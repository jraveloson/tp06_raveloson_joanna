var rv = Object.defineProperty, ov = Object.defineProperties; var iv = Object.getOwnPropertyDescriptors; var Ku = Object.getOwnPropertySymbols; var sv = Object.prototype.hasOwnProperty, av = Object.prototype.propertyIsEnumerable; var Ju = (e, t, n) => t in e ? rv(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, m = (e, t) => { for (var n in t ||= {}) sv.call(t, n) && Ju(e, n, t[n]); if (Ku) for (var n of Ku(t)) av.call(t, n) && Ju(e, n, t[n]); return e }, P = (e, t) => ov(e, iv(t)); function ba(e, t) { return Object.is(e, t) } var te = null, So = !1, _a = 1, Re = Symbol("SIGNAL"); function F(e) { let t = te; return te = e, t } function Ia() { return te } var dr = { version: 0, lastCleanEpoch: 0, dirty: !1, producerNode: void 0, producerLastReadVersion: void 0, producerIndexOfThis: void 0, nextProducerIndex: 0, liveConsumerNode: void 0, liveConsumerIndexOfThis: void 0, consumerAllowSignalWrites: !1, consumerIsAlwaysLive: !1, kind: "unknown", producerMustRecompute: () => !1, producerRecomputeValue: () => { }, consumerMarkedDirty: () => { }, consumerOnSignalRead: () => { } }; function fr(e) { if (So) throw new Error(""); if (te === null) return; te.consumerOnSignalRead(e); let t = te.nextProducerIndex++; if (Ao(te), t < te.producerNode.length && te.producerNode[t] !== e && ur(te)) { let n = te.producerNode[t]; xo(n, te.producerIndexOfThis[t]) } te.producerNode[t] !== e && (te.producerNode[t] = e, te.producerIndexOfThis[t] = ur(te) ? ed(e, te, t) : 0), te.producerLastReadVersion[t] = e.version } function Xu() { _a++ } function Ma(e) { if (!(ur(e) && !e.dirty) && !(!e.dirty && e.lastCleanEpoch === _a)) { if (!e.producerMustRecompute(e) && !xa(e)) { wa(e); return } e.producerRecomputeValue(e), wa(e) } } function Sa(e) { if (e.liveConsumerNode === void 0) return; let t = So; So = !0; try { for (let n of e.liveConsumerNode) n.dirty || lv(n) } finally { So = t } } function Ta() { return te?.consumerAllowSignalWrites !== !1 } function lv(e) { e.dirty = !0, Sa(e), e.consumerMarkedDirty?.(e) } function wa(e) { e.dirty = !1, e.lastCleanEpoch = _a } function No(e) { return e && (e.nextProducerIndex = 0), F(e) } function Na(e, t) { if (F(t), !(!e || e.producerNode === void 0 || e.producerIndexOfThis === void 0 || e.producerLastReadVersion === void 0)) { if (ur(e)) for (let n = e.nextProducerIndex; n < e.producerNode.length; n++)xo(e.producerNode[n], e.producerIndexOfThis[n]); for (; e.producerNode.length > e.nextProducerIndex;)e.producerNode.pop(), e.producerLastReadVersion.pop(), e.producerIndexOfThis.pop() } } function xa(e) { Ao(e); for (let t = 0; t < e.producerNode.length; t++) { let n = e.producerNode[t], r = e.producerLastReadVersion[t]; if (r !== n.version || (Ma(n), r !== n.version)) return !0 } return !1 } function Aa(e) { if (Ao(e), ur(e)) for (let t = 0; t < e.producerNode.length; t++)xo(e.producerNode[t], e.producerIndexOfThis[t]); e.producerNode.length = e.producerLastReadVersion.length = e.producerIndexOfThis.length = 0, e.liveConsumerNode && (e.liveConsumerNode.length = e.liveConsumerIndexOfThis.length = 0) } function ed(e, t, n) { if (td(e), e.liveConsumerNode.length === 0 && nd(e)) for (let r = 0; r < e.producerNode.length; r++)e.producerIndexOfThis[r] = ed(e.producerNode[r], e, r); return e.liveConsumerIndexOfThis.push(n), e.liveConsumerNode.push(t) - 1 } function xo(e, t) { if (td(e), e.liveConsumerNode.length === 1 && nd(e)) for (let r = 0; r < e.producerNode.length; r++)xo(e.producerNode[r], e.producerIndexOfThis[r]); let n = e.liveConsumerNode.length - 1; if (e.liveConsumerNode[t] = e.liveConsumerNode[n], e.liveConsumerIndexOfThis[t] = e.liveConsumerIndexOfThis[n], e.liveConsumerNode.length--, e.liveConsumerIndexOfThis.length--, t < e.liveConsumerNode.length) { let r = e.liveConsumerIndexOfThis[t], o = e.liveConsumerNode[t]; Ao(o), o.producerIndexOfThis[r] = t } } function ur(e) { return e.consumerIsAlwaysLive || (e?.liveConsumerNode?.length ?? 0) > 0 } function Ao(e) { e.producerNode ??= [], e.producerIndexOfThis ??= [], e.producerLastReadVersion ??= [] } function td(e) { e.liveConsumerNode ??= [], e.liveConsumerIndexOfThis ??= [] } function nd(e) { return e.producerNode !== void 0 } function Ra(e, t) { let n = Object.create(cv); n.computation = e, t !== void 0 && (n.equal = t); let r = () => { if (Ma(n), fr(n), n.value === To) throw n.error; return n.value }; return r[Re] = n, r } var Ca = Symbol("UNSET"), Ea = Symbol("COMPUTING"), To = Symbol("ERRORED"), cv = P(m({}, dr), { value: Ca, dirty: !0, error: null, equal: ba, kind: "computed", producerMustRecompute(e) { return e.value === Ca || e.value === Ea }, producerRecomputeValue(e) { if (e.value === Ea) throw new Error("Detected cycle in computations."); let t = e.value; e.value = Ea; let n = No(e), r, o = !1; try { r = e.computation(), F(null), o = t !== Ca && t !== To && r !== To && e.equal(t, r) } catch (i) { r = To, e.error = i } finally { Na(e, n) } if (o) { e.value = t; return } e.value = r, e.version++ } }); function uv() { throw new Error } var rd = uv; function od(e) { rd(e) } function Oa(e) { rd = e } var dv = null; function Pa(e, t) { let n = Object.create(Ro); n.value = e, t !== void 0 && (n.equal = t); let r = () => (fr(n), n.value); return r[Re] = n, r } function hr(e, t) { Ta() || od(e), e.equal(e.value, t) || (e.value = t, fv(e)) } function Fa(e, t) { Ta() || od(e), hr(e, t(e.value)) } var Ro = P(m({}, dr), { equal: ba, value: void 0, kind: "signal" }); function fv(e) { e.version++, Xu(), Sa(e), dv?.() } function ka(e) { let t = F(null); try { return e() } finally { F(t) } } var La; function pr() { return La } function at(e) { let t = La; return La = e, t } var Oo = Symbol("NotFound"); function N(e) { return typeof e == "function" } function pn(e) { let n = e(r => { Error.call(r), r.stack = new Error().stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } var Po = pn(e => function (n) {
  e(this), this.message = n ? `${n.length} errors occurred during unsubscription:
${n.map((r, o) => `${o + 1}) ${r.toString()}`).join(`
  `)}` : "", this.name = "UnsubscriptionError", this.errors = n
}); function gr(e, t) { if (e) { let n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } var Q = class e { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; let { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (let i of n) i.remove(this); else n.remove(this); let { initialTeardown: r } = this; if (N(r)) try { r() } catch (i) { t = i instanceof Po ? i.errors : [i] } let { _finalizers: o } = this; if (o) { this._finalizers = null; for (let i of o) try { id(i) } catch (s) { t = t ?? [], s instanceof Po ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new Po(t) } } add(t) { var n; if (t && t !== this) if (this.closed) id(t); else { if (t instanceof e) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t) } } _hasParent(t) { let { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { let { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { let { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && gr(n, t) } remove(t) { let { _finalizers: n } = this; n && gr(n, t), t instanceof e && t._removeParent(this) } }; Q.EMPTY = (() => { let e = new Q; return e.closed = !0, e })(); var Va = Q.EMPTY; function Fo(e) { return e instanceof Q || e && "closed" in e && N(e.remove) && N(e.add) && N(e.unsubscribe) } function id(e) { N(e) ? e() : e.unsubscribe() } var je = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }; var gn = { setTimeout(e, t, ...n) { let { delegate: r } = gn; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { let { delegate: t } = gn; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function ko(e) { gn.setTimeout(() => { let { onUnhandledError: t } = je; if (t) t(e); else throw e }) } function mr() { } var sd = ja("C", void 0, void 0); function ad(e) { return ja("E", void 0, e) } function ld(e) { return ja("N", e, void 0) } function ja(e, t, n) { return { kind: e, value: t, error: n } } var $t = null; function mn(e) { if (je.useDeprecatedSynchronousErrorHandling) { let t = !$t; if (t && ($t = { errorThrown: !1, error: null }), e(), t) { let { errorThrown: n, error: r } = $t; if ($t = null, n) throw r } } else e() } function cd(e) { je.useDeprecatedSynchronousErrorHandling && $t && ($t.errorThrown = !0, $t.error = e) } var Ht = class extends Q { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, Fo(t) && t.add(this)) : this.destination = yv } static create(t, n, r) { return new vn(t, n, r) } next(t) { this.isStopped ? Ua(ld(t), this) : this._next(t) } error(t) { this.isStopped ? Ua(ad(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? Ua(sd, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } }, mv = Function.prototype.bind; function Ba(e, t) { return mv.call(e, t) } var $a = class { constructor(t) { this.partialObserver = t } next(t) { let { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { Lo(r) } } error(t) { let { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { Lo(r) } else Lo(t) } complete() { let { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { Lo(n) } } }, vn = class extends Ht { constructor(t, n, r) { super(); let o; if (N(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && je.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && Ba(t.next, i), error: t.error && Ba(t.error, i), complete: t.complete && Ba(t.complete, i) }) : o = t } this.destination = new $a(o) } }; function Lo(e) { je.useDeprecatedSynchronousErrorHandling ? cd(e) : ko(e) } function vv(e) { throw e } function Ua(e, t) { let { onStoppedNotification: n } = je; n && gn.setTimeout(() => n(e, t)) } var yv = { closed: !0, next: mr, error: vv, complete: mr }; var yn = typeof Symbol == "function" && Symbol.observable || "@@observable"; function be(e) { return e } function Ha(...e) { return za(e) } function za(e) { return e.length === 0 ? be : e.length === 1 ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } } var B = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { let r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { let i = Cv(n) ? n : new vn(n, r, o); return mn(() => { let { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return r = ud(r), new r((o, i) => { let s = new vn({ next: a => { try { n(a) } catch (l) { i(l), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n) } [yn]() { return this } pipe(...n) { return za(n)(this) } toPromise(n) { return n = ud(n), new n((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function ud(e) { var t; return (t = e ?? je.Promise) !== null && t !== void 0 ? t : Promise } function Dv(e) { return e && N(e.next) && N(e.error) && N(e.complete) } function Cv(e) { return e && e instanceof Ht || Dv(e) && Fo(e) } function Ga(e) { return N(e?.lift) } function V(e) { return t => { if (Ga(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function k(e, t, n, r, o) { return new qa(e, t, n, r, o) } var qa = class extends Ht { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (l) { t.error(l) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (l) { t.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { let { closed: n } = this; super.unsubscribe(), !n && ((t = this.onFinalize) === null || t === void 0 || t.call(this)) } } }; function Dn() { return V((e, t) => { let n = null; e._refCount++; let r = k(t, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) { n = null; return } let o = e._connection, i = n; n = null, o && (!i || o === i) && o.unsubscribe(), t.unsubscribe() }); e.subscribe(r), r.closed || (n = e.connect()) }) } var Cn = class extends B { constructor(t, n) { super(), this.source = t, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, Ga(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { let t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; let { _connection: t } = this; this._subject = this._connection = null, t?.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new Q; let n = this.getSubject(); t.add(this.source.subscribe(k(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), t.closed && (this._connection = null, t = Q.EMPTY) } return t } refCount() { return Dn()(this) } }; var dd = pn(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); var K = (() => { class e extends B { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { let r = new Vo(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new dd } next(n) { mn(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (let r of this.currentObservers) r.next(n) } }) } error(n) { mn(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; let { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { mn(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; let { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { let { hasError: r, isStopped: o, observers: i } = this; return r || o ? Va : (this.currentObservers = null, i.push(n), new Q(() => { this.currentObservers = null, gr(i, n) })) } _checkFinalizedStatuses(n) { let { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { let n = new B; return n.source = this, n } } return e.create = (t, n) => new Vo(t, n), e })(), Vo = class extends K { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; (r = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || r === void 0 || r.call(n, t) } error(t) { var n, r; (r = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || r === void 0 || r.call(n, t) } complete() { var t, n; (n = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || n === void 0 || n.call(t) } _subscribe(t) { var n, r; return (r = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t)) !== null && r !== void 0 ? r : Va } }; var ne = class extends K { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { let n = super._subscribe(t); return !n.closed && t.next(this._value), n } getValue() { let { hasError: t, thrownError: n, _value: r } = this; if (t) throw n; return this._throwIfClosed(), r } next(t) { super.next(this._value = t) } }; var me = new B(e => e.complete()); function fd(e) { return e && N(e.schedule) } function hd(e) { return e[e.length - 1] } function jo(e) { return N(hd(e)) ? e.pop() : void 0 } function wt(e) { return fd(hd(e)) ? e.pop() : void 0 } function gd(e, t, n, r) { function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) } return new (n || (n = Promise))(function (i, s) { function a(u) { try { c(r.next(u)) } catch (f) { s(f) } } function l(u) { try { c(r.throw(u)) } catch (f) { s(f) } } function c(u) { u.done ? i(u.value) : o(u.value).then(a, l) } c((r = r.apply(e, t || [])).next()) }) } function pd(e) { var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && typeof e.length == "number") return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") } function zt(e) { return this instanceof zt ? (this.v = e, this) : new zt(e) } function md(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var r = n.apply(e, t || []), o, i = []; return o = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", s), o[Symbol.asyncIterator] = function () { return this }, o; function s(d) { return function (p) { return Promise.resolve(p).then(d, f) } } function a(d, p) { r[d] && (o[d] = function (y) { return new Promise(function (I, j) { i.push([d, y, I, j]) > 1 || l(d, y) }) }, p && (o[d] = p(o[d]))) } function l(d, p) { try { c(r[d](p)) } catch (y) { h(i[0][3], y) } } function c(d) { d.value instanceof zt ? Promise.resolve(d.value.v).then(u, f) : h(i[0][2], d) } function u(d) { l("next", d) } function f(d) { l("throw", d) } function h(d, p) { d(p), i.shift(), i.length && l(i[0][0], i[0][1]) } } function vd(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t = e[Symbol.asyncIterator], n; return t ? t.call(e) : (e = typeof pd == "function" ? pd(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, l) { s = e[i](s), o(a, l, s.done, s.value) }) } } function o(i, s, a, l) { Promise.resolve(l).then(function (c) { i({ value: c, done: a }) }, s) } } var Bo = e => e && typeof e.length == "number" && typeof e != "function"; function Uo(e) { return N(e?.then) } function $o(e) { return N(e[yn]) } function Ho(e) { return Symbol.asyncIterator && N(e?.[Symbol.asyncIterator]) } function zo(e) { return new TypeError(`You provided ${e !== null && typeof e == "object" ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } function Ev() { return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator } var Go = Ev(); function qo(e) { return N(e?.[Go]) } function Wo(e) { return md(this, arguments, function* () { let n = e.getReader(); try { for (; ;) { let { value: r, done: o } = yield zt(n.read()); if (o) return yield zt(void 0); yield yield zt(r) } } finally { n.releaseLock() } }) } function Zo(e) { return N(e?.getReader) } function J(e) { if (e instanceof B) return e; if (e != null) { if ($o(e)) return wv(e); if (Bo(e)) return bv(e); if (Uo(e)) return _v(e); if (Ho(e)) return yd(e); if (qo(e)) return Iv(e); if (Zo(e)) return Mv(e) } throw zo(e) } function wv(e) { return new B(t => { let n = e[yn](); if (N(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) } function bv(e) { return new B(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) } function _v(e) { return new B(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, ko) }) } function Iv(e) { return new B(t => { for (let n of e) if (t.next(n), t.closed) return; t.complete() }) } function yd(e) { return new B(t => { Sv(e, t).catch(n => t.error(n)) }) } function Mv(e) { return yd(Wo(e)) } function Sv(e, t) { var n, r, o, i; return gd(this, void 0, void 0, function* () { try { for (n = vd(e); r = yield n.next(), !r.done;) { let s = r.value; if (t.next(s), t.closed) return } } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) } function ve(e, t, n, r = 0, o = !1) { let i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function Yo(e, t = 0) { return V((n, r) => { n.subscribe(k(r, o => ve(r, e, () => r.next(o), t), () => ve(r, e, () => r.complete(), t), o => ve(r, e, () => r.error(o), t))) }) } function Qo(e, t = 0) { return V((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function Dd(e, t) { return J(e).pipe(Qo(t), Yo(t)) } function Cd(e, t) { return J(e).pipe(Qo(t), Yo(t)) } function Ed(e, t) { return new B(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) } function wd(e, t) { return new B(n => { let r; return ve(n, t, () => { r = e[Go](), ve(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { n.error(s); return } i ? n.complete() : n.next(o) }, 0, !0) }), () => N(r?.return) && r.return() }) } function Ko(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new B(n => { ve(n, t, () => { let r = e[Symbol.asyncIterator](); ve(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function bd(e, t) { return Ko(Wo(e), t) } function _d(e, t) { if (e != null) { if ($o(e)) return Dd(e, t); if (Bo(e)) return Ed(e, t); if (Uo(e)) return Cd(e, t); if (Ho(e)) return Ko(e, t); if (qo(e)) return wd(e, t); if (Zo(e)) return bd(e, t) } throw zo(e) } function W(e, t) { return t ? _d(e, t) : J(e) } function S(...e) { let t = wt(e); return W(e, t) } function En(e, t) { let n = N(e) ? e : () => e, r = o => o.error(n()); return new B(t ? o => t.schedule(r, 0, o) : r) } function Wa(e) { return !!e && (e instanceof B || N(e.lift) && N(e.subscribe)) } var lt = pn(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function T(e, t) { return V((n, r) => { let o = 0; n.subscribe(k(r, i => { r.next(e.call(t, i, o++)) })) }) } var { isArray: Tv } = Array; function Nv(e, t) { return Tv(t) ? e(...t) : e(t) } function Jo(e) { return T(t => Nv(e, t)) } var { isArray: xv } = Array, { getPrototypeOf: Av, prototype: Rv, keys: Ov } = Object; function Xo(e) { if (e.length === 1) { let t = e[0]; if (xv(t)) return { args: t, keys: null }; if (Pv(t)) { let n = Ov(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } } function Pv(e) { return e && typeof e == "object" && Av(e) === Rv } function ei(e, t) { return e.reduce((n, r, o) => (n[r] = t[o], n), {}) } function ti(...e) { let t = wt(e), n = jo(e), { args: r, keys: o } = Xo(e); if (r.length === 0) return W([], t); let i = new B(Fv(r, t, o ? s => ei(o, s) : be)); return n ? i.pipe(Jo(n)) : i } function Fv(e, t, n = be) { return r => { Id(t, () => { let { length: o } = e, i = new Array(o), s = o, a = o; for (let l = 0; l < o; l++)Id(t, () => { let c = W(e[l], t), u = !1; c.subscribe(k(r, f => { i[l] = f, u || (u = !0, a--), a || r.next(n(i.slice())) }, () => { --s || r.complete() })) }, r) }, r) } } function Id(e, t, n) { e ? ve(n, e, t) : t() } function Md(e, t, n, r, o, i, s, a) { let l = [], c = 0, u = 0, f = !1, h = () => { f && !l.length && !c && t.complete() }, d = y => c < r ? p(y) : l.push(y), p = y => { i && t.next(y), c++; let I = !1; J(n(y, u++)).subscribe(k(t, j => { o?.(j), i ? d(j) : t.next(j) }, () => { I = !0 }, void 0, () => { if (I) try { for (c--; l.length && c < r;) { let j = l.shift(); s ? ve(t, s, () => p(j)) : p(j) } h() } catch (j) { t.error(j) } })) }; return e.subscribe(k(t, d, () => { f = !0, h() })), () => { a?.() } } function re(e, t, n = 1 / 0) { return N(t) ? re((r, o) => T((i, s) => t(r, i, o, s))(J(e(r, o))), n) : (typeof t == "number" && (n = t), V((r, o) => Md(r, o, e, n))) } function Sd(e = 1 / 0) { return re(be, e) } function Td() { return Sd(1) } function wn(...e) { return Td()(W(e, wt(e))) } function ni(e) { return new B(t => { J(e()).subscribe(t) }) } function Za(...e) { let t = jo(e), { args: n, keys: r } = Xo(e), o = new B(i => { let { length: s } = n; if (!s) { i.complete(); return } let a = new Array(s), l = s, c = s; for (let u = 0; u < s; u++) { let f = !1; J(n[u]).subscribe(k(i, h => { f || (f = !0, c--), a[u] = h }, () => l--, void 0, () => { (!l || !f) && (c || i.next(r ? ei(r, a) : a), i.complete()) })) } }); return t ? o.pipe(Jo(t)) : o } function _e(e, t) { return V((n, r) => { let o = 0; n.subscribe(k(r, i => e.call(t, i, o++) && r.next(i))) }) } function bt(e) { return V((t, n) => { let r = null, o = !1, i; r = t.subscribe(k(n, void 0, void 0, s => { i = J(e(s, bt(e)(t))), r ? (r.unsubscribe(), r = null, i.subscribe(n)) : o = !0 })), o && (r.unsubscribe(), r = null, i.subscribe(n)) }) } function Nd(e, t, n, r, o) { return (i, s) => { let a = n, l = t, c = 0; i.subscribe(k(s, u => { let f = c++; l = a ? e(l, u, f) : (a = !0, u), r && s.next(l) }, o && (() => { a && s.next(l), s.complete() }))) } } function _t(e, t) { return N(t) ? re(e, t, 1) : re(e, 1) } function It(e) { return V((t, n) => { let r = !1; t.subscribe(k(n, o => { r = !0, n.next(o) }, () => { r || n.next(e), n.complete() })) }) } function ct(e) { return e <= 0 ? () => me : V((t, n) => { let r = 0; t.subscribe(k(n, o => { ++r <= e && (n.next(o), e <= r && n.complete()) })) }) } function ri(e = kv) { return V((t, n) => { let r = !1; t.subscribe(k(n, o => { r = !0, n.next(o) }, () => r ? n.complete() : n.error(e()))) }) } function kv() { return new lt } function Gt(e) { return V((t, n) => { try { t.subscribe(n) } finally { n.add(e) } }) } function ut(e, t) { let n = arguments.length >= 2; return r => r.pipe(e ? _e((o, i) => e(o, i, r)) : be, ct(1), n ? It(t) : ri(() => new lt)) } function bn(e) { return e <= 0 ? () => me : V((t, n) => { let r = []; t.subscribe(k(n, o => { r.push(o), e < r.length && r.shift() }, () => { for (let o of r) n.next(o); n.complete() }, void 0, () => { r = null })) }) } function Ya(e, t) { let n = arguments.length >= 2; return r => r.pipe(e ? _e((o, i) => e(o, i, r)) : be, bn(1), n ? It(t) : ri(() => new lt)) } function Qa(e, t) { return V(Nd(e, t, arguments.length >= 2, !0)) } function Ka(...e) { let t = wt(e); return V((n, r) => { (t ? wn(e, n, t) : wn(e, n)).subscribe(r) }) } function se(e, t) { return V((n, r) => { let o = null, i = 0, s = !1, a = () => s && !o && r.complete(); n.subscribe(k(r, l => { o?.unsubscribe(); let c = 0, u = i++; J(e(l, u)).subscribe(o = k(r, f => r.next(t ? t(l, f, u, c++) : f), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function Ja(e) { return V((t, n) => { J(e).subscribe(k(n, () => n.complete(), mr)), !n.closed && t.subscribe(n) }) } function ce(e, t, n) { let r = N(e) || t || n ? { next: e, error: t, complete: n } : e; return r ? V((o, i) => { var s; (s = r.subscribe) === null || s === void 0 || s.call(r); let a = !0; o.subscribe(k(i, l => { var c; (c = r.next) === null || c === void 0 || c.call(r, l), i.next(l) }, () => { var l; a = !1, (l = r.complete) === null || l === void 0 || l.call(r), i.complete() }, l => { var c; a = !1, (c = r.error) === null || c === void 0 || c.call(r, l), i.error(l) }, () => { var l, c; a && ((l = r.unsubscribe) === null || l === void 0 || l.call(r)), (c = r.finalize) === null || c === void 0 || c.call(r) })) }) : be } var Cf = "https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss", v = class extends Error { code; constructor(t, n) { super(Vv(t, n)), this.code = t } }; function Lv(e) { return `NG0${Math.abs(e)}` } function Vv(e, t) { return `${Lv(e)}${t ? ": " + t : ""}` } var Ef = Symbol("InputSignalNode#UNSET"), jv = P(m({}, Ro), { transformFn: void 0, applyValueToInputSignal(e, t) { hr(e, t) } }); function wf(e, t) { let n = Object.create(jv); n.value = e, n.transformFn = t?.transform; function r() { if (fr(n), n.value === Ef) { let o = null; throw new v(-950, o) } return n.value } return r[Re] = n, r } function Nr(e) { return { toString: e }.toString() } var oi = "__parameters__"; function Bv(e) { return function (...n) { if (e) { let r = e(...n); for (let o in r) this[o] = r[o] } } } function bf(e, t, n) { return Nr(() => { let r = Bv(t); function o(...i) { if (this instanceof o) return r.apply(this, i), this; let s = new o(...i); return a.annotation = s, a; function a(l, c, u) { let f = l.hasOwnProperty(oi) ? l[oi] : Object.defineProperty(l, oi, { value: [] })[oi]; for (; f.length <= u;)f.push(null); return (f[u] = f[u] || []).push(s), l } } return o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } var hl = globalThis; function H(e) { for (let t in e) if (e[t] === H) return t; throw Error("Could not find renamed property on target object.") } function Uv(e, t) { for (let n in t) t.hasOwnProperty(n) && !e.hasOwnProperty(n) && (e[n] = t[n]) } function De(e) {
  if (typeof e == "string") return e; if (Array.isArray(e)) return `[${e.map(De).join(", ")}]`; if (e == null) return "" + e; let t = e.overriddenName || e.name; if (t) return `${t}`; let n = e.toString(); if (n == null) return "" + n; let r = n.indexOf(`
`); return r >= 0 ? n.slice(0, r) : n
} function xd(e, t) { return e ? t ? `${e} ${t}` : e : t || "" } var $v = H({ __forward_ref__: H }); function Ke(e) { return e.__forward_ref__ = Ke, e.toString = function () { return De(this()) }, e } function de(e) { return _f(e) ? e() : e } function _f(e) { return typeof e == "function" && e.hasOwnProperty($v) && e.__forward_ref__ === Ke } function _(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function Je(e) { return { providers: e.providers || [], imports: e.imports || [] } } function ji(e) { return Ad(e, Mf) || Ad(e, Sf) } function If(e) { return ji(e) !== null } function Ad(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function Hv(e) { let t = e && (e[Mf] || e[Sf]); return t || null } function Rd(e) { return e && (e.hasOwnProperty(Od) || e.hasOwnProperty(zv)) ? e[Od] : null } var Mf = H({ \u0275prov: H }), Od = H({ \u0275inj: H }), Sf = H({ ngInjectableDef: H }), zv = H({ ngInjectorDef: H }), D = class { _desc; ngMetadataName = "InjectionToken"; \u0275prov; constructor(t, n) { this._desc = t, this.\u0275prov = void 0, typeof n == "number" ? this.__NG_ELEMENT_ID__ = n : n !== void 0 && (this.\u0275prov = _({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } }; function Tf(e) { return e && !!e.\u0275providers } var Gv = H({ \u0275cmp: H }), qv = H({ \u0275dir: H }), Wv = H({ \u0275pipe: H }), Zv = H({ \u0275mod: H }), fi = H({ \u0275fac: H }), Cr = H({ __NG_ELEMENT_ID__: H }), Pd = H({ __NG_ENV_ID__: H }); function Tn(e) { return typeof e == "string" ? e : e == null ? "" : String(e) } function Yv(e) { return typeof e == "function" ? e.name || e.toString() : typeof e == "object" && e != null && typeof e.type == "function" ? e.type.name || e.type.toString() : Tn(e) } function Nf(e, t) { throw new v(-200, e) } function ec(e, t) { throw new v(-201, !1) } var R = function (e) { return e[e.Default = 0] = "Default", e[e.Host = 1] = "Host", e[e.Self = 2] = "Self", e[e.SkipSelf = 4] = "SkipSelf", e[e.Optional = 8] = "Optional", e }(R || {}), pl; function xf() { return pl } function ye(e) { let t = pl; return pl = e, t } function Af(e, t, n) { let r = ji(e); if (r && r.providedIn == "root") return r.value === void 0 ? r.value = r.factory() : r.value; if (n & R.Optional) return null; if (t !== void 0) return t; ec(e, "Injector") } var Qv = {}, qt = Qv, gl = "__NG_DI_FLAG__", hi = class { injector; constructor(t) { this.injector = t } retrieve(t, n) { let r = n; return this.injector.get(t, r.optional ? Oo : qt, r) } }, pi = "ngTempTokenPath", Kv = "ngTokenPath", Jv = /\n/gm, Xv = "\u0275", Fd = "__source"; function ey(e, t = R.Default) { if (pr() === void 0) throw new v(-203, !1); if (pr() === null) return Af(e, void 0, t); { let n = pr(), r; return n instanceof hi ? r = n.injector : r = n, r.get(e, t & R.Optional ? null : void 0, t) } } function M(e, t = R.Default) { return (xf() || ey)(de(e), t) } function g(e, t = R.Default) { return M(e, Bi(t)) } function Bi(e) { return typeof e > "u" || typeof e == "number" ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function ml(e) { let t = []; for (let n = 0; n < e.length; n++) { let r = de(e[n]); if (Array.isArray(r)) { if (r.length === 0) throw new v(900, !1); let o, i = R.Default; for (let s = 0; s < r.length; s++) { let a = r[s], l = ty(a); typeof l == "number" ? l === -1 ? o = a.token : i |= l : o = a } t.push(M(o, i)) } else t.push(M(r)) } return t } function Rf(e, t) { return e[gl] = t, e.prototype[gl] = t, e } function ty(e) { return e[gl] } function ny(e, t, n, r) {
  let o = e[pi]; throw t[Fd] && o.unshift(t[Fd]), e.message = ry(`
`+ e.message, o, n, r), e[Kv] = o, e[pi] = null, e
} function ry(e, t, n, r = null) {
  e = e && e.charAt(0) === `
`&& e.charAt(1) == Xv ? e.slice(2) : e; let o = De(t); if (Array.isArray(t)) o = t.map(De).join(" -> "); else if (typeof t == "object") { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + (typeof a == "string" ? JSON.stringify(a) : De(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(Jv, `
  `)}`
} var oy = Rf(bf("Optional"), 8); var iy = Rf(bf("SkipSelf"), 4); function Zt(e, t) { let n = e.hasOwnProperty(fi); return n ? e[fi] : null } function tc(e, t) { e.forEach(n => Array.isArray(n) ? tc(n, t) : t(n)) } function Of(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function gi(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } function sy(e, t, n, r) { let o = e.length; if (o == t) e.push(n, r); else if (o === 1) e.push(r, e[0]), e[0] = n; else { for (o--, e.push(e[o - 1], e[o]); o > t;) { let i = o - 2; e[o] = e[i], o-- } e[t] = n, e[t + 1] = r } } function ay(e, t, n) { let r = xr(e, t); return r >= 0 ? e[r | 1] = n : (r = ~r, sy(e, r, t, n)), r } function Xa(e, t) { let n = xr(e, t); if (n >= 0) return e[n | 1] } function xr(e, t) { return ly(e, t, 1) } function ly(e, t, n) { let r = 0, o = e.length >> n; for (; o !== r;) { let i = r + (o - r >> 1), s = e[i << n]; if (t === s) return i << n; s > t ? o = i : r = i + 1 } return ~(o << n) } var Yt = {}, Oe = [], Er = new D(""), Pf = new D("", -1), Ff = new D(""), mi = class { get(t, n = qt) { if (n === qt) { let r = new Error(`NullInjectorError: No provider for ${De(t)}!`); throw r.name = "NullInjectorError", r } return n } }; function kf(e, t) { let n = e[Zv] || null; if (!n && t === !0) throw new Error(`Type ${De(e)} does not have '\u0275mod' property.`); return n } function Nn(e) { return e[Gv] || null } function cy(e) { return e[qv] || null } function uy(e) { return e[Wv] || null } function Ar(e) { return { \u0275providers: e } } function dy(...e) { return { \u0275providers: Lf(!0, e), \u0275fromNgModule: !0 } } function Lf(e, ...t) { let n = [], r = new Set, o, i = s => { n.push(s) }; return tc(t, s => { let a = s; vl(a, i, [], r) && (o ||= [], o.push(a)) }), o !== void 0 && Vf(o, i), n } function Vf(e, t) { for (let n = 0; n < e.length; n++) { let { ngModule: r, providers: o } = e[n]; nc(o, i => { t(i, r) }) } } function vl(e, t, n, r) { if (e = de(e), !e) return !1; let o = null, i = Rd(e), s = !i && Nn(e); if (!i && !s) { let l = e.ngModule; if (i = Rd(l), i) o = l; else return !1 } else { if (s && !s.standalone) return !1; o = e } let a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { let l = typeof s.dependencies == "function" ? s.dependencies() : s.dependencies; for (let c of l) vl(c, t, n, r) } } else if (i) { if (i.imports != null && !a) { r.add(o); let c; try { tc(i.imports, u => { vl(u, t, n, r) && (c ||= [], c.push(u)) }) } finally { } c !== void 0 && Vf(c, t) } if (!a) { let c = Zt(o) || (() => new o); t({ provide: o, useFactory: c, deps: Oe }, o), t({ provide: Ff, useValue: o, multi: !0 }, o), t({ provide: Er, useValue: () => M(o), multi: !0 }, o) } let l = i.providers; if (l != null && !a) { let c = e; nc(l, u => { t(u, c) }) } } else return !1; return o !== e && e.providers !== void 0 } function nc(e, t) { for (let n of e) Tf(n) && (n = n.\u0275providers), Array.isArray(n) ? nc(n, t) : t(n) } var fy = H({ provide: String, useValue: H }); function jf(e) { return e !== null && typeof e == "object" && fy in e } function hy(e) { return !!(e && e.useExisting) } function py(e) { return !!(e && e.useFactory) } function xn(e) { return typeof e == "function" } function gy(e) { return !!e.useClass } var Ui = new D(""), ai = {}, kd = {}, el; function rc() { return el === void 0 && (el = new mi), el } var fe = class { }, wr = class extends fe { parent; source; scopes; records = new Map; _ngOnDestroyHooks = new Set; _onDestroyHooks = []; get destroyed() { return this._destroyed } _destroyed = !1; injectorDefTypes; constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, Dl(t, s => this.processProvider(s)), this.records.set(Pf, _n(void 0, this)), o.has("environment") && this.records.set(fe, _n(void 0, this)); let i = this.records.get(Ui); i != null && typeof i.value == "string" && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(Ff, Oe, R.Self)) } retrieve(t, n) { let r = n; return this.get(t, r.optional ? Oo : qt, r) } destroy() { yr(this), this._destroyed = !0; let t = F(null); try { for (let r of this._ngOnDestroyHooks) r.ngOnDestroy(); let n = this._onDestroyHooks; this._onDestroyHooks = []; for (let r of n) r() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), F(t) } } onDestroy(t) { return yr(this), this._onDestroyHooks.push(t), () => this.removeOnDestroy(t) } runInContext(t) { yr(this); let n = at(this), r = ye(void 0), o; try { return t() } finally { at(n), ye(r) } } get(t, n = qt, r = R.Default) { if (yr(this), t.hasOwnProperty(Pd)) return t[Pd](this); r = Bi(r); let o, i = at(this), s = ye(void 0); try { if (!(r & R.SkipSelf)) { let l = this.records.get(t); if (l === void 0) { let c = Cy(t) && ji(t); c && this.injectableDefInScope(c) ? l = _n(yl(t), ai) : l = null, this.records.set(t, l) } if (l != null) return this.hydrate(t, l, r) } let a = r & R.Self ? rc() : this.parent; return n = r & R.Optional && n === qt ? null : n, a.get(t, n) } catch (a) { if (a.name === "NullInjectorError") { if ((a[pi] = a[pi] || []).unshift(De(t)), i) throw a; return ny(a, t, "R3InjectorError", this.source) } else throw a } finally { ye(s), at(i) } } resolveInjectorInitializers() { let t = F(null), n = at(this), r = ye(void 0), o; try { let i = this.get(Er, Oe, R.Self); for (let s of i) s() } finally { at(n), ye(r), F(t) } } toString() { let t = [], n = this.records; for (let r of n.keys()) t.push(De(r)); return `R3Injector[${t.join(", ")}]` } processProvider(t) { t = de(t); let n = xn(t) ? t : de(t && t.provide), r = vy(t); if (!xn(t) && t.multi === !0) { let o = this.records.get(n); o || (o = _n(void 0, ai, !0), o.factory = () => ml(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n, r) { let o = F(null); try { return n.value === kd ? Nf(De(t)) : n.value === ai && (n.value = kd, n.value = n.factory(void 0, r)), typeof n.value == "object" && n.value && Dy(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } finally { F(o) } } injectableDefInScope(t) { if (!t.providedIn) return !1; let n = de(t.providedIn); return typeof n == "string" ? n === "any" || this.scopes.has(n) : this.injectorDefTypes.has(n) } removeOnDestroy(t) { let n = this._onDestroyHooks.indexOf(t); n !== -1 && this._onDestroyHooks.splice(n, 1) } }; function yl(e) { let t = ji(e), n = t !== null ? t.factory : Zt(e); if (n !== null) return n; if (e instanceof D) throw new v(204, !1); if (e instanceof Function) return my(e); throw new v(204, !1) } function my(e) { if (e.length > 0) throw new v(204, !1); let n = Hv(e); return n !== null ? () => n.factory(e) : () => new e } function vy(e) { if (jf(e)) return _n(void 0, e.useValue); { let t = Bf(e); return _n(t, ai) } } function Bf(e, t, n) { let r; if (xn(e)) { let o = de(e); return Zt(o) || yl(o) } else if (jf(e)) r = () => de(e.useValue); else if (py(e)) r = () => e.useFactory(...ml(e.deps || [])); else if (hy(e)) r = (o, i) => M(de(e.useExisting), i !== void 0 && i & R.Optional ? R.Optional : void 0); else { let o = de(e && (e.useClass || e.provide)); if (yy(e)) r = () => new o(...ml(e.deps)); else return Zt(o) || yl(o) } return r } function yr(e) { if (e.destroyed) throw new v(205, !1) } function _n(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function yy(e) { return !!e.deps } function Dy(e) { return e !== null && typeof e == "object" && typeof e.ngOnDestroy == "function" } function Cy(e) { return typeof e == "function" || typeof e == "object" && e instanceof D } function Dl(e, t) { for (let n of e) Array.isArray(n) ? Dl(n, t) : n && Tf(n) ? Dl(n.\u0275providers, t) : t(n) } function Me(e, t) { let n; e instanceof wr ? (yr(e), n = e) : n = new hi(e); let r, o = at(n), i = ye(void 0); try { return t() } finally { at(o), ye(i) } } function Ey() { return xf() !== void 0 || pr() != null } function wy(e) { return typeof e == "function" } var gt = 0, L = 1, x = 2, he = 3, Ue = 4, $e = 5, vi = 6, yi = 7, Ce = 8, An = 9, dt = 10, ie = 11, br = 12, Ld = 13, Ln = 14, qe = 15, Rn = 16, In = 17, On = 18, $i = 19, Uf = 20, Mt = 21, tl = 22, Di = 23, Pe = 24, nl = 25, Ie = 26, $f = 1; var Qt = 7, Ci = 8, Ei = 9, Fe = 10; function St(e) { return Array.isArray(e) && typeof e[$f] == "object" } function mt(e) { return Array.isArray(e) && e[$f] === !0 } function Hf(e) { return (e.flags & 4) !== 0 } function Vn(e) { return e.componentOffset > -1 } function oc(e) { return (e.flags & 1) === 1 } function We(e) { return !!e.template } function wi(e) { return (e[x] & 512) !== 0 } function jn(e) { return (e[x] & 256) === 256 } var Cl = class { previousValue; currentValue; firstChange; constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } }; function zf(e, t, n, r) { t !== null ? t.applyValueToInputSignal(t, r) : e[n] = r } var vt = (() => { let e = () => Gf; return e.ngInherit = !0, e })(); function Gf(e) { return e.type.prototype.ngOnChanges && (e.setInput = _y), by } function by() { let e = Wf(this), t = e?.current; if (t) { let n = e.previous; if (n === Yt) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function _y(e, t, n, r, o) { let i = this.declaredInputs[r], s = Wf(e) || Iy(e, { previous: Yt, current: null }), a = s.current || (s.current = {}), l = s.previous, c = l[i]; a[i] = new Cl(c && c.currentValue, n, l === Yt), zf(e, t, o, n) } var qf = "__ngSimpleChanges__"; function Wf(e) { return e[qf] || null } function Iy(e, t) { return e[qf] = t } var Vd = null; var z = function (e, t = null, n) { Vd?.(e, t, n) }, My = "svg", Sy = "math"; function Ze(e) { for (; Array.isArray(e);)e = e[gt]; return e } function Zf(e, t) { return Ze(t[e]) } function Xe(e, t) { return Ze(t[e.index]) } function Yf(e, t) { return e.data[t] } function ic(e, t) { return e[t] } function Ty(e, t, n, r) { n >= e.data.length && (e.data[n] = null, e.blueprint[n] = null), t[n] = r } function Ye(e, t) { let n = t[e]; return St(n) ? n : n[gt] } function sc(e) { return (e[x] & 128) === 128 } function Ny(e) { return mt(e[he]) } function bi(e, t) { return t == null ? null : e[t] } function Qf(e) { e[In] = 0 } function Kf(e) { e[x] & 1024 || (e[x] |= 1024, sc(e) && zi(e)) } function xy(e, t) { for (; e > 0;)t = t[Ln], e--; return t } function Hi(e) { return !!(e[x] & 9216 || e[Pe]?.dirty) } function El(e) { e[dt].changeDetectionScheduler?.notify(8), e[x] & 64 && (e[x] |= 1024), Hi(e) && zi(e) } function zi(e) { e[dt].changeDetectionScheduler?.notify(0); let t = Kt(e); for (; t !== null && !(t[x] & 8192 || (t[x] |= 8192, !sc(t)));)t = Kt(t) } function Jf(e, t) { if (jn(e)) throw new v(911, !1); e[Mt] === null && (e[Mt] = []), e[Mt].push(t) } function Ay(e, t) { if (e[Mt] === null) return; let n = e[Mt].indexOf(t); n !== -1 && e[Mt].splice(n, 1) } function Kt(e) { let t = e[he]; return mt(t) ? t[he] : t } function Xf(e) { return e[yi] ??= [] } function eh(e) { return e.cleanup ??= [] } var O = { lFrame: ch(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; var wl = !1; function Ry() { return O.lFrame.elementDepthCount } function Oy() { O.lFrame.elementDepthCount++ } function Py() { O.lFrame.elementDepthCount-- } function th() { return O.bindingsEnabled } function Fy() { return O.skipHydrationRootTNode !== null } function ky(e) { return O.skipHydrationRootTNode === e } function Ly() { O.skipHydrationRootTNode = null } function $() { return O.lFrame.lView } function Ee() { return O.lFrame.tView } function ac(e) { return O.lFrame.contextLView = e, e[Ce] } function lc(e) { return O.lFrame.contextLView = null, e } function Se() { let e = nh(); for (; e !== null && e.type === 64;)e = e.parent; return e } function nh() { return O.lFrame.currentTNode } function Vy() { let e = O.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent } function Rr(e, t) { let n = O.lFrame; n.currentTNode = e, n.isParent = t } function rh() { return O.lFrame.isParent } function jy() { O.lFrame.isParent = !1 } function By() { return O.lFrame.contextLView } function oh() { return wl } function jd(e) { let t = wl; return wl = e, t } function cc() { let e = O.lFrame, t = e.bindingRootIndex; return t === -1 && (t = e.bindingRootIndex = e.tView.bindingStartIndex), t } function Uy() { return O.lFrame.bindingIndex } function $y(e) { return O.lFrame.bindingIndex = e } function Gi() { return O.lFrame.bindingIndex++ } function ih(e) { let t = O.lFrame, n = t.bindingIndex; return t.bindingIndex = t.bindingIndex + e, n } function Hy() { return O.lFrame.inI18n } function zy(e, t) { let n = O.lFrame; n.bindingIndex = n.bindingRootIndex = e, bl(t) } function Gy() { return O.lFrame.currentDirectiveIndex } function bl(e) { O.lFrame.currentDirectiveIndex = e } function qy(e) { let t = O.lFrame.currentDirectiveIndex; return t === -1 ? null : e[t] } function sh(e) { O.lFrame.currentQueryIndex = e } function Wy(e) { let t = e[L]; return t.type === 2 ? t.declTNode : t.type === 1 ? e[$e] : null } function ah(e, t, n) { if (n & R.SkipSelf) { let o = t, i = e; for (; o = o.parent, o === null && !(n & R.Host);)if (o = Wy(i), o === null || (i = i[Ln], o.type & 10)) break; if (o === null) return !1; t = o, e = i } let r = O.lFrame = lh(); return r.currentTNode = t, r.lView = e, !0 } function uc(e) { let t = lh(), n = e[L]; O.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function lh() { let e = O.lFrame, t = e === null ? null : e.child; return t === null ? ch(e) : t } function ch(e) { let t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return e !== null && (e.child = t), t } function uh() { let e = O.lFrame; return O.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } var dh = uh; function dc() { let e = uh(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function Zy(e) { return (O.lFrame.contextLView = xy(e, O.lFrame.contextLView))[Ce] } function nn() { return O.lFrame.selectedIndex } function Jt(e) { O.lFrame.selectedIndex = e } function fc() { let e = O.lFrame; return Yf(e.tView, e.selectedIndex) } function Yy() { return O.lFrame.currentNamespace } var fh = !0; function hc() { return fh } function pc(e) { fh = e } function Qy(e, t, n) { let { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { let s = Gf(t); (n.preOrderHooks ??= []).push(e, s), (n.preOrderCheckHooks ??= []).push(e, s) } o && (n.preOrderHooks ??= []).push(0 - e, o), i && ((n.preOrderHooks ??= []).push(e, i), (n.preOrderCheckHooks ??= []).push(e, i)) } function hh(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { let i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: c, ngOnDestroy: u } = i; s && (e.contentHooks ??= []).push(-n, s), a && ((e.contentHooks ??= []).push(n, a), (e.contentCheckHooks ??= []).push(n, a)), l && (e.viewHooks ??= []).push(-n, l), c && ((e.viewHooks ??= []).push(n, c), (e.viewCheckHooks ??= []).push(n, c)), u != null && (e.destroyHooks ??= []).push(n, u) } } function li(e, t, n) { ph(e, t, 3, n) } function ci(e, t, n, r) { (e[x] & 3) === n && ph(e, t, n, r) } function rl(e, t) { let n = e[x]; (n & 3) === t && (n &= 16383, n += 1, e[x] = n) } function ph(e, t, n, r) { let o = r !== void 0 ? e[In] & 65535 : 0, i = r ?? -1, s = t.length - 1, a = 0; for (let l = o; l < s; l++)if (typeof t[l + 1] == "number") { if (a = t[l], r != null && a >= r) break } else t[l] < 0 && (e[In] += 65536), (a < i || i == -1) && (Ky(e, n, t, l), e[In] = (e[In] & 4294901760) + l + 2), l++ } function Bd(e, t) { z(4, e, t); let n = F(null); try { t.call(e) } finally { F(n), z(5, e, t) } } function Ky(e, t, n, r) { let o = n[r] < 0, i = n[r + 1], s = o ? -n[r] : n[r], a = e[s]; o ? e[x] >> 14 < e[In] >> 16 && (e[x] & 3) === t && (e[x] += 16384, Bd(a, i)) : Bd(a, i) } var Sn = -1, Xt = class { factory; injectImpl; resolving = !1; canSeeViewProviders; multi; componentProviders; index; providerFactory; constructor(t, n, r) { this.factory = t, this.canSeeViewProviders = n, this.injectImpl = r } }; function Jy(e) { return (e.flags & 8) !== 0 } function Xy(e) { return (e.flags & 16) !== 0 } function eD(e, t, n) { let r = 0; for (; r < n.length;) { let o = n[r]; if (typeof o == "number") { if (o !== 0) break; r++; let i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { let i = o, s = n[++r]; tD(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function gh(e) { return e === 3 || e === 4 || e === 6 } function tD(e) { return e.charCodeAt(0) === 64 } function _r(e, t) { if (!(t === null || t.length === 0)) if (e === null || e.length === 0) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { let o = t[r]; typeof o == "number" ? n = o : n === 0 || (n === -1 || n === 2 ? Ud(e, n, o, null, t[++r]) : Ud(e, n, o, null, null)) } } return e } function Ud(e, t, n, r, o) { let i = 0, s = e.length; if (t === -1) s = -1; else for (; i < e.length;) { let a = e[i++]; if (typeof a == "number") { if (a === t) { s = -1; break } else if (a > t) { s = i - 1; break } } } for (; i < e.length;) { let a = e[i]; if (typeof a == "number") break; if (a === n) { o !== null && (e[i + 1] = o); return } i++, o !== null && i++ } s !== -1 && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), o !== null && e.splice(i++, 0, o) } function mh(e) { return e !== Sn } function _i(e) { return e & 32767 } function nD(e) { return e >> 16 } function Ii(e, t) { let n = nD(e), r = t; for (; n > 0;)r = r[Ln], n--; return r } var _l = !0; function Mi(e) { let t = _l; return _l = e, t } var rD = 256, vh = rD - 1, yh = 5, oD = 0, Ge = {}; function iD(e, t, n) { let r; typeof n == "string" ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Cr) && (r = n[Cr]), r == null && (r = n[Cr] = oD++); let o = r & vh, i = 1 << o; t.data[e + (o >> yh)] |= i } function Si(e, t) { let n = Dh(e, t); if (n !== -1) return n; let r = t[L]; r.firstCreatePass && (e.injectorIndex = t.length, ol(r.data, e), ol(t, null), ol(r.blueprint, null)); let o = gc(e, t), i = e.injectorIndex; if (mh(o)) { let s = _i(o), a = Ii(o, t), l = a[L].data; for (let c = 0; c < 8; c++)t[i + c] = a[s + c] | l[s + c] } return t[i + 8] = o, i } function ol(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function Dh(e, t) { return e.injectorIndex === -1 || e.parent && e.parent.injectorIndex === e.injectorIndex || t[e.injectorIndex + 8] === null ? -1 : e.injectorIndex } function gc(e, t) { if (e.parent && e.parent.injectorIndex !== -1) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; o !== null;) { if (r = _h(o), r === null) return Sn; if (n++, o = o[Ln], r.injectorIndex !== -1) return r.injectorIndex | n << 16 } return Sn } function Il(e, t, n) { iD(e, t, n) } function sD(e, t) { if (t === "class") return e.classes; if (t === "style") return e.styles; let n = e.attrs; if (n) { let r = n.length, o = 0; for (; o < r;) { let i = n[o]; if (gh(i)) break; if (i === 0) o = o + 2; else if (typeof i == "number") for (o++; o < r && typeof n[o] == "string";)o++; else { if (i === t) return n[o + 1]; o = o + 2 } } } return null } function Ch(e, t, n) { if (n & R.Optional || e !== void 0) return e; ec(t, "NodeInjector") } function Eh(e, t, n, r) { if (n & R.Optional && r === void 0 && (r = null), (n & (R.Self | R.Host)) === 0) { let o = e[An], i = ye(void 0); try { return o ? o.get(t, r, n & R.Optional) : Af(t, r, n & R.Optional) } finally { ye(i) } } return Ch(r, t, n) } function wh(e, t, n, r = R.Default, o) { if (e !== null) { if (t[x] & 2048 && !(r & R.Self)) { let s = dD(e, t, n, r, Ge); if (s !== Ge) return s } let i = bh(e, t, n, r, Ge); if (i !== Ge) return i } return Eh(t, n, r, o) } function bh(e, t, n, r, o) { let i = cD(n); if (typeof i == "function") { if (!ah(t, e, r)) return r & R.Host ? Ch(o, n, r) : Eh(t, n, r, o); try { let s; if (s = i(r), s == null && !(r & R.Optional)) ec(n); else return s } finally { dh() } } else if (typeof i == "number") { let s = null, a = Dh(e, t), l = Sn, c = r & R.Host ? t[qe][$e] : null; for ((a === -1 || r & R.SkipSelf) && (l = a === -1 ? gc(e, t) : t[a + 8], l === Sn || !Hd(r, !1) ? a = -1 : (s = t[L], a = _i(l), t = Ii(l, t))); a !== -1;) { let u = t[L]; if ($d(i, a, u.data)) { let f = aD(a, t, n, s, r, c); if (f !== Ge) return f } l = t[a + 8], l !== Sn && Hd(r, t[L].data[a + 8] === c) && $d(i, a, t) ? (s = u, a = _i(l), t = Ii(l, t)) : a = -1 } } return o } function aD(e, t, n, r, o, i) { let s = t[L], a = s.data[e + 8], l = r == null ? Vn(a) && _l : r != s && (a.type & 3) !== 0, c = o & R.Host && i === a, u = lD(a, s, n, l, c); return u !== null ? Ti(t, s, u, a, o) : Ge } function lD(e, t, n, r, o) { let i = e.providerIndexes, s = t.data, a = i & 1048575, l = e.directiveStart, c = e.directiveEnd, u = i >> 20, f = r ? a : a + u, h = o ? a + u : c; for (let d = f; d < h; d++) { let p = s[d]; if (d < l && n === p || d >= l && p.type === n) return d } if (o) { let d = s[l]; if (d && We(d) && d.type === n) return l } return null } function Ti(e, t, n, r, o) { let i = e[n], s = t.data; if (i instanceof Xt) { let a = i; a.resolving && Nf(Yv(s[n])); let l = Mi(a.canSeeViewProviders); a.resolving = !0; let c, u = a.injectImpl ? ye(a.injectImpl) : null, f = ah(e, r, R.Default); try { i = e[n] = a.factory(void 0, o, s, e, r), t.firstCreatePass && n >= r.directiveStart && Qy(n, s[n], t) } finally { u !== null && ye(u), Mi(l), a.resolving = !1, dh() } } return i } function cD(e) { if (typeof e == "string") return e.charCodeAt(0) || 0; let t = e.hasOwnProperty(Cr) ? e[Cr] : void 0; return typeof t == "number" ? t >= 0 ? t & vh : uD : t } function $d(e, t, n) { let r = 1 << e; return !!(n[t + (e >> yh)] & r) } function Hd(e, t) { return !(e & R.Self) && !(e & R.Host && t) } var Wt = class { _tNode; _lView; constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return wh(this._tNode, this._lView, t, Bi(r), n) } }; function uD() { return new Wt(Se(), $()) } function Nt(e) { return Nr(() => { let t = e.prototype.constructor, n = t[fi] || Ml(t), r = Object.prototype, o = Object.getPrototypeOf(e.prototype).constructor; for (; o && o !== r;) { let i = o[fi] || Ml(o); if (i && i !== n) return i; o = Object.getPrototypeOf(o) } return i => new i }) } function Ml(e) { return _f(e) ? () => { let t = Ml(de(e)); return t && t() } : Zt(e) } function dD(e, t, n, r, o) { let i = e, s = t; for (; i !== null && s !== null && s[x] & 2048 && !wi(s);) { let a = bh(i, s, n, r | R.Self, Ge); if (a !== Ge) return a; let l = i.parent; if (!l) { let c = s[Uf]; if (c) { let u = c.get(n, Ge, r); if (u !== Ge) return u } l = _h(s), s = s[Ln] } i = l } return o } function _h(e) { let t = e[L], n = t.type; return n === 2 ? t.declTNode : n === 1 ? e[$e] : null } function mc(e) { return sD(Se(), e) } function zd(e, t = null, n = null, r) { let o = Ih(e, t, n, r); return o.resolveInjectorInitializers(), o } function Ih(e, t = null, n = null, r, o = new Set) { let i = [n || Oe, dy(e)]; return r = r || (typeof e == "object" ? void 0 : De(e)), new wr(i, t || rc(), r || null, o) } var ft = class e { static THROW_IF_NOT_FOUND = qt; static NULL = new mi; static create(t, n) { if (Array.isArray(t)) return zd({ name: "" }, n, t, ""); { let r = t.name ?? ""; return zd({ name: r }, t.parent, t.providers, r) } } static \u0275prov = _({ token: e, providedIn: "any", factory: () => M(Pf) }); static __NG_ELEMENT_ID__ = -1 }; var fD = new D(""); fD.__NG_ELEMENT_ID__ = e => { let t = Se(); if (t === null) throw new v(204, !1); if (t.type & 2) return t.value; if (e & R.Optional) return null; throw new v(204, !1) }; var Mh = !1, Or = (() => { class e { static __NG_ELEMENT_ID__ = hD; static __NG_ENV_ID__ = n => n } return e })(), Sl = class extends Or { _lView; constructor(t) { super(), this._lView = t } onDestroy(t) { let n = this._lView; return jn(n) ? (t(), () => { }) : (Jf(n, t), () => Ay(n, t)) } }; function hD() { return new Sl($()) } var Ir = class { }, vc = new D("", { providedIn: "root", factory: () => !1 }); var Sh = new D(""), Th = new D(""), xt = (() => { class e { taskId = 0; pendingTasks = new Set; get _hasPendingTasks() { return this.hasPendingTasks.value } hasPendingTasks = new ne(!1); add() { this._hasPendingTasks || this.hasPendingTasks.next(!0); let n = this.taskId++; return this.pendingTasks.add(n), n } has(n) { return this.pendingTasks.has(n) } remove(n) { this.pendingTasks.delete(n), this.pendingTasks.size === 0 && this._hasPendingTasks && this.hasPendingTasks.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this._hasPendingTasks && this.hasPendingTasks.next(!1) } static \u0275prov = _({ token: e, providedIn: "root", factory: () => new e }) } return e })(); var Tl = class extends K { __isAsync; destroyRef = void 0; pendingTasks = void 0; constructor(t = !1) { super(), this.__isAsync = t, Ey() && (this.destroyRef = g(Or, { optional: !0 }) ?? void 0, this.pendingTasks = g(xt, { optional: !0 }) ?? void 0) } emit(t) { let n = F(null); try { super.next(t) } finally { F(n) } } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && typeof t == "object") { let l = t; o = l.next?.bind(l), i = l.error?.bind(l), s = l.complete?.bind(l) } this.__isAsync && (i = this.wrapInTimeout(i), o && (o = this.wrapInTimeout(o)), s && (s = this.wrapInTimeout(s))); let a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof Q && t.add(a), a } wrapInTimeout(t) { return n => { let r = this.pendingTasks?.add(); setTimeout(() => { try { t(n) } finally { r !== void 0 && this.pendingTasks?.remove(r) } }) } } }, X = Tl; function Ni(...e) { } function Nh(e) { let t, n; function r() { e = Ni; try { n !== void 0 && typeof cancelAnimationFrame == "function" && cancelAnimationFrame(n), t !== void 0 && clearTimeout(t) } catch { } } return t = setTimeout(() => { e(), r() }), typeof requestAnimationFrame == "function" && (n = requestAnimationFrame(() => { e(), r() })), () => r() } function Gd(e) { return queueMicrotask(() => e()), () => { e = Ni } } var yc = "isAngularZone", xi = yc + "_ID", pD = 0, oe = class e { hasPendingMacrotasks = !1; hasPendingMicrotasks = !1; isStable = !0; onUnstable = new X(!1); onMicrotaskEmpty = new X(!1); onStable = new X(!1); onError = new X(!1); constructor(t) { let { enableLongStackTrace: n = !1, shouldCoalesceEventChangeDetection: r = !1, shouldCoalesceRunChangeDetection: o = !1, scheduleInRootZone: i = Mh } = t; if (typeof Zone > "u") throw new v(908, !1); Zone.assertZonePatched(); let s = this; s._nesting = 0, s._outer = s._inner = Zone.current, Zone.TaskTrackingZoneSpec && (s._inner = s._inner.fork(new Zone.TaskTrackingZoneSpec)), n && Zone.longStackTraceZoneSpec && (s._inner = s._inner.fork(Zone.longStackTraceZoneSpec)), s.shouldCoalesceEventChangeDetection = !o && r, s.shouldCoalesceRunChangeDetection = o, s.callbackScheduled = !1, s.scheduleInRootZone = i, vD(s) } static isInAngularZone() { return typeof Zone < "u" && Zone.current.get(yc) === !0 } static assertInAngularZone() { if (!e.isInAngularZone()) throw new v(909, !1) } static assertNotInAngularZone() { if (e.isInAngularZone()) throw new v(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { let i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, gD, Ni, Ni); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } }, gD = {}; function Dc(e) { if (e._nesting == 0 && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function mD(e) { if (e.isCheckStableRunning || e.callbackScheduled) return; e.callbackScheduled = !0; function t() { Nh(() => { e.callbackScheduled = !1, Nl(e), e.isCheckStableRunning = !0, Dc(e), e.isCheckStableRunning = !1 }) } e.scheduleInRootZone ? Zone.root.run(() => { t() }) : e._outer.run(() => { t() }), Nl(e) } function vD(e) { let t = () => { mD(e) }, n = pD++; e._inner = e._inner.fork({ name: "angular", properties: { [yc]: !0, [xi]: n, [xi + n]: !0 }, onInvokeTask: (r, o, i, s, a, l) => { if (yD(l)) return r.invokeTask(i, s, a, l); try { return qd(e), r.invokeTask(i, s, a, l) } finally { (e.shouldCoalesceEventChangeDetection && s.type === "eventTask" || e.shouldCoalesceRunChangeDetection) && t(), Wd(e) } }, onInvoke: (r, o, i, s, a, l, c) => { try { return qd(e), r.invoke(i, s, a, l, c) } finally { e.shouldCoalesceRunChangeDetection && !e.callbackScheduled && !DD(l) && t(), Wd(e) } }, onHasTask: (r, o, i, s) => { r.hasTask(i, s), o === i && (s.change == "microTask" ? (e._hasPendingMicrotasks = s.microTask, Nl(e), Dc(e)) : s.change == "macroTask" && (e.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (r, o, i, s) => (r.handleError(i, s), e.runOutsideAngular(() => e.onError.emit(s)), !1) }) } function Nl(e) { e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && e.callbackScheduled === !0 ? e.hasPendingMicrotasks = !0 : e.hasPendingMicrotasks = !1 } function qd(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function Wd(e) { e._nesting--, Dc(e) } var xl = class { hasPendingMicrotasks = !1; hasPendingMacrotasks = !1; isStable = !0; onUnstable = new X; onMicrotaskEmpty = new X; onStable = new X; onError = new X; run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } }; function yD(e) { return xh(e, "__ignore_ng_zone__") } function DD(e) { return xh(e, "__scheduler_tick__") } function xh(e, t) { return !Array.isArray(e) || e.length !== 1 ? !1 : e[0]?.data?.[t] === !0 } var ht = class { _console = console; handleError(t) { this._console.error("ERROR", t) } }, CD = new D("", { providedIn: "root", factory: () => { let e = g(oe), t = g(ht); return n => e.runOutsideAngular(() => t.handleError(n)) } }); function Zd(e, t) { return wf(e, t) } function ED(e) { return wf(Ef, e) } var Ah = (Zd.required = ED, Zd); function wD() { return qi(Se(), $()) } function qi(e, t) { return new yt(Xe(e, t)) } var yt = (() => { class e { nativeElement; constructor(n) { this.nativeElement = n } static __NG_ELEMENT_ID__ = wD } return e })(); function bD(e) { return typeof e == "function" && e[Re] !== void 0 } function Pr(e, t) { let n = Pa(e, t?.equal), r = n[Re]; return n.set = o => hr(r, o), n.update = o => Fa(r, o), n.asReadonly = _D.bind(n), n } function _D() { let e = this[Re]; if (e.readonlyFn === void 0) { let t = () => this(); t[Re] = e, e.readonlyFn = t } return e.readonlyFn } function Rh(e) { return bD(e) && typeof e.set == "function" } function Oh(e) { return (e.flags & 128) === 128 } var Ph = function (e) { return e[e.OnPush = 0] = "OnPush", e[e.Default = 1] = "Default", e }(Ph || {}), Fh = new Map, ID = 0; function MD() { return ID++ } function SD(e) { Fh.set(e[$i], e) } function Al(e) { Fh.delete(e[$i]) } var Yd = "__ngContext__"; function Fr(e, t) { St(t) ? (e[Yd] = t[$i], SD(t)) : e[Yd] = t } function kh(e) { return Vh(e[br]) } function Lh(e) { return Vh(e[Ue]) } function Vh(e) { for (; e !== null && !mt(e);)e = e[Ue]; return e } var Rl; function jh(e) { Rl = e } function TD() { if (Rl !== void 0) return Rl; if (typeof document < "u") return document; throw new v(210, !1) } var Cc = new D("", { providedIn: "root", factory: () => ND }), ND = "ng", Ec = new D(""), kr = new D("", { providedIn: "platform", factory: () => "unknown" }); var wc = new D("", { providedIn: "root", factory: () => TD().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); var xD = "h", AD = "b"; var Bh = !1, RD = new D("", { providedIn: "root", factory: () => Bh }); var Uh = function (e) { return e[e.CHANGE_DETECTION = 0] = "CHANGE_DETECTION", e[e.AFTER_NEXT_RENDER = 1] = "AFTER_NEXT_RENDER", e }(Uh || {}), Wi = new D(""), Qd = new Set; function bc(e) { Qd.has(e) || (Qd.add(e), performance?.mark?.("mark_feature_usage", { detail: { feature: e } })) } var OD = (() => { class e { impl = null; execute() { this.impl?.execute() } static \u0275prov = _({ token: e, providedIn: "root", factory: () => new e }) } return e })(); var PD = (e, t, n, r) => { }; function FD(e, t, n, r) { PD(e, t, n, r) } var kD = () => null; function $h(e, t, n = !1) { return kD(e, t, n) } function Hh(e, t) { let n = e.contentQueries; if (n !== null) { let r = F(null); try { for (let o = 0; o < n.length; o += 2) { let i = n[o], s = n[o + 1]; if (s !== -1) { let a = e.data[s]; sh(i), a.contentQueries(2, t[s], s) } } } finally { F(r) } } } function Ol(e, t, n) { sh(0); let r = F(null); try { t(e, n) } finally { F(r) } } function zh(e, t, n) { if (Hf(t)) { let r = F(null); try { let o = t.directiveStart, i = t.directiveEnd; for (let s = o; s < i; s++) { let a = e.data[s]; if (a.contentQueries) { let l = n[s]; a.contentQueries(1, l, s) } } } finally { F(r) } } } var Qe = function (e) { return e[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", e }(Qe || {}); var ii; function LD() { if (ii === void 0 && (ii = null, hl.trustedTypes)) try { ii = hl.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch { } return ii } function Kd(e) { return LD()?.createScriptURL(e) || e } var Ai = class { changingThisBreaksApplicationSecurity; constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Cf})` } }; function _c(e) { return e instanceof Ai ? e.changingThisBreaksApplicationSecurity : e } function Gh(e, t) { let n = VD(e); if (n != null && n !== t) { if (n === "ResourceURL" && t === "URL") return !0; throw new Error(`Required a safe ${t}, got a ${n} (see ${Cf})`) } return n === t } function VD(e) { return e instanceof Ai && e.getTypeName() || null } var jD = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i; function BD(e) { return e = String(e), e.match(jD) ? e : "unsafe:" + e } var Ic = function (e) { return e[e.NONE = 0] = "NONE", e[e.HTML = 1] = "HTML", e[e.STYLE = 2] = "STYLE", e[e.SCRIPT = 3] = "SCRIPT", e[e.URL = 4] = "URL", e[e.RESOURCE_URL = 5] = "RESOURCE_URL", e }(Ic || {}); function UD(e) { let t = Wh(); return t ? t.sanitize(Ic.URL, e) || "" : Gh(e, "URL") ? _c(e) : BD(Tn(e)) } function $D(e) { let t = Wh(); if (t) return Kd(t.sanitize(Ic.RESOURCE_URL, e) || ""); if (Gh(e, "ResourceURL")) return Kd(_c(e)); throw new v(904, !1) } function HD(e, t) { return t === "src" && (e === "embed" || e === "frame" || e === "iframe" || e === "media" || e === "script") || t === "href" && (e === "base" || e === "link") ? $D : UD } function qh(e, t, n) { return HD(t, n)(e) } function Wh() { let e = $(); return e && e[dt].sanitizer } function Zh(e) { return e instanceof Function ? e() : e } function zD(e, t, n) { let r = e.length; for (; ;) { let o = e.indexOf(t, n); if (o === -1) return o; if (o === 0 || e.charCodeAt(o - 1) <= 32) { let i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } var Yh = "ng-template"; function GD(e, t, n, r) { let o = 0; if (r) { for (; o < t.length && typeof t[o] == "string"; o += 2)if (t[o] === "class" && zD(t[o + 1].toLowerCase(), n, 0) !== -1) return !0 } else if (Mc(e)) return !1; if (o = t.indexOf(1, o), o > -1) { let i; for (; ++o < t.length && typeof (i = t[o]) == "string";)if (i.toLowerCase() === n) return !0 } return !1 } function Mc(e) { return e.type === 4 && e.value !== Yh } function qD(e, t, n) { let r = e.type === 4 && !n ? Yh : e.value; return t === r } function WD(e, t, n) { let r = 4, o = e.attrs, i = o !== null ? QD(o) : 0, s = !1; for (let a = 0; a < t.length; a++) { let l = t[a]; if (typeof l == "number") { if (!s && !Be(r) && !Be(l)) return !1; if (s && Be(l)) continue; s = !1, r = l | r & 1; continue } if (!s) if (r & 4) { if (r = 2 | r & 1, l !== "" && !qD(e, l, n) || l === "" && t.length === 1) { if (Be(r)) return !1; s = !0 } } else if (r & 8) { if (o === null || !GD(e, o, l, n)) { if (Be(r)) return !1; s = !0 } } else { let c = t[++a], u = ZD(l, o, Mc(e), n); if (u === -1) { if (Be(r)) return !1; s = !0; continue } if (c !== "") { let f; if (u > i ? f = "" : f = o[u + 1].toLowerCase(), r & 2 && c !== f) { if (Be(r)) return !1; s = !0 } } } } return Be(r) || s } function Be(e) { return (e & 1) === 0 } function ZD(e, t, n, r) { if (t === null) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { let s = t[o]; if (s === e) return o; if (s === 3 || s === 6) i = !0; else if (s === 1 || s === 2) { let a = t[++o]; for (; typeof a == "string";)a = t[++o]; continue } else { if (s === 4) break; if (s === 0) { o += 4; continue } } o += i ? 1 : 2 } return -1 } else return KD(t, e) } function YD(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (WD(e, t[r], n)) return !0; return !1 } function QD(e) { for (let t = 0; t < e.length; t++) { let n = e[t]; if (gh(n)) return t } return e.length } function KD(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { let r = e[n]; if (typeof r == "number") return -1; if (r === t) return n; n++ } return -1 } function Jd(e, t) { return e ? ":not(" + t.trim() + ")" : t } function JD(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if (typeof s == "string") if (r & 2) { let a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else r & 8 ? o += "." + s : r & 4 && (o += " " + s); else o !== "" && !Be(s) && (t += Jd(i, o), o = ""), r = s, i = i || !Be(r); n++ } return o !== "" && (t += Jd(i, o)), t } function XD(e) { return e.map(JD).join(",") } function eC(e) { let t = [], n = [], r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if (typeof i == "string") o === 2 ? i !== "" && t.push(i, e[++r]) : o === 8 && n.push(i); else { if (!Be(o)) break; o = i } r++ } return n.length && t.push(1, ...n), t } var Dt = {}; function tC(e, t) { return e.createText(t) } function nC(e, t, n) { e.setValue(t, n) } function Qh(e, t, n) { return e.createElement(t, n) } function Ri(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function Kh(e, t, n) { e.appendChild(t, n) } function Xd(e, t, n, r, o) { r !== null ? Ri(e, t, n, r, o) : Kh(e, t, n) } function rC(e, t, n) { e.removeChild(null, t, n) } function oC(e, t, n) { e.setAttribute(t, "style", n) } function iC(e, t, n) { n === "" ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function Jh(e, t, n) { let { mergedAttrs: r, classes: o, styles: i } = n; r !== null && eD(e, t, r), o !== null && iC(e, t, o), i !== null && oC(e, t, i) } function Sc(e, t, n, r, o, i, s, a, l, c, u) { let f = Ie + r, h = f + o, d = sC(f, h), p = typeof c == "function" ? c() : c; return d[L] = { type: e, blueprint: d, template: n, queries: null, viewQuery: a, declTNode: t, data: d.slice().fill(null, f), bindingStartIndex: f, expandoStartIndex: h, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: typeof i == "function" ? i() : i, pipeRegistry: typeof s == "function" ? s() : s, firstChild: null, schemas: l, consts: p, incompleteFirstPass: !1, ssrId: u } } function sC(e, t) { let n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : Dt); return n } function aC(e) { let t = e.tView; return t === null || t.incompleteFirstPass ? e.tView = Sc(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts, e.id) : t } function Tc(e, t, n, r, o, i, s, a, l, c, u) { let f = t.blueprint.slice(); return f[gt] = o, f[x] = r | 4 | 128 | 8 | 64 | 1024, (c !== null || e && e[x] & 2048) && (f[x] |= 2048), Qf(f), f[he] = f[Ln] = e, f[Ce] = n, f[dt] = s || e && e[dt], f[ie] = a || e && e[ie], f[An] = l || e && e[An] || null, f[$e] = i, f[$i] = MD(), f[vi] = u, f[Uf] = c, f[qe] = t.type == 2 ? e[qe] : f, f } function lC(e, t, n) { let r = Xe(t, e), o = aC(n), i = e[dt].rendererFactory, s = Nc(e, Tc(e, o, null, Xh(n), r, t, null, i.createRenderer(r, n), null, null, null)); return e[t.index] = s } function Xh(e) { let t = 16; return e.signals ? t = 4096 : e.onPush && (t = 64), t } function ep(e, t, n, r) { if (n === 0) return -1; let o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function Nc(e, t) { return e[br] ? e[Ld][Ue] = t : e[br] = t, e[Ld] = t, t } function Z(e = 1) { tp(Ee(), $(), nn() + e, !1) } function tp(e, t, n, r) { if (!r) if ((t[x] & 3) === 3) { let i = e.preOrderCheckHooks; i !== null && li(t, i, n) } else { let i = e.preOrderHooks; i !== null && ci(t, i, 0, n) } Jt(n) } var Zi = function (e) { return e[e.None = 0] = "None", e[e.SignalBased = 1] = "SignalBased", e[e.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform", e }(Zi || {}); function Pl(e, t, n, r) { let o = F(null); try { let [i, s, a] = e.inputs[n], l = null; (s & Zi.SignalBased) !== 0 && (l = t[i][Re]), l !== null && l.transformFn !== void 0 ? r = l.transformFn(r) : a !== null && (r = a.call(t, r)), e.setInput !== null ? e.setInput(t, l, r, n, i) : zf(t, l, i, r) } finally { F(o) } } function np(e, t, n, r, o) { let i = nn(), s = r & 2; try { Jt(-1), s && t.length > Ie && tp(e, t, Ie, !1), z(s ? 2 : 0, o), n(r, o) } finally { Jt(i), z(s ? 3 : 1, o) } } function xc(e, t, n) { pC(e, t, n), (n.flags & 64) === 64 && gC(e, t, n) } function rp(e, t, n = Xe) { let r = t.localNames; if (r !== null) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { let s = r[i + 1], a = s === -1 ? n(t, e) : e[s]; e[o++] = a } } } function cC(e, t, n, r) { let i = r.get(RD, Bh) || n === Qe.ShadowDom, s = e.selectRootElement(t, i); return uC(s), s } function uC(e) { dC(e) } var dC = () => null; function fC(e) { return e === "class" ? "className" : e === "for" ? "htmlFor" : e === "formaction" ? "formAction" : e === "innerHtml" ? "innerHTML" : e === "readonly" ? "readOnly" : e === "tabindex" ? "tabIndex" : e } function op(e, t, n, r, o, i, s, a) { if (!a && Ac(t, e, n, r, o)) { Vn(t) && hC(n, t.index); return } if (t.type & 3) { let l = Xe(t, n); r = fC(r), o = s != null ? s(o, t.value || "", r) : o, i.setProperty(l, r, o) } else t.type & 12 } function hC(e, t) { let n = Ye(t, e); n[x] & 16 || (n[x] |= 64) } function pC(e, t, n) { let r = n.directiveStart, o = n.directiveEnd; Vn(n) && lC(t, n, e.data[r + n.componentOffset]), e.firstCreatePass || Si(n, t); let i = n.initialInputs; for (let s = r; s < o; s++) { let a = e.data[s], l = Ti(t, e, s, n); if (Fr(l, t), i !== null && DC(t, s - r, l, a, n, i), We(a)) { let c = Ye(n.index, t); c[Ce] = Ti(t, e, s, n) } } } function gC(e, t, n) { let r = n.directiveStart, o = n.directiveEnd, i = n.index, s = Gy(); try { Jt(i); for (let a = r; a < o; a++) { let l = e.data[a], c = t[a]; bl(a), (l.hostBindings !== null || l.hostVars !== 0 || l.hostAttrs !== null) && mC(l, c) } } finally { Jt(-1), bl(s) } } function mC(e, t) { e.hostBindings !== null && e.hostBindings(1, t) } function ip(e, t) { let n = e.directiveRegistry, r = null; if (n) for (let o = 0; o < n.length; o++) { let i = n[o]; YD(t, i.selectors, !1) && (r ??= [], We(i) ? r.unshift(i) : r.push(i)) } return r } function vC(e, t, n, r, o, i) { let s = Xe(e, t); yC(t[ie], s, i, e.value, n, r, o) } function yC(e, t, n, r, o, i, s) { if (i == null) e.removeAttribute(t, o, n); else { let a = s == null ? Tn(i) : s(i, r || "", o); e.setAttribute(t, o, a, n) } } function DC(e, t, n, r, o, i) { let s = i[t]; if (s !== null) for (let a = 0; a < s.length; a += 2) { let l = s[a], c = s[a + 1]; Pl(r, n, l, c) } } function CC(e, t) { let n = e[An], r = n ? n.get(ht, null) : null; r && r.handleError(t) } function Ac(e, t, n, r, o) { let i = e.inputs?.[r], s = e.hostDirectiveInputs?.[r], a = !1; if (s) for (let l = 0; l < s.length; l += 2) { let c = s[l], u = s[l + 1], f = t.data[c]; Pl(f, n[c], u, o), a = !0 } if (i) for (let l of i) { let c = n[l], u = t.data[l]; Pl(u, c, r, o), a = !0 } return a } function EC(e, t) { let n = Ye(t, e), r = n[L]; wC(r, n); let o = n[gt]; o !== null && n[vi] === null && (n[vi] = $h(o, n[An])), z(18), Rc(r, n, n[Ce]), z(19, n[Ce]) } function wC(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) } function Rc(e, t, n) { uc(t); try { let r = e.viewQuery; r !== null && Ol(1, r, n); let o = e.template; o !== null && np(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), t[On]?.finishViewCreation(e), e.staticContentQueries && Hh(e, t), e.staticViewQueries && Ol(2, e.viewQuery, n); let i = e.components; i !== null && bC(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[x] &= -5, dc() } } function bC(e, t) { for (let n = 0; n < t.length; n++)EC(e, t[n]) } function _C(e, t, n, r) { let o = F(null); try { let i = t.tView, a = e[x] & 4096 ? 4096 : 16, l = Tc(e, i, n, a, null, t, null, null, r?.injector ?? null, r?.embeddedViewInjector ?? null, r?.dehydratedView ?? null), c = e[t.index]; l[Rn] = c; let u = e[On]; return u !== null && (l[On] = u.createEmbeddedView(i)), Rc(i, l, n), l } finally { F(o) } } function ef(e, t) { return !t || t.firstChild === null || Oh(e) } var IC; function Oc(e, t) { return IC(e, t) } var pt = function (e) { return e[e.Important = 1] = "Important", e[e.DashCase = 2] = "DashCase", e }(pt || {}); function sp(e) { return (e.flags & 32) === 32 } function Mn(e, t, n, r, o) { if (r != null) { let i, s = !1; mt(r) ? i = r : St(r) && (s = !0, r = r[gt]); let a = Ze(r); e === 0 && n !== null ? o == null ? Kh(t, n, a) : Ri(t, n, a, o || null, !0) : e === 1 && n !== null ? Ri(t, n, a, o || null, !0) : e === 2 ? rC(t, a, s) : e === 3 && t.destroyNode(a), i != null && LC(t, e, i, n, o) } } function MC(e, t) { ap(e, t), t[gt] = null, t[$e] = null } function SC(e, t, n, r, o, i) { r[gt] = o, r[$e] = t, Yi(e, r, n, 1, o, i) } function ap(e, t) { t[dt].changeDetectionScheduler?.notify(9), Yi(e, t, t[ie], 2, null, null) } function TC(e) { let t = e[br]; if (!t) return il(e[L], e); for (; t;) { let n = null; if (St(t)) n = t[br]; else { let r = t[Fe]; r && (n = r) } if (!n) { for (; t && !t[Ue] && t !== e;)St(t) && il(t[L], t), t = t[he]; t === null && (t = e), St(t) && il(t[L], t), n = t && t[Ue] } t = n } } function Pc(e, t) { let n = e[Ei], r = n.indexOf(t); n.splice(r, 1) } function lp(e, t) { if (jn(t)) return; let n = t[ie]; n.destroyNode && Yi(e, t, n, 3, null, null), TC(t) } function il(e, t) { if (jn(t)) return; let n = F(null); try { t[x] &= -129, t[x] |= 256, t[Pe] && Aa(t[Pe]), xC(e, t), NC(e, t), t[L].type === 1 && t[ie].destroy(); let r = t[Rn]; if (r !== null && mt(t[he])) { r !== t[he] && Pc(r, t); let o = t[On]; o !== null && o.detachView(e) } Al(t) } finally { F(n) } } function NC(e, t) { let n = e.cleanup, r = t[yi]; if (n !== null) for (let s = 0; s < n.length - 1; s += 2)if (typeof n[s] == "string") { let a = n[s + 3]; a >= 0 ? r[a]() : r[-a].unsubscribe(), s += 2 } else { let a = r[n[s + 1]]; n[s].call(a) } r !== null && (t[yi] = null); let o = t[Mt]; if (o !== null) { t[Mt] = null; for (let s = 0; s < o.length; s++) { let a = o[s]; a() } } let i = t[Di]; if (i !== null) { t[Di] = null; for (let s of i) s.destroy() } } function xC(e, t) { let n; if (e != null && (n = e.destroyHooks) != null) for (let r = 0; r < n.length; r += 2) { let o = t[n[r]]; if (!(o instanceof Xt)) { let i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { let a = o[i[s]], l = i[s + 1]; z(4, a, l); try { l.call(a) } finally { z(5, a, l) } } else { z(4, o, i); try { i.call(o) } finally { z(5, o, i) } } } } } function AC(e, t, n) { return RC(e, t.parent, n) } function RC(e, t, n) { let r = t; for (; r !== null && r.type & 168;)t = r, r = t.parent; if (r === null) return n[gt]; if (Vn(r)) { let { encapsulation: o } = e.data[r.directiveStart + r.componentOffset]; if (o === Qe.None || o === Qe.Emulated) return null } return Xe(r, n) } function OC(e, t, n) { return FC(e, t, n) } function PC(e, t, n) { return e.type & 40 ? Xe(e, n) : null } var FC = PC, tf; function Fc(e, t, n, r) { let o = AC(e, r, t), i = t[ie], s = r.parent || t[$e], a = OC(s, r, t); if (o != null) if (Array.isArray(n)) for (let l = 0; l < n.length; l++)Xd(i, o, n[l], a, !1); else Xd(i, o, n, a, !1); tf !== void 0 && tf(i, r, t, n, o) } function Dr(e, t) { if (t !== null) { let n = t.type; if (n & 3) return Xe(t, e); if (n & 4) return Fl(-1, e[t.index]); if (n & 8) { let r = t.child; if (r !== null) return Dr(e, r); { let o = e[t.index]; return mt(o) ? Fl(-1, o) : Ze(o) } } else { if (n & 128) return Dr(e, t.next); if (n & 32) return Oc(t, e)() || Ze(e[t.index]); { let r = cp(e, t); if (r !== null) { if (Array.isArray(r)) return r[0]; let o = Kt(e[qe]); return Dr(o, r) } else return Dr(e, t.next) } } } return null } function cp(e, t) { if (t !== null) { let r = e[qe][$e], o = t.projection; return r.projection[o] } return null } function Fl(e, t) { let n = Fe + e + 1; if (n < t.length) { let r = t[n], o = r[L].firstChild; if (o !== null) return Dr(r, o) } return t[Qt] } function kc(e, t, n, r, o, i, s) { for (; n != null;) { if (n.type === 128) { n = n.next; continue } let a = r[n.index], l = n.type; if (s && t === 0 && (a && Fr(Ze(a), r), n.flags |= 2), !sp(n)) if (l & 8) kc(e, t, n.child, r, o, i, !1), Mn(t, e, o, a, i); else if (l & 32) { let c = Oc(n, r), u; for (; u = c();)Mn(t, e, o, u, i); Mn(t, e, o, a, i) } else l & 16 ? kC(e, t, r, n, o, i) : Mn(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function Yi(e, t, n, r, o, i) { kc(n, r, e.firstChild, t, o, i, !1) } function kC(e, t, n, r, o, i) { let s = n[qe], l = s[$e].projection[r.projection]; if (Array.isArray(l)) for (let c = 0; c < l.length; c++) { let u = l[c]; Mn(t, e, o, u, i) } else { let c = l, u = s[he]; Oh(r) && (c.flags |= 128), kc(e, t, c, u, o, i, !0) } } function LC(e, t, n, r, o) { let i = n[Qt], s = Ze(n); i !== s && Mn(t, e, r, i, o); for (let a = Fe; a < n.length; a++) { let l = n[a]; Yi(l[L], l, e, t, r, i) } } function VC(e, t, n, r, o) { if (t) o ? e.addClass(n, r) : e.removeClass(n, r); else { let i = r.indexOf("-") === -1 ? void 0 : pt.DashCase; o == null ? e.removeStyle(n, r, i) : (typeof o == "string" && o.endsWith("!important") && (o = o.slice(0, -10), i |= pt.Important), e.setStyle(n, r, o, i)) } } function Oi(e, t, n, r, o = !1) { for (; n !== null;) { if (n.type === 128) { n = o ? n.projectionNext : n.next; continue } let i = t[n.index]; i !== null && r.push(Ze(i)), mt(i) && jC(i, r); let s = n.type; if (s & 8) Oi(e, t, n.child, r); else if (s & 32) { let a = Oc(n, t), l; for (; l = a();)r.push(l) } else if (s & 16) { let a = cp(t, n); if (Array.isArray(a)) r.push(...a); else { let l = Kt(t[qe]); Oi(l[L], l, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } function jC(e, t) { for (let n = Fe; n < e.length; n++) { let r = e[n], o = r[L].firstChild; o !== null && Oi(r[L], r, o, t) } e[Qt] !== e[gt] && t.push(e[Qt]) } function up(e) { if (e[nl] !== null) { for (let t of e[nl]) t.impl.addSequence(t); e[nl].length = 0 } } var dp = []; function BC(e) { return e[Pe] ?? UC(e) } function UC(e) { let t = dp.pop() ?? Object.create(HC); return t.lView = e, t } function $C(e) { e.lView[Pe] !== e && (e.lView = null, dp.push(e)) } var HC = P(m({}, dr), { consumerIsAlwaysLive: !0, kind: "template", consumerMarkedDirty: e => { zi(e.lView) }, consumerOnSignalRead() { this.lView[Pe] = this } }); function zC(e) { let t = e[Pe] ?? Object.create(GC); return t.lView = e, t } var GC = P(m({}, dr), { consumerIsAlwaysLive: !0, kind: "template", consumerMarkedDirty: e => { let t = Kt(e.lView); for (; t && !fp(t[L]);)t = Kt(t); t && Kf(t) }, consumerOnSignalRead() { this.lView[Pe] = this } }); function fp(e) { return e.type !== 2 } function hp(e) { if (e[Di] === null) return; let t = !0; for (; t;) { let n = !1; for (let r of e[Di]) r.dirty && (n = !0, r.zone === null || Zone.current === r.zone ? r.run() : r.zone.run(() => r.run())); t = n && !!(e[x] & 8192) } } var qC = 100; function pp(e, t = !0, n = 0) { let o = e[dt].rendererFactory, i = !1; i || o.begin?.(); try { WC(e, n) } catch (s) { throw t && CC(e, s), s } finally { i || o.end?.() } } function WC(e, t) { let n = oh(); try { jd(!0), kl(e, t); let r = 0; for (; Hi(e);) { if (r === qC) throw new v(103, !1); r++, kl(e, 1) } } finally { jd(n) } } function ZC(e, t, n, r) { if (jn(t)) return; let o = t[x], i = !1, s = !1; uc(t); let a = !0, l = null, c = null; i || (fp(e) ? (c = BC(t), l = No(c)) : Ia() === null ? (a = !1, c = zC(t), l = No(c)) : t[Pe] && (Aa(t[Pe]), t[Pe] = null)); try { Qf(t), $y(e.bindingStartIndex), n !== null && np(e, t, n, 2, r); let u = (o & 3) === 3; if (!i) if (u) { let d = e.preOrderCheckHooks; d !== null && li(t, d, null) } else { let d = e.preOrderHooks; d !== null && ci(t, d, 0, null), rl(t, 0) } if (s || YC(t), hp(t), gp(t, 0), e.contentQueries !== null && Hh(e, t), !i) if (u) { let d = e.contentCheckHooks; d !== null && li(t, d) } else { let d = e.contentHooks; d !== null && ci(t, d, 1), rl(t, 1) } KC(e, t); let f = e.components; f !== null && vp(t, f, 0); let h = e.viewQuery; if (h !== null && Ol(2, h, r), !i) if (u) { let d = e.viewCheckHooks; d !== null && li(t, d) } else { let d = e.viewHooks; d !== null && ci(t, d, 2), rl(t, 2) } if (e.firstUpdatePass === !0 && (e.firstUpdatePass = !1), t[tl]) { for (let d of t[tl]) d(); t[tl] = null } i || (up(t), t[x] &= -73) } catch (u) { throw i || zi(t), u } finally { c !== null && (Na(c, l), a && $C(c)), dc() } } function gp(e, t) { for (let n = kh(e); n !== null; n = Lh(n))for (let r = Fe; r < n.length; r++) { let o = n[r]; mp(o, t) } } function YC(e) { for (let t = kh(e); t !== null; t = Lh(t)) { if (!(t[x] & 2)) continue; let n = t[Ei]; for (let r = 0; r < n.length; r++) { let o = n[r]; Kf(o) } } } function QC(e, t, n) { z(18); let r = Ye(t, e); mp(r, n), z(19, r[Ce]) } function mp(e, t) { sc(e) && kl(e, t) } function kl(e, t) { let r = e[L], o = e[x], i = e[Pe], s = !!(t === 0 && o & 16); if (s ||= !!(o & 64 && t === 0), s ||= !!(o & 1024), s ||= !!(i?.dirty && xa(i)), s ||= !1, i && (i.dirty = !1), e[x] &= -9217, s) ZC(r, e, r.template, e[Ce]); else if (o & 8192) { hp(e), gp(e, 1); let a = r.components; a !== null && vp(e, a, 1), up(e) } } function vp(e, t, n) { for (let r = 0; r < t.length; r++)QC(e, t[r], n) } function KC(e, t) { let n = e.hostBindingOpCodes; if (n !== null) try { for (let r = 0; r < n.length; r++) { let o = n[r]; if (o < 0) Jt(~o); else { let i = o, s = n[++r], a = n[++r]; zy(s, i); let l = t[i]; z(24, l), a(2, l), z(25, l) } } } finally { Jt(-1) } } function Lc(e, t) { let n = oh() ? 64 : 1088; for (e[dt].changeDetectionScheduler?.notify(t); e;) { e[x] |= n; let r = Kt(e); if (wi(e) && !r) return e; e = r } return null } function yp(e, t, n, r) { return [e, !0, 0, t, null, r, null, n, null, null] } function JC(e, t, n, r = !0) { let o = t[L]; if (XC(o, t, e, n), r) { let s = Fl(n, e), a = t[ie], l = a.parentNode(e[Qt]); l !== null && SC(o, e[$e], a, t, l, s) } let i = t[vi]; i !== null && i.firstChild !== null && (i.firstChild = null) } function Ll(e, t) { if (e.length <= Fe) return; let n = Fe + t, r = e[n]; if (r) { let o = r[Rn]; o !== null && o !== e && Pc(o, r), t > 0 && (e[n - 1][Ue] = r[Ue]); let i = gi(e, Fe + t); MC(r[L], r); let s = i[On]; s !== null && s.detachView(i[L]), r[he] = null, r[Ue] = null, r[x] &= -129 } return r } function XC(e, t, n, r) { let o = Fe + r, i = n.length; r > 0 && (n[o - 1][Ue] = t), r < i - Fe ? (t[Ue] = n[o], Of(n, Fe + r, t)) : (n.push(t), t[Ue] = null), t[he] = n; let s = t[Rn]; s !== null && n !== s && Dp(s, t); let a = t[On]; a !== null && a.insertView(e), El(t), t[x] |= 128 } function Dp(e, t) { let n = e[Ei], r = t[he]; if (St(r)) e[x] |= 2; else { let o = r[he][qe]; t[qe] !== o && (e[x] |= 2) } n === null ? e[Ei] = [t] : n.push(t) } var Mr = class { _lView; _cdRefInjectingView; notifyErrorHandler; _appRef = null; _attachedToViewContainer = !1; get rootNodes() { let t = this._lView, n = t[L]; return Oi(n, t, n.firstChild, []) } constructor(t, n, r = !0) { this._lView = t, this._cdRefInjectingView = n, this.notifyErrorHandler = r } get context() { return this._lView[Ce] } set context(t) { this._lView[Ce] = t } get destroyed() { return jn(this._lView) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { let t = this._lView[he]; if (mt(t)) { let n = t[Ci], r = n ? n.indexOf(this) : -1; r > -1 && (Ll(t, r), gi(n, r)) } this._attachedToViewContainer = !1 } lp(this._lView[L], this._lView) } onDestroy(t) { Jf(this._lView, t) } markForCheck() { Lc(this._cdRefInjectingView || this._lView, 4) } detach() { this._lView[x] &= -129 } reattach() { El(this._lView), this._lView[x] |= 128 } detectChanges() { this._lView[x] |= 1024, pp(this._lView, this.notifyErrorHandler) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new v(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null; let t = wi(this._lView), n = this._lView[Rn]; n !== null && !t && Pc(n, this._lView), ap(this._lView[L], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new v(902, !1); this._appRef = t; let n = wi(this._lView), r = this._lView[Rn]; r !== null && !n && Dp(r, this._lView), El(this._lView) } }; var Qi = (() => { class e { static __NG_ELEMENT_ID__ = nE } return e })(), eE = Qi, tE = class extends eE { _declarationLView; _declarationTContainer; elementRef; constructor(t, n, r) { super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = r } get ssrId() { return this._declarationTContainer.tView?.ssrId || null } createEmbeddedView(t, n) { return this.createEmbeddedViewImpl(t, n) } createEmbeddedViewImpl(t, n, r) { let o = _C(this._declarationLView, this._declarationTContainer, t, { embeddedViewInjector: n, dehydratedView: r }); return new Mr(o) } }; function nE() { return Cp(Se(), $()) } function Cp(e, t) { return e.type & 4 ? new tE(t, e, qi(e, t)) : null } function Vc(e, t, n, r, o) { let i = e.data[t]; if (i === null) i = rE(e, t, n, r, o), Hy() && (i.flags |= 32); else if (i.type & 64) { i.type = n, i.value = r, i.attrs = o; let s = Vy(); i.injectorIndex = s === null ? -1 : s.injectorIndex } return Rr(i, !0), i } function rE(e, t, n, r, o) { let i = nh(), s = rh(), a = s ? i : i && i.parent, l = e.data[t] = iE(e, a, n, t, r, o); return oE(e, l, i, s), l } function oE(e, t, n, r) { e.firstChild === null && (e.firstChild = t), n !== null && (r ? n.child == null && t.parent !== null && (n.child = t) : n.next === null && (n.next = t, t.prev = n)) } function iE(e, t, n, r, o, i) { let s = t ? t.injectorIndex : -1, a = 0; return Fy() && (a |= 128), { type: n, index: r, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: null, inputs: null, hostDirectiveInputs: null, outputs: null, hostDirectiveOutputs: null, directiveToIndex: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } } var lA = new RegExp(`^(\\d+)*(${AD}|${xD})*(.*)`); var sE = () => null; function nf(e, t) { return sE(e, t) } var aE = class { }, Ep = class { }, Vl = class { resolveComponentFactory(t) { throw Error(`No component factory found for ${De(t)}.`) } }, Ki = class { static NULL = new Vl }, Pn = class { }, At = (() => { class e { destroyNode = null; static __NG_ELEMENT_ID__ = () => lE() } return e })(); function lE() { let e = $(), t = Se(), n = Ye(t.index, e); return (St(n) ? n : e)[ie] } var cE = (() => { class e { static \u0275prov = _({ token: e, providedIn: "root", factory: () => null }) } return e })(); var sl = {}, jl = class { injector; parentInjector; constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { r = Bi(r); let o = this.injector.get(t, sl, r); return o !== sl || n === sl ? o : this.parentInjector.get(t, n, r) } }; function rf(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (t !== null) for (let s = 0; s < t.length; s++) { let a = t[s]; if (typeof a == "number") i = a; else if (i == 1) o = xd(o, a); else if (i == 2) { let l = a, c = t[++s]; r = xd(r, l + ": " + c + ";") } } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function E(e, t = R.Default) { let n = $(); if (n === null) return M(e, t); let r = Se(); return wh(r, n, de(e), t) } function wp(e, t, n, r, o) { let i = r === null ? null : { "": -1 }, s = o(e, n); if (s !== null) { let a, l = null, c = null, u = dE(s); u === null ? a = s : [a, l, c] = u, pE(e, t, n, a, i, l, c) } i !== null && r !== null && uE(n, r, i) } function uE(e, t, n) { let r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { let i = n[t[o + 1]]; if (i == null) throw new v(-301, !1); r.push(t[o], i) } } function dE(e) { let t = null, n = !1; for (let s = 0; s < e.length; s++) { let a = e[s]; if (s === 0 && We(a) && (t = a), a.findHostDirectiveDefs !== null) { n = !0; break } } if (!n) return null; let r = null, o = null, i = null; for (let s of e) s.findHostDirectiveDefs !== null && (r ??= [], o ??= new Map, i ??= new Map, fE(s, r, i, o)), s === t && (r ??= [], r.push(s)); return r !== null ? (r.push(...t === null ? e : e.slice(1)), [r, o, i]) : null } function fE(e, t, n, r) { let o = t.length; e.findHostDirectiveDefs(e, t, r), n.set(e, [o, t.length - 1]) } function hE(e, t, n) { t.componentOffset = n, (e.components ??= []).push(t.index) } function pE(e, t, n, r, o, i, s) { let a = r.length, l = !1; for (let h = 0; h < a; h++) { let d = r[h]; !l && We(d) && (l = !0, hE(e, n, h)), Il(Si(n, t), e, d.type) } CE(n, e.data.length, a); for (let h = 0; h < a; h++) { let d = r[h]; d.providersResolver && d.providersResolver(d) } let c = !1, u = !1, f = ep(e, t, a, null); a > 0 && (n.directiveToIndex = new Map); for (let h = 0; h < a; h++) { let d = r[h]; if (n.mergedAttrs = _r(n.mergedAttrs, d.hostAttrs), mE(e, n, t, f, d), DE(f, d, o), s !== null && s.has(d)) { let [y, I] = s.get(d); n.directiveToIndex.set(d.type, [f, y + n.directiveStart, I + n.directiveStart]) } else (i === null || !i.has(d)) && n.directiveToIndex.set(d.type, f); d.contentQueries !== null && (n.flags |= 4), (d.hostBindings !== null || d.hostAttrs !== null || d.hostVars !== 0) && (n.flags |= 64); let p = d.type.prototype; !c && (p.ngOnChanges || p.ngOnInit || p.ngDoCheck) && ((e.preOrderHooks ??= []).push(n.index), c = !0), !u && (p.ngOnChanges || p.ngDoCheck) && ((e.preOrderCheckHooks ??= []).push(n.index), u = !0), f++ } gE(e, n, i) } function gE(e, t, n) { for (let r = t.directiveStart; r < t.directiveEnd; r++) { let o = e.data[r]; if (n === null || !n.has(o)) of(0, t, o, r), of(1, t, o, r), af(t, r, !1); else { let i = n.get(o); sf(0, t, i, r), sf(1, t, i, r), af(t, r, !0) } } } function of(e, t, n, r) { let o = e === 0 ? n.inputs : n.outputs; for (let i in o) if (o.hasOwnProperty(i)) { let s; e === 0 ? s = t.inputs ??= {} : s = t.outputs ??= {}, s[i] ??= [], s[i].push(r), bp(t, i) } } function sf(e, t, n, r) { let o = e === 0 ? n.inputs : n.outputs; for (let i in o) if (o.hasOwnProperty(i)) { let s = o[i], a; e === 0 ? a = t.hostDirectiveInputs ??= {} : a = t.hostDirectiveOutputs ??= {}, a[s] ??= [], a[s].push(r, i), bp(t, s) } } function bp(e, t) { t === "class" ? e.flags |= 8 : t === "style" && (e.flags |= 16) } function af(e, t, n) { let { attrs: r, inputs: o, hostDirectiveInputs: i } = e; if (r === null || !n && o === null || n && i === null || Mc(e)) { e.initialInputs ??= [], e.initialInputs.push(null); return } let s = null, a = 0; for (; a < r.length;) { let l = r[a]; if (l === 0) { a += 4; continue } else if (l === 5) { a += 2; continue } else if (typeof l == "number") break; if (!n && o.hasOwnProperty(l)) { let c = o[l]; for (let u of c) if (u === t) { s ??= [], s.push(l, r[a + 1]); break } } else if (n && i.hasOwnProperty(l)) { let c = i[l]; for (let u = 0; u < c.length; u += 2)if (c[u] === t) { s ??= [], s.push(c[u + 1], r[a + 1]); break } } a += 2 } e.initialInputs ??= [], e.initialInputs.push(s) } function mE(e, t, n, r, o) { e.data[r] = o; let i = o.factory || (o.factory = Zt(o.type, !0)), s = new Xt(i, We(o), E); e.blueprint[r] = s, n[r] = s, vE(e, t, r, ep(e, n, o.hostVars, Dt), o) } function vE(e, t, n, r, o) { let i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; s === null && (s = e.hostBindingOpCodes = []); let a = ~t.index; yE(s) != a && s.push(a), s.push(n, r, i) } } function yE(e) { let t = e.length; for (; t > 0;) { let n = e[--t]; if (typeof n == "number" && n < 0) return n } return 0 } function DE(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; We(t) && (n[""] = e) } } function CE(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t } function _p(e, t, n, r, o, i, s, a) { let l = t.consts, c = bi(l, s), u = Vc(t, e, 2, r, c); return i && wp(t, n, u, bi(l, a), o), u.mergedAttrs = _r(u.mergedAttrs, u.attrs), u.attrs !== null && rf(u, u.attrs, !1), u.mergedAttrs !== null && rf(u, u.mergedAttrs, !0), t.queries !== null && t.queries.elementStart(t, u), u } function Ip(e, t) { hh(e, t), Hf(t) && e.queries.elementEnd(t) } var Pi = class extends Ki { ngModule; constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { let n = Nn(t); return new Sr(n, this.ngModule) } }; function EE(e) { return Object.keys(e).map(t => { let [n, r, o] = e[t], i = { propName: n, templateName: t, isSignal: (r & Zi.SignalBased) !== 0 }; return o && (i.transform = o), i }) } function wE(e) { return Object.keys(e).map(t => ({ propName: e[t], templateName: t })) } function bE(e, t, n) { let r = t instanceof fe ? t : t?.injector; return r && e.getStandaloneInjector !== null && (r = e.getStandaloneInjector(r) || r), r ? new jl(n, r) : n } function _E(e) { let t = e.get(Pn, null); if (t === null) throw new v(407, !1); let n = e.get(cE, null), r = e.get(Ir, null); return { rendererFactory: t, sanitizer: n, changeDetectionScheduler: r } } function IE(e, t) { let n = (e.selectors[0][0] || "div").toLowerCase(); return Qh(t, n, n === "svg" ? My : n === "math" ? Sy : null) } var Sr = class extends Ep { componentDef; ngModule; selector; componentType; ngContentSelectors; isBoundToModule; cachedInputs = null; cachedOutputs = null; get inputs() { return this.cachedInputs ??= EE(this.componentDef.inputs), this.cachedInputs } get outputs() { return this.cachedOutputs ??= wE(this.componentDef.outputs), this.cachedOutputs } constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = XD(t.selectors), this.ngContentSelectors = t.ngContentSelectors ?? [], this.isBoundToModule = !!n } create(t, n, r, o) { z(22); let i = F(null); try { let s = this.componentDef, a = r ? ["ng-version", "19.2.15"] : eC(this.componentDef.selectors[0]), l = Sc(0, null, null, 1, 0, null, null, null, null, [a], null), c = bE(s, o || this.ngModule, t), u = _E(c), f = u.rendererFactory.createRenderer(null, s), h = r ? cC(f, r, s.encapsulation, c) : IE(s, f), d = Tc(null, l, null, 512 | Xh(s), null, null, u, f, c, null, $h(h, c, !0)); d[Ie] = h, uc(d); let p = null; try { let y = _p(Ie, l, d, "#host", () => [this.componentDef], !0, 0); h && (Jh(f, h, y), Fr(h, d)), xc(l, d, y), zh(l, y, d), Ip(l, y), n !== void 0 && ME(y, this.ngContentSelectors, n), p = Ye(y.index, d), d[Ce] = p[Ce], Rc(l, d, null) } catch (y) { throw p !== null && Al(p), Al(d), y } finally { z(23), dc() } return new Bl(this.componentType, d) } finally { F(i) } } }, Bl = class extends aE { _rootLView; instance; hostView; changeDetectorRef; componentType; location; previousInputValues = null; _tNode; constructor(t, n) { super(), this._rootLView = n, this._tNode = Yf(n[L], Ie), this.location = qi(this._tNode, n), this.instance = Ye(this._tNode.index, n)[Ce], this.hostView = this.changeDetectorRef = new Mr(n, void 0, !1), this.componentType = t } setInput(t, n) { let r = this._tNode; if (this.previousInputValues ??= new Map, this.previousInputValues.has(t) && Object.is(this.previousInputValues.get(t), n)) return; let o = this._rootLView, i = Ac(r, o[L], o, t, n); this.previousInputValues.set(t, n); let s = Ye(r.index, o); Lc(s, 1) } get injector() { return new Wt(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } }; function ME(e, t, n) { let r = e.projection = []; for (let o = 0; o < t.length; o++) { let i = n[o]; r.push(i != null && i.length ? Array.from(i) : null) } } var Bn = (() => { class e { static __NG_ELEMENT_ID__ = SE } return e })(); function SE() { let e = Se(); return NE(e, $()) } var TE = Bn, Mp = class extends TE { _lContainer; _hostTNode; _hostLView; constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return qi(this._hostTNode, this._hostLView) } get injector() { return new Wt(this._hostTNode, this._hostLView) } get parentInjector() { let t = gc(this._hostTNode, this._hostLView); if (mh(t)) { let n = Ii(t, this._hostLView), r = _i(t), o = n[L].data[r + 8]; return new Wt(o, n) } else return new Wt(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { let n = lf(this._lContainer); return n !== null && n[t] || null } get length() { return this._lContainer.length - Fe } createEmbeddedView(t, n, r) { let o, i; typeof r == "number" ? o = r : r != null && (o = r.index, i = r.injector); let s = nf(this._lContainer, t.ssrId), a = t.createEmbeddedViewImpl(n || {}, i, s); return this.insertImpl(a, o, ef(this._hostTNode, s)), a } createComponent(t, n, r, o, i) { let s = t && !wy(t), a; if (s) a = n; else { let p = n || {}; a = p.index, r = p.injector, o = p.projectableNodes, i = p.environmentInjector || p.ngModuleRef } let l = s ? t : new Sr(Nn(t)), c = r || this.parentInjector; if (!i && l.ngModule == null) { let y = (s ? c : this.parentInjector).get(fe, null); y && (i = y) } let u = Nn(l.componentType ?? {}), f = nf(this._lContainer, u?.id ?? null), h = f?.firstChild ?? null, d = l.create(c, o, h, i); return this.insertImpl(d.hostView, a, ef(this._hostTNode, f)), d } insert(t, n) { return this.insertImpl(t, n, !0) } insertImpl(t, n, r) { let o = t._lView; if (Ny(o)) { let a = this.indexOf(t); if (a !== -1) this.detach(a); else { let l = o[he], c = new Mp(l, l[$e], l[he]); c.detach(c.indexOf(t)) } } let i = this._adjustIndex(n), s = this._lContainer; return JC(s, o, i, r), t.attachToViewContainerRef(), Of(al(s), i, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { let n = lf(this._lContainer); return n !== null ? n.indexOf(t) : -1 } remove(t) { let n = this._adjustIndex(t, -1), r = Ll(this._lContainer, n); r && (gi(al(this._lContainer), n), lp(r[L], r)) } detach(t) { let n = this._adjustIndex(t, -1), r = Ll(this._lContainer, n); return r && gi(al(this._lContainer), n) != null ? new Mr(r) : null } _adjustIndex(t, n = 0) { return t ?? this.length + n } }; function lf(e) { return e[Ci] } function al(e) { return e[Ci] || (e[Ci] = []) } function NE(e, t) { let n, r = t[e.index]; return mt(r) ? n = r : (n = yp(r, t, null, e), t[e.index] = n, Nc(t, n)), AE(n, t, e, r), new Mp(n, e, t) } function xE(e, t) { let n = e[ie], r = n.createComment(""), o = Xe(t, e), i = n.parentNode(o); return Ri(n, i, r, n.nextSibling(o), !1), r } var AE = PE, RE = () => !1; function OE(e, t, n) { return RE(e, t, n) } function PE(e, t, n, r) { if (e[Qt]) return; let o; n.type & 8 ? o = Ze(r) : o = xE(t, n), e[Qt] = o } var Fn = class { }, jc = class { }; var Ul = class extends Fn { ngModuleType; _parent; _bootstrapComponents = []; _r3Injector; instance; destroyCbs = []; componentFactoryResolver = new Pi(this); constructor(t, n, r, o = !0) { super(), this.ngModuleType = t, this._parent = n; let i = kf(t); this._bootstrapComponents = Zh(i.bootstrap), this._r3Injector = Ih(t, n, [{ provide: Fn, useValue: this }, { provide: Ki, useValue: this.componentFactoryResolver }, ...r], De(t), new Set(["environment"])), o && this.resolveInjectorInitializers() } resolveInjectorInitializers() { this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(this.ngModuleType) } get injector() { return this._r3Injector } destroy() { let t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } }, $l = class extends jc { moduleType; constructor(t) { super(), this.moduleType = t } create(t) { return new Ul(this.moduleType, t, []) } }; var Fi = class extends Fn { injector; componentFactoryResolver = new Pi(this); instance = null; constructor(t) { super(); let n = new wr([...t.providers, { provide: Fn, useValue: this }, { provide: Ki, useValue: this.componentFactoryResolver }], t.parent || rc(), t.debugName, new Set(["environment"])); this.injector = n, t.runEnvironmentInitializers && n.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(t) { this.injector.onDestroy(t) } }; function Ji(e, t, n = null) { return new Fi({ providers: e, parent: t, debugName: n, runEnvironmentInitializers: !0 }).injector } var FE = (() => { class e { _injector; cachedInjectors = new Map; constructor(n) { this._injector = n } getOrCreateStandaloneInjector(n) { if (!n.standalone) return null; if (!this.cachedInjectors.has(n)) { let r = Lf(!1, n.type), o = r.length > 0 ? Ji([r], this._injector, `Standalone[${n.type.name}]`) : null; this.cachedInjectors.set(n, o) } return this.cachedInjectors.get(n) } ngOnDestroy() { try { for (let n of this.cachedInjectors.values()) n !== null && n.destroy() } finally { this.cachedInjectors.clear() } } static \u0275prov = _({ token: e, providedIn: "environment", factory: () => new e(M(fe)) }) } return e })(); function ke(e) { return Nr(() => { let t = Sp(e), n = P(m({}, t), { decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === Ph.OnPush, directiveDefs: null, pipeDefs: null, dependencies: t.standalone && e.dependencies || null, getStandaloneInjector: t.standalone ? o => o.get(FE).getOrCreateStandaloneInjector(n) : null, getExternalStyles: null, signals: e.signals ?? !1, data: e.data || {}, encapsulation: e.encapsulation || Qe.Emulated, styles: e.styles || Oe, _: null, schemas: e.schemas || null, tView: null, id: "" }); t.standalone && bc("NgStandalone"), Tp(n); let r = e.dependencies; return n.directiveDefs = cf(r, !1), n.pipeDefs = cf(r, !0), n.id = BE(n), n }) } function kE(e) { return Nn(e) || cy(e) } function LE(e) { return e !== null } function et(e) { return Nr(() => ({ type: e.type, bootstrap: e.bootstrap || Oe, declarations: e.declarations || Oe, imports: e.imports || Oe, exports: e.exports || Oe, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function VE(e, t) { if (e == null) return Yt; let n = {}; for (let r in e) if (e.hasOwnProperty(r)) { let o = e[r], i, s, a, l; Array.isArray(o) ? (a = o[0], i = o[1], s = o[2] ?? i, l = o[3] || null) : (i = o, s = o, a = Zi.None, l = null), n[i] = [r, a, l], t[i] = s } return n } function jE(e) { if (e == null) return Yt; let t = {}; for (let n in e) e.hasOwnProperty(n) && (t[e[n]] = n); return t } function Y(e) { return Nr(() => { let t = Sp(e); return Tp(t), t }) } function Xi(e) { return { type: e.type, name: e.name, factory: null, pure: e.pure !== !1, standalone: e.standalone ?? !0, onDestroy: e.type.prototype.ngOnDestroy || null } } function Sp(e) { let t = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: t, inputConfig: e.inputs || Yt, exportAs: e.exportAs || null, standalone: e.standalone ?? !0, signals: e.signals === !0, selectors: e.selectors || Oe, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: VE(e.inputs, t), outputs: jE(e.outputs), debugInfo: null } } function Tp(e) { e.features?.forEach(t => t(e)) } function cf(e, t) { if (!e) return null; let n = t ? uy : kE; return () => (typeof e == "function" ? e() : e).map(r => n(r)).filter(LE) } function BE(e) { let t = 0, n = typeof e.consts == "function" ? "" : e.consts, r = [e.selectors, e.ngContentSelectors, e.hostVars, e.hostAttrs, n, e.vars, e.decls, e.encapsulation, e.standalone, e.signals, e.exportAs, JSON.stringify(e.inputs), JSON.stringify(e.outputs), Object.getOwnPropertyNames(e.type.prototype), !!e.contentQueries, !!e.viewQuery]; for (let i of r.join("|")) t = Math.imul(31, t) + i.charCodeAt(0) << 0; return t += 2147483648, "c" + t } function UE(e) { return Object.getPrototypeOf(e.prototype).constructor } function Le(e) { let t = UE(e.type), n = !0, r = [e]; for (; t;) { let o; if (We(e)) o = t.\u0275cmp || t.\u0275dir; else { if (t.\u0275cmp) throw new v(903, !1); o = t.\u0275dir } if (o) { if (n) { r.push(o); let s = e; s.inputs = ll(e.inputs), s.declaredInputs = ll(e.declaredInputs), s.outputs = ll(e.outputs); let a = o.hostBindings; a && qE(e, a); let l = o.viewQuery, c = o.contentQueries; if (l && zE(e, l), c && GE(e, c), $E(e, o), Uv(e.outputs, o.outputs), We(o) && o.data.animation) { let u = e.data; u.animation = (u.animation || []).concat(o.data.animation) } } let i = o.features; if (i) for (let s = 0; s < i.length; s++) { let a = i[s]; a && a.ngInherit && a(e), a === Le && (n = !1) } } t = Object.getPrototypeOf(t) } HE(r) } function $E(e, t) { for (let n in t.inputs) { if (!t.inputs.hasOwnProperty(n) || e.inputs.hasOwnProperty(n)) continue; let r = t.inputs[n]; r !== void 0 && (e.inputs[n] = r, e.declaredInputs[n] = t.declaredInputs[n]) } } function HE(e) { let t = 0, n = null; for (let r = e.length - 1; r >= 0; r--) { let o = e[r]; o.hostVars = t += o.hostVars, o.hostAttrs = _r(o.hostAttrs, n = _r(n, o.hostAttrs)) } } function ll(e) { return e === Yt ? {} : e === Oe ? [] : e } function zE(e, t) { let n = e.viewQuery; n ? e.viewQuery = (r, o) => { t(r, o), n(r, o) } : e.viewQuery = t } function GE(e, t) { let n = e.contentQueries; n ? e.contentQueries = (r, o, i) => { t(r, o, i), n(r, o, i) } : e.contentQueries = t } function qE(e, t) { let n = e.hostBindings; n ? e.hostBindings = (r, o) => { t(r, o), n(r, o) } : e.hostBindings = t } function Np(e) { return ZE(e) ? Array.isArray(e) || !(e instanceof Map) && Symbol.iterator in e : !1 } function WE(e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { let n = e[Symbol.iterator](), r; for (; !(r = n.next()).done;)t(r.value) } } function ZE(e) { return e !== null && (typeof e == "function" || typeof e == "object") } function xp(e, t, n) { return e[t] = n } function Tt(e, t, n) { let r = e[t]; return Object.is(r, n) ? !1 : (e[t] = n, !0) } function Ap(e, t, n, r) { let o = Tt(e, t, n); return Tt(e, t + 1, r) || o } function YE(e, t, n, r, o, i, s, a, l) { let c = t.consts, u = Vc(t, e, 4, s || null, a || null); th() && wp(t, n, u, bi(c, l), ip), u.mergedAttrs = _r(u.mergedAttrs, u.attrs), hh(t, u); let f = u.tView = Sc(2, u, r, o, i, t.directiveRegistry, t.pipeRegistry, null, t.schemas, c, null); return t.queries !== null && (t.queries.template(t, u), f.queries = t.queries.embeddedTView(u)), u } function QE(e, t, n, r, o, i, s, a, l, c) { let u = n + Ie, f = t.firstCreatePass ? YE(u, t, e, r, o, i, s, a, l) : t.data[u]; Rr(f, !1); let h = KE(t, e, f, n); hc() && Fc(t, e, h, f), Fr(h, e); let d = yp(h, e, h, f); return e[u] = d, Nc(e, d), OE(d, f, e), oc(f) && xc(t, e, f), l != null && rp(e, f, c), f } function Rt(e, t, n, r, o, i, s, a) { let l = $(), c = Ee(), u = bi(c.consts, i); return QE(l, c, e, t, n, r, o, u, s, a), Rt } var KE = JE; function JE(e, t, n, r) { return pc(!0), t[ie].createComment("") } var Rp = (() => { class e { log(n) { console.log(n) } warn(n) { console.warn(n) } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "platform" }) } return e })(); var Op = new D(""); var XE = (() => { class e { static \u0275prov = _({ token: e, providedIn: "root", factory: () => new Hl }) } return e })(), Hl = class { queuedEffectCount = 0; queues = new Map; schedule(t) { this.enqueue(t) } remove(t) { let n = t.zone, r = this.queues.get(n); r.has(t) && (r.delete(t), this.queuedEffectCount--) } enqueue(t) { let n = t.zone; this.queues.has(n) || this.queues.set(n, new Set); let r = this.queues.get(n); r.has(t) || (this.queuedEffectCount++, r.add(t)) } flush() { for (; this.queuedEffectCount > 0;)for (let [t, n] of this.queues) t === null ? this.flushQueue(n) : t.run(() => this.flushQueue(n)) } flushQueue(t) { for (let n of t) t.delete(n), this.queuedEffectCount--, n.run() } }; function Ot(e) { return !!e && typeof e.then == "function" } function Bc(e) { return !!e && typeof e.subscribe == "function" } var ew = new D(""); var Pp = (() => { class e { resolve; reject; initialized = !1; done = !1; donePromise = new Promise((n, r) => { this.resolve = n, this.reject = r }); appInits = g(ew, { optional: !0 }) ?? []; injector = g(ft); constructor() { } runInitializers() { if (this.initialized) return; let n = []; for (let o of this.appInits) { let i = Me(this.injector, o); if (Ot(i)) n.push(i); else if (Bc(i)) { let s = new Promise((a, l) => { i.subscribe({ complete: a, error: l }) }); n.push(s) } } let r = () => { this.done = !0, this.resolve() }; Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), n.length === 0 && r(), this.initialized = !0 } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), Uc = new D(""); function tw() { Oa(() => { throw new v(600, !1) }) } function nw(e) { return e.isBoundToModule } var rw = 10; var en = (() => { class e { _runningTick = !1; _destroyed = !1; _destroyListeners = []; _views = []; internalErrorHandler = g(CD); afterRenderManager = g(OD); zonelessEnabled = g(vc); rootEffectScheduler = g(XE); dirtyFlags = 0; tracingSnapshot = null; externalTestViews = new Set; afterTick = new K; get allViews() { return [...this.externalTestViews.keys(), ...this._views] } get destroyed() { return this._destroyed } componentTypes = []; components = []; isStable = g(xt).hasPendingTasks.pipe(T(n => !n)); constructor() { g(Wi, { optional: !0 }) } whenStable() { let n; return new Promise(r => { n = this.isStable.subscribe({ next: o => { o && r() } }) }).finally(() => { n.unsubscribe() }) } _injector = g(fe); _rendererFactory = null; get injector() { return this._injector } bootstrap(n, r) { return this.bootstrapImpl(n, r) } bootstrapImpl(n, r, o = ft.NULL) { z(10); let i = n instanceof Ep; if (!this._injector.get(Pp).done) { let d = ""; throw new v(405, d) } let a; i ? a = n : a = this._injector.get(Ki).resolveComponentFactory(n), this.componentTypes.push(a.componentType); let l = nw(a) ? void 0 : this._injector.get(Fn), c = r || a.selector, u = a.create(o, [], c, l), f = u.location.nativeElement, h = u.injector.get(Op, null); return h?.registerApplication(f), u.onDestroy(() => { this.detachView(u.hostView), ui(this.components, u), h?.unregisterApplication(f) }), this._loadComponent(u), z(11, u), u } tick() { this.zonelessEnabled || (this.dirtyFlags |= 1), this._tick() } _tick() { z(12), this.tracingSnapshot !== null ? this.tracingSnapshot.run(Uh.CHANGE_DETECTION, this.tickImpl) : this.tickImpl() } tickImpl = () => { if (this._runningTick) throw new v(101, !1); let n = F(null); try { this._runningTick = !0, this.synchronize() } catch (r) { this.internalErrorHandler(r) } finally { this._runningTick = !1, this.tracingSnapshot?.dispose(), this.tracingSnapshot = null, F(n), this.afterTick.next(), z(13) } }; synchronize() { this._rendererFactory === null && !this._injector.destroyed && (this._rendererFactory = this._injector.get(Pn, null, { optional: !0 })); let n = 0; for (; this.dirtyFlags !== 0 && n++ < rw;)z(14), this.synchronizeOnce(), z(15) } synchronizeOnce() { if (this.dirtyFlags & 16 && (this.dirtyFlags &= -17, this.rootEffectScheduler.flush()), this.dirtyFlags & 7) { let n = !!(this.dirtyFlags & 1); this.dirtyFlags &= -8, this.dirtyFlags |= 8; for (let { _lView: r, notifyErrorHandler: o } of this.allViews) ow(r, o, n, this.zonelessEnabled); if (this.dirtyFlags &= -5, this.syncDirtyFlagsWithViews(), this.dirtyFlags & 23) return } else this._rendererFactory?.begin?.(), this._rendererFactory?.end?.(); this.dirtyFlags & 8 && (this.dirtyFlags &= -9, this.afterRenderManager.execute()), this.syncDirtyFlagsWithViews() } syncDirtyFlagsWithViews() { if (this.allViews.some(({ _lView: n }) => Hi(n))) { this.dirtyFlags |= 2; return } else this.dirtyFlags &= -8 } attachView(n) { let r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { let r = n; ui(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(Uc, []).forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()) } finally { this._destroyed = !0, this._views = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => ui(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new v(406, !1); let n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function ui(e, t) { let n = e.indexOf(t); n > -1 && e.splice(n, 1) } function ow(e, t, n, r) { if (!n && !Hi(e)) return; pp(e, t, n && !r ? 0 : 1) } function es(e, t, n, r) { let o = $(), i = Gi(); if (Tt(o, i, t)) { let s = Ee(), a = fc(); vC(a, o, e, t, n, r) } return es } function iw(e, t, n, r) { return Tt(e, Gi(), n) ? t + Tn(n) + r : Dt } function sw(e, t, n, r, o, i) { let s = Uy(), a = Ap(e, s, n, o); return ih(2), a ? t + Tn(n) + r + Tn(o) + i : Dt } function si(e, t) { return e << 17 | t << 2 } function tn(e) { return e >> 17 & 32767 } function aw(e) { return (e & 2) == 2 } function lw(e, t) { return e & 131071 | t << 17 } function zl(e) { return e | 2 } function kn(e) { return (e & 131068) >> 2 } function cl(e, t) { return e & -131069 | t << 2 } function cw(e) { return (e & 1) === 1 } function Gl(e) { return e | 1 } function uw(e, t, n, r, o, i) { let s = i ? t.classBindings : t.styleBindings, a = tn(s), l = kn(s); e[r] = n; let c = !1, u; if (Array.isArray(n)) { let f = n; u = f[1], (u === null || xr(f, u) > 0) && (c = !0) } else u = n; if (o) if (l !== 0) { let h = tn(e[a + 1]); e[r + 1] = si(h, a), h !== 0 && (e[h + 1] = cl(e[h + 1], r)), e[a + 1] = lw(e[a + 1], r) } else e[r + 1] = si(a, 0), a !== 0 && (e[a + 1] = cl(e[a + 1], r)), a = r; else e[r + 1] = si(l, 0), a === 0 ? a = r : e[l + 1] = cl(e[l + 1], r), l = r; c && (e[r + 1] = zl(e[r + 1])), uf(e, u, r, !0), uf(e, u, r, !1), dw(t, u, e, r, i), s = si(a, l), i ? t.classBindings = s : t.styleBindings = s } function dw(e, t, n, r, o) { let i = o ? e.residualClasses : e.residualStyles; i != null && typeof t == "string" && xr(i, t) >= 0 && (n[r + 1] = Gl(n[r + 1])) } function uf(e, t, n, r) { let o = e[n + 1], i = t === null, s = r ? tn(o) : kn(o), a = !1; for (; s !== 0 && (a === !1 || i);) { let l = e[s], c = e[s + 1]; fw(l, t) && (a = !0, e[s + 1] = r ? Gl(c) : zl(c)), s = r ? tn(c) : kn(c) } a && (e[n + 1] = r ? zl(o) : Gl(o)) } function fw(e, t) { return e === null || t == null || (Array.isArray(e) ? e[1] : e) === t ? !0 : Array.isArray(e) && typeof t == "string" ? xr(e, t) >= 0 : !1 } function pe(e, t, n) { let r = $(), o = Gi(); if (Tt(r, o, t)) { let i = Ee(), s = fc(); op(i, s, r, e, t, r[ie], n, !1) } return pe } function df(e, t, n, r, o) { Ac(t, e, n, o ? "class" : "style", r) } function $c(e, t, n) { return Fp(e, t, n, !1), $c } function ts(e, t) { return Fp(e, t, null, !0), ts } function Fp(e, t, n, r) { let o = $(), i = Ee(), s = ih(2); if (i.firstUpdatePass && pw(i, e, s, r), t !== Dt && Tt(o, s, t)) { let a = i.data[nn()]; Dw(i, a, o, o[ie], e, o[s + 1] = Cw(t, n), r, s) } } function hw(e, t) { return t >= e.expandoStartIndex } function pw(e, t, n, r) { let o = e.data; if (o[n + 1] === null) { let i = o[nn()], s = hw(e, n); Ew(i, r) && t === null && !s && (t = !1), t = gw(o, i, t, r), uw(o, i, t, n, s, r) } } function gw(e, t, n, r) { let o = qy(e), i = r ? t.residualClasses : t.residualStyles; if (o === null) (r ? t.classBindings : t.styleBindings) === 0 && (n = ul(null, e, t, n, r), n = Tr(n, t.attrs, r), i = null); else { let s = t.directiveStylingLast; if (s === -1 || e[s] !== o) if (n = ul(o, e, t, n, r), i === null) { let l = mw(e, t, r); l !== void 0 && Array.isArray(l) && (l = ul(null, e, t, l[1], r), l = Tr(l, t.attrs, r), vw(e, t, r, l)) } else i = yw(e, t, r) } return i !== void 0 && (r ? t.residualClasses = i : t.residualStyles = i), n } function mw(e, t, n) { let r = n ? t.classBindings : t.styleBindings; if (kn(r) !== 0) return e[tn(r)] } function vw(e, t, n, r) { let o = n ? t.classBindings : t.styleBindings; e[tn(o)] = r } function yw(e, t, n) { let r, o = t.directiveEnd; for (let i = 1 + t.directiveStylingLast; i < o; i++) { let s = e[i].hostAttrs; r = Tr(r, s, n) } return Tr(r, t.attrs, n) } function ul(e, t, n, r, o) { let i = null, s = n.directiveEnd, a = n.directiveStylingLast; for (a === -1 ? a = n.directiveStart : a++; a < s && (i = t[a], r = Tr(r, i.hostAttrs, o), i !== e);)a++; return e !== null && (n.directiveStylingLast = a), r } function Tr(e, t, n) { let r = n ? 1 : 2, o = -1; if (t !== null) for (let i = 0; i < t.length; i++) { let s = t[i]; typeof s == "number" ? o = s : o === r && (Array.isArray(e) || (e = e === void 0 ? [] : ["", e]), ay(e, s, n ? !0 : t[++i])) } return e === void 0 ? null : e } function Dw(e, t, n, r, o, i, s, a) { if (!(t.type & 3)) return; let l = e.data, c = l[a + 1], u = cw(c) ? ff(l, t, n, o, kn(c), s) : void 0; if (!ki(u)) { ki(i) || aw(c) && (i = ff(l, null, n, o, a, s)); let f = Zf(nn(), n); VC(r, s, f, o, i) } } function ff(e, t, n, r, o, i) { let s = t === null, a; for (; o > 0;) { let l = e[o], c = Array.isArray(l), u = c ? l[1] : l, f = u === null, h = n[o + 1]; h === Dt && (h = f ? Oe : void 0); let d = f ? Xa(h, r) : u === r ? h : void 0; if (c && !ki(d) && (d = Xa(l, r)), ki(d) && (a = d, s)) return a; let p = e[o + 1]; o = s ? tn(p) : kn(p) } if (t !== null) { let l = i ? t.residualClasses : t.residualStyles; l != null && (a = Xa(l, r)) } return a } function ki(e) { return e !== void 0 } function Cw(e, t) { return e == null || e === "" || (typeof t == "string" ? e = e + t : typeof e == "object" && (e = De(_c(e)))), e } function Ew(e, t) { return (e.flags & (t ? 8 : 16)) !== 0 } function b(e, t, n, r) { let o = $(), i = Ee(), s = Ie + e, a = o[ie], l = i.firstCreatePass ? _p(s, i, o, t, ip, th(), n, r) : i.data[s], c = ww(i, o, l, a, t, e); o[s] = c; let u = oc(l); return Rr(l, !0), Jh(a, c, l), !sp(l) && hc() && Fc(i, o, c, l), (Ry() === 0 || u) && Fr(c, o), Oy(), u && (xc(i, o, l), zh(i, l, o)), r !== null && rp(o, l), b } function C() { let e = Se(); rh() ? jy() : (e = e.parent, Rr(e, !1)); let t = e; ky(t) && Ly(), Py(); let n = Ee(); return n.firstCreatePass && Ip(n, t), t.classesWithoutHost != null && Jy(t) && df(n, t, $(), t.classesWithoutHost, !0), t.stylesWithoutHost != null && Xy(t) && df(n, t, $(), t.stylesWithoutHost, !1), C } function q(e, t, n, r) { return b(e, t, n, r), C(), q } var ww = (e, t, n, r, o, i) => (pc(!0), Qh(r, o, Yy())); function Hc() { return $() } var Li = "en-US"; var bw = Li; function _w(e) { typeof e == "string" && (bw = e.toLowerCase().replace(/_/g, "-")) } function hf(e, t, n) { return function r(o) { if (o === Function) return n; let i = Vn(e) ? Ye(e.index, t) : t; Lc(i, 5); let s = t[Ce], a = pf(t, s, n, o), l = r.__ngNextListenerFn__; for (; l;)a = pf(t, s, l, o) && a, l = l.__ngNextListenerFn__; return a } } function pf(e, t, n, r) { let o = F(null); try { return z(6, t, n), n(r) !== !1 } catch (i) { return Iw(e, i), !1 } finally { z(7, t, n), F(o) } } function Iw(e, t) { let n = e[An], r = n ? n.get(ht, null) : null; r && r.handleError(t) } function gf(e, t, n, r, o, i) { let s = t[n], a = t[L], c = a.data[n].outputs[r], u = s[c], f = a.firstCreatePass ? eh(a) : null, h = Xf(t), d = u.subscribe(i), p = h.length; h.push(i, d), f && f.push(o, e.index, p, -(p + 1)) } function ge(e, t, n, r) { let o = $(), i = Ee(), s = Se(); return kp(i, o, o[ie], s, e, t, r), ge } function Mw(e, t, n, r) { let o = e.cleanup; if (o != null) for (let i = 0; i < o.length - 1; i += 2) { let s = o[i]; if (s === n && o[i + 1] === r) { let a = t[yi], l = o[i + 2]; return a.length > l ? a[l] : null } typeof s == "string" && (i += 2) } return null } function kp(e, t, n, r, o, i, s) { let a = oc(r), c = e.firstCreatePass ? eh(e) : null, u = Xf(t), f = !0; if (r.type & 3 || s) { let h = Xe(r, t), d = s ? s(h) : h, p = u.length, y = s ? j => s(Ze(j[r.index])) : r.index, I = null; if (!s && a && (I = Mw(e, t, o, r.index)), I !== null) { let j = I.__ngLastListenerFn__ || I; j.__ngNextListenerFn__ = i, I.__ngLastListenerFn__ = i, f = !1 } else { i = hf(r, t, i), FD(t, d, o, i); let j = n.listen(d, o, i); u.push(i, j), c && c.push(o, y, p, p + 1) } } else i = hf(r, t, i); if (f) { let h = r.outputs?.[o], d = r.hostDirectiveOutputs?.[o]; if (d && d.length) for (let p = 0; p < d.length; p += 2) { let y = d[p], I = d[p + 1]; gf(r, t, y, I, o, i) } if (h && h.length) for (let p of h) gf(r, t, p, o, o, i) } } function ns(e = 1) { return Zy(e) } function Lp(e) { let t = By(); return ic(t, Ie + e) } function w(e, t = "") { let n = $(), r = Ee(), o = e + Ie, i = r.firstCreatePass ? Vc(r, o, 1, t, null) : r.data[o], s = Sw(r, n, i, t, e); n[o] = s, hc() && Fc(r, n, s, i), Rr(i, !1) } var Sw = (e, t, n, r, o) => (pc(!0), tC(t[ie], r)); function tt(e, t, n) { let r = $(), o = iw(r, e, t, n); return o !== Dt && Vp(r, nn(), o), tt } function zc(e, t, n, r, o) { let i = $(), s = sw(i, e, t, n, r, o); return s !== Dt && Vp(i, nn(), s), zc } function Vp(e, t, n) { let r = Zf(t, e); nC(e[ie], r, n) } function Gc(e, t, n) { Rh(t) && (t = t()); let r = $(), o = Gi(); if (Tt(r, o, t)) { let i = Ee(), s = fc(); op(i, s, r, e, t, r[ie], n, !1) } return Gc } function jp(e, t) { let n = Rh(e); return n && e.set(t), n } function qc(e, t) { let n = $(), r = Ee(), o = Se(); return kp(r, n, n[ie], o, e, t), qc } function Tw(e, t, n) { let r = Ee(); if (r.firstCreatePass) { let o = We(e); ql(n, r.data, r.blueprint, o, !0), ql(t, r.data, r.blueprint, o, !1) } } function ql(e, t, n, r, o) { if (e = de(e), Array.isArray(e)) for (let i = 0; i < e.length; i++)ql(e[i], t, n, r, o); else { let i = Ee(), s = $(), a = Se(), l = xn(e) ? e : de(e.provide), c = Bf(e), u = a.providerIndexes & 1048575, f = a.directiveStart, h = a.providerIndexes >> 20; if (xn(e) || !e.multi) { let d = new Xt(c, o, E), p = fl(l, t, o ? u : u + h, f); p === -1 ? (Il(Si(a, s), i, l), dl(i, e, t.length), t.push(l), a.directiveStart++, a.directiveEnd++, o && (a.providerIndexes += 1048576), n.push(d), s.push(d)) : (n[p] = d, s[p] = d) } else { let d = fl(l, t, u + h, f), p = fl(l, t, u, u + h), y = d >= 0 && n[d], I = p >= 0 && n[p]; if (o && !I || !o && !y) { Il(Si(a, s), i, l); let j = Aw(o ? xw : Nw, n.length, o, r, c); !o && I && (n[p].providerFactory = j), dl(i, e, t.length, 0), t.push(l), a.directiveStart++, a.directiveEnd++, o && (a.providerIndexes += 1048576), n.push(j), s.push(j) } else { let j = Bp(n[o ? p : d], c, !o && r); dl(i, e, d > -1 ? d : p, j) } !o && r && I && n[p].componentProviders++ } } } function dl(e, t, n, r) { let o = xn(t), i = gy(t); if (o || i) { let l = (i ? de(t.useClass) : t).prototype.ngOnDestroy; if (l) { let c = e.destroyHooks || (e.destroyHooks = []); if (!o && t.multi) { let u = c.indexOf(n); u === -1 ? c.push(n, [r, l]) : c[u + 1].push(r, l) } else c.push(n, l) } } } function Bp(e, t, n) { return n && e.componentProviders++, e.multi.push(t) - 1 } function fl(e, t, n, r) { for (let o = n; o < r; o++)if (t[o] === e) return o; return -1 } function Nw(e, t, n, r, o) { return Wl(this.multi, []) } function xw(e, t, n, r, o) { let i = this.multi, s; if (this.providerFactory) { let a = this.providerFactory.componentProviders, l = Ti(r, r[L], this.providerFactory.index, o); s = l.slice(0, a), Wl(i, s); for (let c = a; c < l.length; c++)s.push(l[c]) } else s = [], Wl(i, s); return s } function Wl(e, t) { for (let n = 0; n < e.length; n++) { let r = e[n]; t.push(r()) } return t } function Aw(e, t, n, r, o) { let i = new Xt(e, n, E); return i.multi = [], i.index = t, i.componentProviders = 0, Bp(i, o, r && !n), i } function Pt(e, t = []) { return n => { n.providersResolver = (r, o) => Tw(r, o ? o(e) : e, t) } } function Wc(e, t, n, r) { return $p($(), cc(), e, t, n, r) } function Up(e, t) { let n = e[t]; return n === Dt ? void 0 : n } function $p(e, t, n, r, o, i) { let s = t + n; return Tt(e, s, o) ? xp(e, s + 1, i ? r.call(i, o) : r(o)) : Up(e, s + 1) } function Rw(e, t, n, r, o, i, s) { let a = t + n; return Ap(e, a, o, i) ? xp(e, a + 2, s ? r.call(s, o, i) : r(o, i)) : Up(e, a + 2) } function Lr(e, t) { let n = Ee(), r, o = e + Ie; n.firstCreatePass ? (r = Ow(t, n.pipeRegistry), n.data[o] = r, r.onDestroy && (n.destroyHooks ??= []).push(o, r.onDestroy)) : r = n.data[o]; let i = r.factory || (r.factory = Zt(r.type, !0)), s, a = ye(E); try { let l = Mi(!1), c = i(); return Mi(l), Ty(n, $(), o, c), c } finally { ye(a) } } function Ow(e, t) { if (t) for (let n = t.length - 1; n >= 0; n--) { let r = t[n]; if (e === r.name) return r } } function rs(e, t, n) { let r = e + Ie, o = $(), i = ic(o, r); return zp(o, r) ? $p(o, cc(), t, i.transform, n, i) : i.transform(n) } function Hp(e, t, n, r) { let o = e + Ie, i = $(), s = ic(i, o); return zp(i, o) ? Rw(i, cc(), t, s.transform, n, r, s) : s.transform(n, r) } function zp(e, t) { return e[L].data[t].pure } function Gp(e, t) { return Cp(e, t) } var Zl = class { ngModuleFactory; componentFactories; constructor(t, n) { this.ngModuleFactory = t, this.componentFactories = n } }, qp = (() => { class e { compileModuleSync(n) { return new $l(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { let r = this.compileModuleSync(n), o = kf(n), i = Zh(o.declarations).reduce((s, a) => { let l = Nn(a); return l && s.push(new Sr(l)), s }, []); return new Zl(r, i) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); var Pw = (() => { class e { zone = g(oe); changeDetectionScheduler = g(Ir); applicationRef = g(en); _onMicrotaskEmptySubscription; initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.changeDetectionScheduler.runningTick || this.zone.run(() => { this.applicationRef.tick() }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), Fw = new D("", { factory: () => !1 }); function Wp({ ngZoneFactory: e, ignoreChangesOutsideZone: t, scheduleInRootZone: n }) { return e ??= () => new oe(P(m({}, Yp()), { scheduleInRootZone: n })), [{ provide: oe, useFactory: e }, { provide: Er, multi: !0, useFactory: () => { let r = g(Pw, { optional: !0 }); return () => r.initialize() } }, { provide: Er, multi: !0, useFactory: () => { let r = g(kw); return () => { r.initialize() } } }, t === !0 ? { provide: Sh, useValue: !0 } : [], { provide: Th, useValue: n ?? Mh }] } function Zp(e) { let t = e?.ignoreChangesOutsideZone, n = e?.scheduleInRootZone, r = Wp({ ngZoneFactory: () => { let o = Yp(e); return o.scheduleInRootZone = n, o.shouldCoalesceEventChangeDetection && bc("NgZone_CoalesceEvent"), new oe(o) }, ignoreChangesOutsideZone: t, scheduleInRootZone: n }); return Ar([{ provide: Fw, useValue: !0 }, { provide: vc, useValue: !1 }, r]) } function Yp(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: e?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: e?.runCoalescing ?? !1 } } var kw = (() => { class e { subscription = new Q; initialized = !1; zone = g(oe); pendingTasks = g(xt); initialize() { if (this.initialized) return; this.initialized = !0; let n = null; !this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (n = this.pendingTasks.add()), this.zone.runOutsideAngular(() => { this.subscription.add(this.zone.onStable.subscribe(() => { oe.assertNotInAngularZone(), queueMicrotask(() => { n !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (this.pendingTasks.remove(n), n = null) }) })) }), this.subscription.add(this.zone.onUnstable.subscribe(() => { oe.assertInAngularZone(), n ??= this.pendingTasks.add() })) } ngOnDestroy() { this.subscription.unsubscribe() } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); var Lw = (() => { class e { appRef = g(en); taskService = g(xt); ngZone = g(oe); zonelessEnabled = g(vc); tracing = g(Wi, { optional: !0 }); disableScheduling = g(Sh, { optional: !0 }) ?? !1; zoneIsDefined = typeof Zone < "u" && !!Zone.root.run; schedulerTickApplyArgs = [{ data: { __scheduler_tick__: !0 } }]; subscriptions = new Q; angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(xi) : null; scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && (g(Th, { optional: !0 }) ?? !1); cancelScheduledCallback = null; useMicrotaskScheduler = !1; runningTick = !1; pendingRenderTaskId = null; constructor() { this.subscriptions.add(this.appRef.afterTick.subscribe(() => { this.runningTick || this.cleanup() })), this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => { this.runningTick || this.cleanup() })), this.disableScheduling ||= !this.zonelessEnabled && (this.ngZone instanceof xl || !this.zoneIsDefined) } notify(n) { if (!this.zonelessEnabled && n === 5) return; let r = !1; switch (n) { case 0: { this.appRef.dirtyFlags |= 2; break } case 3: case 2: case 4: case 5: case 1: { this.appRef.dirtyFlags |= 4; break } case 6: { this.appRef.dirtyFlags |= 2, r = !0; break } case 12: { this.appRef.dirtyFlags |= 16, r = !0; break } case 13: { this.appRef.dirtyFlags |= 2, r = !0; break } case 11: { r = !0; break } case 9: case 8: case 7: case 10: default: this.appRef.dirtyFlags |= 8 }if (this.appRef.tracingSnapshot = this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null, !this.shouldScheduleTick(r)) return; let o = this.useMicrotaskScheduler ? Gd : Nh; this.pendingRenderTaskId = this.taskService.add(), this.scheduleInRootZone ? this.cancelScheduledCallback = Zone.root.run(() => o(() => this.tick())) : this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => o(() => this.tick())) } shouldScheduleTick(n) { return !(this.disableScheduling && !n || this.appRef.destroyed || this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick || !this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(xi + this.angularZoneId)) } tick() { if (this.runningTick || this.appRef.destroyed) return; if (this.appRef.dirtyFlags === 0) { this.cleanup(); return } !this.zonelessEnabled && this.appRef.dirtyFlags & 7 && (this.appRef.dirtyFlags |= 1); let n = this.taskService.add(); try { this.ngZone.run(() => { this.runningTick = !0, this.appRef._tick() }, void 0, this.schedulerTickApplyArgs) } catch (r) { throw this.taskService.remove(n), r } finally { this.cleanup() } this.useMicrotaskScheduler = !0, Gd(() => { this.useMicrotaskScheduler = !1, this.taskService.remove(n) }) } ngOnDestroy() { this.subscriptions.unsubscribe(), this.cleanup() } cleanup() { if (this.runningTick = !1, this.cancelScheduledCallback?.(), this.cancelScheduledCallback = null, this.pendingRenderTaskId !== null) { let n = this.pendingRenderTaskId; this.pendingRenderTaskId = null, this.taskService.remove(n) } } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function Vw() { return typeof $localize < "u" && $localize.locale || Li } var Zc = new D("", { providedIn: "root", factory: () => g(Zc, R.Optional | R.SkipSelf) || Vw() }); var Yl = new D(""), jw = new D(""); function vr(e) { return !e.moduleRef } function Bw(e) { let t = vr(e) ? e.r3Injector : e.moduleRef.injector, n = t.get(oe); return n.run(() => { vr(e) ? e.r3Injector.resolveInjectorInitializers() : e.moduleRef.resolveInjectorInitializers(); let r = t.get(ht, null), o; if (n.runOutsideAngular(() => { o = n.onError.subscribe({ next: i => { r.handleError(i) } }) }), vr(e)) { let i = () => t.destroy(), s = e.platformInjector.get(Yl); s.add(i), t.onDestroy(() => { o.unsubscribe(), s.delete(i) }) } else { let i = () => e.moduleRef.destroy(), s = e.platformInjector.get(Yl); s.add(i), e.moduleRef.onDestroy(() => { ui(e.allPlatformModules, e.moduleRef), o.unsubscribe(), s.delete(i) }) } return $w(r, n, () => { let i = t.get(Pp); return i.runInitializers(), i.donePromise.then(() => { let s = t.get(Zc, Li); if (_w(s || Li), !t.get(jw, !0)) return vr(e) ? t.get(en) : (e.allPlatformModules.push(e.moduleRef), e.moduleRef); if (vr(e)) { let l = t.get(en); return e.rootComponent !== void 0 && l.bootstrap(e.rootComponent), l } else return Uw(e.moduleRef, e.allPlatformModules), e.moduleRef }) }) }) } function Uw(e, t) { let n = e.injector.get(en); if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(r => n.bootstrap(r)); else if (e.instance.ngDoBootstrap) e.instance.ngDoBootstrap(n); else throw new v(-403, !1); t.push(e) } function $w(e, t, n) { try { let r = n(); return Ot(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } } var di = null; function Hw(e = [], t) { return ft.create({ name: t, providers: [{ provide: Ui, useValue: "platform" }, { provide: Yl, useValue: new Set([() => di = null]) }, ...e] }) } function zw(e = []) { if (di) return di; let t = Hw(e); return di = t, tw(), Gw(t), t } function Gw(e) { let t = e.get(Ec, null); Me(e, () => { t?.forEach(n => n()) }) } var rn = (() => { class e { static __NG_ELEMENT_ID__ = qw } return e })(); function qw(e) { return Ww(Se(), $(), (e & 16) === 16) } function Ww(e, t, n) { if (Vn(e) && !n) { let r = Ye(e.index, t); return new Mr(r, r) } else if (e.type & 175) { let r = t[qe]; return new Mr(r, t) } return null } var Ql = class { constructor() { } supports(t) { return Np(t) } create(t) { return new Kl(t) } }, Zw = (e, t) => t, Kl = class { length = 0; collection; _linkedRecords = null; _unlinkedRecords = null; _previousItHead = null; _itHead = null; _itTail = null; _additionsHead = null; _additionsTail = null; _movesHead = null; _movesTail = null; _removalsHead = null; _removalsTail = null; _identityChangesHead = null; _identityChangesTail = null; _trackByFn; constructor(t) { this._trackByFn = t || Zw } forEachItem(t) { let n; for (n = this._itHead; n !== null; n = n._next)t(n) } forEachOperation(t) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { let s = !r || n && n.currentIndex < mf(r, o, i) ? n : r, a = mf(s, o, i), l = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, s.previousIndex == null) o++; else { i || (i = []); let c = a - o, u = l - o; if (c != u) { for (let h = 0; h < c; h++) { let d = h < i.length ? i[h] : i[h] = 0, p = d + h; u <= p && p < c && (i[h] = d + 1) } let f = s.previousIndex; i[f] = u - c } } a !== l && t(s, a, l) } } forEachPreviousItem(t) { let n; for (n = this._previousItHead; n !== null; n = n._nextPrevious)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; n !== null; n = n._nextAdded)t(n) } forEachMovedItem(t) { let n; for (n = this._movesHead; n !== null; n = n._nextMoved)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; n !== null; n = n._nextRemoved)t(n) } forEachIdentityChange(t) { let n; for (n = this._identityChangesHead; n !== null; n = n._nextIdentityChange)t(n) } diff(t) { if (t == null && (t = []), !Np(t)) throw new v(900, !1); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let n = this._itHead, r = !1, o, i, s; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)i = t[a], s = this._trackByFn(a, i), n === null || !Object.is(n.trackById, s) ? (n = this._mismatch(n, i, s, a), r = !0) : (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)), n = n._next } else o = 0, WE(t, a => { s = this._trackByFn(o, a), n === null || !Object.is(n.trackById, s) ? (n = this._mismatch(n, a, s, o), r = !0) : (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = t, this.isDirty } get isDirty() { return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; t !== null; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; t !== null; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; t !== null; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, n, r, o) { let i; return t === null ? i = this._itTail : (i = t._prev, this._remove(t)), t = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(r, null), t !== null ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, i, o)) : (t = this._linkedRecords === null ? null : this._linkedRecords.get(r, o), t !== null ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, i, o)) : t = this._addAfter(new Jl(n, r), i, o)), t } _verifyReinsertion(t, n, r, o) { let i = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(r, null); return i !== null ? t = this._reinsertAfter(i, t._prev, o) : t.currentIndex != o && (t.currentIndex = o, this._addToMoves(t, o)), t } _truncate(t) { for (; t !== null;) { let n = t._next; this._addToRemovals(this._unlink(t)), t = n } this._unlinkedRecords !== null && this._unlinkedRecords.clear(), this._additionsTail !== null && (this._additionsTail._nextAdded = null), this._movesTail !== null && (this._movesTail._nextMoved = null), this._itTail !== null && (this._itTail._next = null), this._removalsTail !== null && (this._removalsTail._nextRemoved = null), this._identityChangesTail !== null && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, n, r) { this._unlinkedRecords !== null && this._unlinkedRecords.remove(t); let o = t._prevRemoved, i = t._nextRemoved; return o === null ? this._removalsHead = i : o._nextRemoved = i, i === null ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(t, n, r), this._addToMoves(t, r), t } _moveAfter(t, n, r) { return this._unlink(t), this._insertAfter(t, n, r), this._addToMoves(t, r), t } _addAfter(t, n, r) { return this._insertAfter(t, n, r), this._additionsTail === null ? this._additionsTail = this._additionsHead = t : this._additionsTail = this._additionsTail._nextAdded = t, t } _insertAfter(t, n, r) { let o = n === null ? this._itHead : n._next; return t._next = o, t._prev = n, o === null ? this._itTail = t : o._prev = t, n === null ? this._itHead = t : n._next = t, this._linkedRecords === null && (this._linkedRecords = new Vi), this._linkedRecords.put(t), t.currentIndex = r, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { this._linkedRecords !== null && this._linkedRecords.remove(t); let n = t._prev, r = t._next; return n === null ? this._itHead = r : n._next = r, r === null ? this._itTail = n : r._prev = n, t } _addToMoves(t, n) { return t.previousIndex === n || (this._movesTail === null ? this._movesTail = this._movesHead = t : this._movesTail = this._movesTail._nextMoved = t), t } _addToRemovals(t) { return this._unlinkedRecords === null && (this._unlinkedRecords = new Vi), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, this._removalsTail === null ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, n) { return t.item = n, this._identityChangesTail === null ? this._identityChangesTail = this._identityChangesHead = t : this._identityChangesTail = this._identityChangesTail._nextIdentityChange = t, t } }, Jl = class { item; trackById; currentIndex = null; previousIndex = null; _nextPrevious = null; _prev = null; _next = null; _prevDup = null; _nextDup = null; _prevRemoved = null; _nextRemoved = null; _nextAdded = null; _nextMoved = null; _nextIdentityChange = null; constructor(t, n) { this.item = t, this.trackById = n } }, Xl = class { _head = null; _tail = null; add(t) { this._head === null ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, n) { let r; for (r = this._head; r !== null; r = r._nextDup)if ((n === null || n <= r.currentIndex) && Object.is(r.trackById, t)) return r; return null } remove(t) { let n = t._prevDup, r = t._nextDup; return n === null ? this._head = r : n._nextDup = r, r === null ? this._tail = n : r._prevDup = n, this._head === null } }, Vi = class { map = new Map; put(t) { let n = t.trackById, r = this.map.get(n); r || (r = new Xl, this.map.set(n, r)), r.add(t) } get(t, n) { let r = t, o = this.map.get(r); return o ? o.get(t, n) : null } remove(t) { let n = t.trackById; return this.map.get(n).remove(t) && this.map.delete(n), t } get isEmpty() { return this.map.size === 0 } clear() { this.map.clear() } }; function mf(e, t, n) { let r = e.previousIndex; if (r === null) return r; let o = 0; return n && r < n.length && (o = n[r]), r + t + o } function vf() { return new Yc([new Ql]) } var Yc = (() => { class e { factories; static \u0275prov = _({ token: e, providedIn: "root", factory: vf }); constructor(n) { this.factories = n } static create(n, r) { if (r != null) { let o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || vf()), deps: [[e, new iy, new oy]] } } find(n) { let r = this.factories.find(o => o.supports(n)); if (r != null) return r; throw new v(901, !1) } } return e })(); function Qp(e) { let { rootComponent: t, appProviders: n, platformProviders: r, platformRef: o } = e; z(8); try { let i = o?.injector ?? zw(r), s = [Wp({}), { provide: Ir, useExisting: Lw }, ...n || []], a = new Fi({ providers: s, parent: i, debugName: "", runEnvironmentInitializers: !1 }); return Bw({ r3Injector: a.injector, platformInjector: i, rootComponent: t }) } catch (i) { return Promise.reject(i) } finally { z(9) } } function Un(e) { return typeof e == "boolean" ? e : e != null && e !== "false" } function He(e) { return ka(e) } function Vr(e, t) { return Ra(e, t?.equal) } var yf = class { [Re]; constructor(t) { this[Re] = t } destroy() { this[Re].destroy() } }; var ae = new D(""); var Xp = null; function Ve() { return Xp } function Qc(e) { Xp ??= e } var jr = class { }, Kc = (() => { class e { historyGo(n) { throw new Error("") } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: () => g(eg), providedIn: "platform" }) } return e })(); var eg = (() => { class e extends Kc { _location; _history; _doc = g(ae); constructor() { super(), this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Ve().getBaseHref(this._doc) } onPopState(n) { let r = Ve().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { let r = Ve().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(n) { this._location.pathname = n } pushState(n, r, o) { this._history.pushState(n, r, o) } replaceState(n, r, o) { this._history.replaceState(n, r, o) } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: () => new e, providedIn: "platform" }) } return e })(); function tg(e, t) { return e ? t ? e.endsWith("/") ? t.startsWith("/") ? e + t.slice(1) : e + t : t.startsWith("/") ? e + t : `${e}/${t}` : e : t } function Kp(e) { let t = e.search(/#|\?|$/); return e[t - 1] === "/" ? e.slice(0, t - 1) + e.slice(t) : e } function Ft(e) { return e && e[0] !== "?" ? `?${e}` : e } var $n = (() => { class e { historyGo(n) { throw new Error("") } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: () => g(rg), providedIn: "root" }) } return e })(), ng = new D(""), rg = (() => { class e extends $n { _platformLocation; _baseHref; _removeListenerFns = []; constructor(n, r) { super(), this._platformLocation = n, this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? g(ae).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return tg(this._baseHref, n) } path(n = !1) { let r = this._platformLocation.pathname + Ft(this._platformLocation.search), o = this._platformLocation.hash; return o && n ? `${r}${o}` : r } pushState(n, r, o, i) { let s = this.prepareExternalUrl(o + Ft(i)); this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { let s = this.prepareExternalUrl(o + Ft(i)); this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } static \u0275fac = function (r) { return new (r || e)(M(Kc), M(ng, 8)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), Hn = (() => { class e { _subject = new K; _basePath; _locationStrategy; _urlChangeListeners = []; _urlChangeSubscription = null; constructor(n) { this._locationStrategy = n; let r = this._locationStrategy.getBaseHref(); this._basePath = Kw(Kp(Jp(r))), this._locationStrategy.onPopState(o => { this._subject.next({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(n = !1) { return this.normalize(this._locationStrategy.path(n)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + Ft(r)) } normalize(n) { return e.stripTrailingSlash(Qw(this._basePath, Jp(n))) } prepareExternalUrl(n) { return n && n[0] !== "/" && (n = "/" + n), this._locationStrategy.prepareExternalUrl(n) } go(n, r = "", o = null) { this._locationStrategy.pushState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + Ft(r)), o) } replaceState(n, r = "", o = null) { this._locationStrategy.replaceState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + Ft(r)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(n = 0) { this._locationStrategy.historyGo?.(n) } onUrlChange(n) { return this._urlChangeListeners.push(n), this._urlChangeSubscription ??= this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) }), () => { let r = this._urlChangeListeners.indexOf(n); this._urlChangeListeners.splice(r, 1), this._urlChangeListeners.length === 0 && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(o => o(n, r)) } subscribe(n, r, o) { return this._subject.subscribe({ next: n, error: r ?? void 0, complete: o ?? void 0 }) } static normalizeQueryParams = Ft; static joinWithSlash = tg; static stripTrailingSlash = Kp; static \u0275fac = function (r) { return new (r || e)(M($n)) }; static \u0275prov = _({ token: e, factory: () => Yw(), providedIn: "root" }) } return e })(); function Yw() { return new Hn(M($n)) } function Qw(e, t) { if (!e || !t.startsWith(e)) return t; let n = t.substring(e.length); return n === "" || ["/", ";", "?", "#"].includes(n[0]) ? n : t } function Jp(e) { return e.replace(/\/index.html$/, "") } function Kw(e) { if (new RegExp("^(https?:)?//").test(e)) { let [, n] = e.split(/\/\/[^\/]+/); return n } return e } var os = class { $implicit; ngForOf; index; count; constructor(t, n, r, o) { this.$implicit = t, this.ngForOf = n, this.index = r, this.count = o } get first() { return this.index === 0 } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 === 0 } get odd() { return !this.even } }, ss = (() => { class e { _viewContainer; _template; _differs; set ngForOf(n) { this._ngForOf = n, this._ngForOfDirty = !0 } set ngForTrackBy(n) { this._trackByFn = n } get ngForTrackBy() { return this._trackByFn } _ngForOf = null; _ngForOfDirty = !0; _differ = null; _trackByFn; constructor(n, r, o) { this._viewContainer = n, this._template = r, this._differs = o } set ngForTemplate(n) { n && (this._template = n) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; let n = this._ngForOf; !this._differ && n && (this._differ = this._differs.find(n).create(this.ngForTrackBy)) } if (this._differ) { let n = this._differ.diff(this._ngForOf); n && this._applyChanges(n) } } _applyChanges(n) { let r = this._viewContainer; n.forEachOperation((o, i, s) => { if (o.previousIndex == null) r.createEmbeddedView(this._template, new os(o.item, this._ngForOf, -1, -1), s === null ? void 0 : s); else if (s == null) r.remove(i === null ? void 0 : i); else if (i !== null) { let a = r.get(i); r.move(a, s), og(a, o) } }); for (let o = 0, i = r.length; o < i; o++) { let a = r.get(o).context; a.index = o, a.count = i, a.ngForOf = this._ngForOf } n.forEachIdentityChange(o => { let i = r.get(o.currentIndex); og(i, o) }) } static ngTemplateContextGuard(n, r) { return !0 } static \u0275fac = function (r) { return new (r || e)(E(Bn), E(Qi), E(Yc)) }; static \u0275dir = Y({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }) } return e })(); function og(e, t) { e.context.$implicit = t.item } var Br = (() => { class e { _viewContainer; _context = new is; _thenTemplateRef = null; _elseTemplateRef = null; _thenViewRef = null; _elseViewRef = null; constructor(n, r) { this._viewContainer = n, this._thenTemplateRef = r } set ngIf(n) { this._context.$implicit = this._context.ngIf = n, this._updateView() } set ngIfThen(n) { ig(n, !1), this._thenTemplateRef = n, this._thenViewRef = null, this._updateView() } set ngIfElse(n) { ig(n, !1), this._elseTemplateRef = n, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngIfUseIfTypeGuard; static ngTemplateGuard_ngIf; static ngTemplateContextGuard(n, r) { return !0 } static \u0275fac = function (r) { return new (r || e)(E(Bn), E(Qi)) }; static \u0275dir = Y({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }) } return e })(), is = class { $implicit = null; ngIf = null }; function ig(e, t) { if (e && !e.createEmbeddedView) throw new v(2020, !1) } function Jw(e, t) { return new v(2100, !1) } var Jc = class { createSubscription(t, n) { return He(() => t.subscribe({ next: n, error: r => { throw r } })) } dispose(t) { He(() => t.unsubscribe()) } }, Xc = class { createSubscription(t, n) { return t.then(r => n?.(r), r => { throw r }), { unsubscribe: () => { n = null } } } dispose(t) { t.unsubscribe() } }, Xw = new Xc, eb = new Jc, Ur = (() => { class e { _ref; _latestValue = null; markForCheckOnValueUpdate = !0; _subscription = null; _obj = null; _strategy = null; constructor(n) { this._ref = n } ngOnDestroy() { this._subscription && this._dispose(), this._ref = null } transform(n) { if (!this._obj) { if (n) try { this.markForCheckOnValueUpdate = !1, this._subscribe(n) } finally { this.markForCheckOnValueUpdate = !0 } return this._latestValue } return n !== this._obj ? (this._dispose(), this.transform(n)) : this._latestValue } _subscribe(n) { this._obj = n, this._strategy = this._selectStrategy(n), this._subscription = this._strategy.createSubscription(n, r => this._updateLatestValue(n, r)) } _selectStrategy(n) { if (Ot(n)) return Xw; if (Bc(n)) return eb; throw Jw(e, n) } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null } _updateLatestValue(n, r) { n === this._obj && (this._latestValue = r, this.markForCheckOnValueUpdate && this._ref?.markForCheck()) } static \u0275fac = function (r) { return new (r || e)(E(rn, 16)) }; static \u0275pipe = Xi({ name: "async", type: e, pure: !1 }) } return e })(); var as = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275mod = et({ type: e }); static \u0275inj = Je({}) } return e })(); function $r(e, t) { t = encodeURIComponent(t); for (let n of e.split(";")) { let r = n.indexOf("="), [o, i] = r == -1 ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null } var eu = "browser", sg = "server"; function ls(e) { return e === sg } var on = class { }; var ds = new D(""), ou = (() => { class e { _zone; _plugins; _eventNameToPlugin = new Map; constructor(n, r) { this._zone = r, n.forEach(o => { o.manager = this }), this._plugins = n.slice().reverse() } addEventListener(n, r, o, i) { return this._findPluginFor(r).addEventListener(n, r, o, i) } getZone() { return this._zone } _findPluginFor(n) { let r = this._eventNameToPlugin.get(n); if (r) return r; if (r = this._plugins.find(i => i.supports(n)), !r) throw new v(5101, !1); return this._eventNameToPlugin.set(n, r), r } static \u0275fac = function (r) { return new (r || e)(M(ds), M(oe)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac }) } return e })(), Hr = class { _doc; constructor(t) { this._doc = t } manager }, cs = "ng-app-id"; function lg(e) { for (let t of e) t.remove() } function cg(e, t) { let n = t.createElement("style"); return n.textContent = e, n } function tb(e, t, n, r) { let o = e.head?.querySelectorAll(`style[${cs}="${t}"],link[${cs}="${t}"]`); if (o) for (let i of o) i.removeAttribute(cs), i instanceof HTMLLinkElement ? r.set(i.href.slice(i.href.lastIndexOf("/") + 1), { usage: 0, elements: [i] }) : i.textContent && n.set(i.textContent, { usage: 0, elements: [i] }) } function nu(e, t) { let n = t.createElement("link"); return n.setAttribute("rel", "stylesheet"), n.setAttribute("href", e), n } var iu = (() => { class e { doc; appId; nonce; inline = new Map; external = new Map; hosts = new Set; isServer; constructor(n, r, o, i = {}) { this.doc = n, this.appId = r, this.nonce = o, this.isServer = ls(i), tb(n, r, this.inline, this.external), this.hosts.add(n.head) } addStyles(n, r) { for (let o of n) this.addUsage(o, this.inline, cg); r?.forEach(o => this.addUsage(o, this.external, nu)) } removeStyles(n, r) { for (let o of n) this.removeUsage(o, this.inline); r?.forEach(o => this.removeUsage(o, this.external)) } addUsage(n, r, o) { let i = r.get(n); i ? i.usage++ : r.set(n, { usage: 1, elements: [...this.hosts].map(s => this.addElement(s, o(n, this.doc))) }) } removeUsage(n, r) { let o = r.get(n); o && (o.usage--, o.usage <= 0 && (lg(o.elements), r.delete(n))) } ngOnDestroy() { for (let [, { elements: n }] of [...this.inline, ...this.external]) lg(n); this.hosts.clear() } addHost(n) { this.hosts.add(n); for (let [r, { elements: o }] of this.inline) o.push(this.addElement(n, cg(r, this.doc))); for (let [r, { elements: o }] of this.external) o.push(this.addElement(n, nu(r, this.doc))) } removeHost(n) { this.hosts.delete(n) } addElement(n, r) { return this.nonce && r.setAttribute("nonce", this.nonce), this.isServer && r.setAttribute(cs, this.appId), n.appendChild(r) } static \u0275fac = function (r) { return new (r || e)(M(ae), M(Cc), M(wc, 8), M(kr)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac }) } return e })(), tu = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/Math/MathML" }, su = /%COMP%/g; var dg = "%COMP%", nb = `_nghost-${dg}`, rb = `_ngcontent-${dg}`, ob = !0, ib = new D("", { providedIn: "root", factory: () => ob }); function sb(e) { return rb.replace(su, e) } function ab(e) { return nb.replace(su, e) } function fg(e, t) { return t.map(n => n.replace(su, e)) } var au = (() => { class e { eventManager; sharedStylesHost; appId; removeStylesOnCompDestroy; doc; platformId; ngZone; nonce; tracingService; rendererByCompId = new Map; defaultRenderer; platformIsServer; constructor(n, r, o, i, s, a, l, c = null, u = null) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.removeStylesOnCompDestroy = i, this.doc = s, this.platformId = a, this.ngZone = l, this.nonce = c, this.tracingService = u, this.platformIsServer = ls(a), this.defaultRenderer = new zr(n, s, l, this.platformIsServer, this.tracingService) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; this.platformIsServer && r.encapsulation === Qe.ShadowDom && (r = P(m({}, r), { encapsulation: Qe.Emulated })); let o = this.getOrCreateRenderer(n, r); return o instanceof us ? o.applyToHost(n) : o instanceof Gr && o.applyStyles(), o } getOrCreateRenderer(n, r) { let o = this.rendererByCompId, i = o.get(r.id); if (!i) { let s = this.doc, a = this.ngZone, l = this.eventManager, c = this.sharedStylesHost, u = this.removeStylesOnCompDestroy, f = this.platformIsServer, h = this.tracingService; switch (r.encapsulation) { case Qe.Emulated: i = new us(l, c, r, this.appId, u, s, a, f, h); break; case Qe.ShadowDom: return new ru(l, c, n, r, s, a, this.nonce, f, h); default: i = new Gr(l, c, r, u, s, a, f, h); break }o.set(r.id, i) } return i } ngOnDestroy() { this.rendererByCompId.clear() } componentReplaced(n) { this.rendererByCompId.delete(n) } static \u0275fac = function (r) { return new (r || e)(M(ou), M(iu), M(Cc), M(ib), M(ae), M(kr), M(oe), M(wc), M(Wi, 8)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac }) } return e })(), zr = class { eventManager; doc; ngZone; platformIsServer; tracingService; data = Object.create(null); throwOnSyntheticProps = !0; constructor(t, n, r, o, i) { this.eventManager = t, this.doc = n, this.ngZone = r, this.platformIsServer = o, this.tracingService = i } destroy() { } destroyNode = null; createElement(t, n) { return n ? this.doc.createElementNS(tu[n] || n, t) : this.doc.createElement(t) } createComment(t) { return this.doc.createComment(t) } createText(t) { return this.doc.createTextNode(t) } appendChild(t, n) { (ug(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (ug(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { n.remove() } selectRootElement(t, n) { let r = typeof t == "string" ? this.doc.querySelector(t) : t; if (!r) throw new v(-5104, !1); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; let i = tu[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { let o = tu[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (pt.DashCase | pt.Important) ? t.style.setProperty(n, r, o & pt.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & pt.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t != null && (t[n] = r) } setValue(t, n) { t.nodeValue = n } listen(t, n, r, o) { if (typeof t == "string" && (t = Ve().getGlobalEventTarget(this.doc, t), !t)) throw new v(5102, !1); let i = this.decoratePreventDefault(r); return this.tracingService?.wrapEventListener && (i = this.tracingService.wrapEventListener(t, n, i)), this.eventManager.addEventListener(t, n, i, o) } decoratePreventDefault(t) { return n => { if (n === "__ngUnwrap__") return t; (this.platformIsServer ? this.ngZone.runGuarded(() => t(n)) : t(n)) === !1 && n.preventDefault() } } }; function ug(e) { return e.tagName === "TEMPLATE" && e.content !== void 0 } var ru = class extends zr { sharedStylesHost; hostEl; shadowRoot; constructor(t, n, r, o, i, s, a, l, c) { super(t, i, s, l, c), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); let u = o.styles; u = fg(o.id, u); for (let h of u) { let d = document.createElement("style"); a && d.setAttribute("nonce", a), d.textContent = h, this.shadowRoot.appendChild(d) } let f = o.getExternalStyles?.(); if (f) for (let h of f) { let d = nu(h, i); a && d.setAttribute("nonce", a), this.shadowRoot.appendChild(d) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(null, n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } }, Gr = class extends zr { sharedStylesHost; removeStylesOnCompDestroy; styles; styleUrls; constructor(t, n, r, o, i, s, a, l, c) { super(t, i, s, a, l), this.sharedStylesHost = n, this.removeStylesOnCompDestroy = o; let u = r.styles; this.styles = c ? fg(c, u) : u, this.styleUrls = r.getExternalStyles?.(c) } applyStyles() { this.sharedStylesHost.addStyles(this.styles, this.styleUrls) } destroy() { this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles, this.styleUrls) } }, us = class extends Gr { contentAttr; hostAttr; constructor(t, n, r, o, i, s, a, l, c) { let u = o + "-" + r.id; super(t, n, r, i, s, a, l, c, u), this.contentAttr = sb(u), this.hostAttr = ab(u) } applyToHost(t) { this.applyStyles(), this.setAttribute(t, this.hostAttr, "") } createElement(t, n) { let r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } }; var fs = class e extends jr { supportsDOMEvents = !0; static makeCurrent() { Qc(new e) } onAndCancel(t, n, r, o) { return t.addEventListener(n, r, o), () => { t.removeEventListener(n, r, o) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.remove() } createElement(t, n) { return n = n || this.getDefaultDocument(), n.createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return n === "window" ? window : n === "document" ? t : n === "body" ? t.body : null } getBaseHref(t) { let n = lb(); return n == null ? null : cb(n) } resetBaseElement() { qr = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return $r(document.cookie, t) } }, qr = null; function lb() { return qr = qr || document.head.querySelector("base"), qr ? qr.getAttribute("href") : null } function cb(e) { return new URL(e, document.baseURI).pathname } var ub = (() => { class e { build() { return new XMLHttpRequest } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac }) } return e })(), pg = (() => { class e extends Hr { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o, i) { return n.addEventListener(r, o, i), () => this.removeEventListener(n, r, o, i) } removeEventListener(n, r, o, i) { return n.removeEventListener(r, o, i) } static \u0275fac = function (r) { return new (r || e)(M(ae)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac }) } return e })(), hg = ["alt", "control", "meta", "shift"], db = { "\b": "Backspace", "	": "Tab", "\x7F": "Delete", "\x1B": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, fb = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }, gg = (() => { class e extends Hr { constructor(n) { super(n) } supports(n) { return e.parseEventName(n) != null } addEventListener(n, r, o, i) { let s = e.parseEventName(r), a = e.eventCallback(s.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Ve().onAndCancel(n, s.domEventName, a, i)) } static parseEventName(n) { let r = n.toLowerCase().split("."), o = r.shift(); if (r.length === 0 || !(o === "keydown" || o === "keyup")) return null; let i = e._normalizeKey(r.pop()), s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), hg.forEach(c => { let u = r.indexOf(c); u > -1 && (r.splice(u, 1), s += c + ".") }), s += i, r.length != 0 || i.length === 0) return null; let l = {}; return l.domEventName = o, l.fullKey = s, l } static matchEventFullKeyCode(n, r) { let o = db[n.key] || n.key, i = ""; return r.indexOf("code.") > -1 && (o = n.code, i = "code."), o == null || !o ? !1 : (o = o.toLowerCase(), o === " " ? o = "space" : o === "." && (o = "dot"), hg.forEach(s => { if (s !== o) { let a = fb[s]; a(n) && (i += s + ".") } }), i += o, i === r) } static eventCallback(n, r, o) { return i => { e.matchEventFullKeyCode(i, n) && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return n === "esc" ? "escape" : n } static \u0275fac = function (r) { return new (r || e)(M(ae)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac }) } return e })(); function lu(e, t, n) { return Qp(m({ rootComponent: e, platformRef: n?.platformRef }, hb(t))) } function hb(e) { return { appProviders: [...yb, ...e?.providers ?? []], platformProviders: vb } } function pb() { fs.makeCurrent() } function gb() { return new ht } function mb() { return jh(document), document } var vb = [{ provide: kr, useValue: eu }, { provide: Ec, useValue: pb, multi: !0 }, { provide: ae, useFactory: mb }]; var yb = [{ provide: Ui, useValue: "root" }, { provide: ht, useFactory: gb }, { provide: ds, useClass: pg, multi: !0, deps: [ae] }, { provide: ds, useClass: gg, multi: !0, deps: [ae] }, au, iu, ou, { provide: Pn, useExisting: au }, { provide: on, useClass: ub }, []]; var Gn = class { }, Wr = class { }, kt = class e {
  headers; normalizedNames = new Map; lazyInit; lazyUpdate = null; constructor(t) {
    t ? typeof t == "string" ? this.lazyInit = () => {
      this.headers = new Map, t.split(`
`).forEach(n => { let r = n.indexOf(":"); if (r > 0) { let o = n.slice(0, r), i = n.slice(r + 1).trim(); this.addHeaderEntry(o, i) } })
    } : typeof Headers < "u" && t instanceof Headers ? (this.headers = new Map, t.forEach((n, r) => { this.addHeaderEntry(r, n) })) : this.lazyInit = () => { this.headers = new Map, Object.entries(t).forEach(([n, r]) => { this.setHeaderEntries(n, r) }) } : this.headers = new Map
  } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); let n = this.headers.get(t.toLowerCase()); return n && n.length > 0 ? n[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, n) { return this.clone({ name: t, value: n, op: "a" }) } set(t, n) { return this.clone({ name: t, value: n, op: "s" }) } delete(t, n) { return this.clone({ name: t, value: n, op: "d" }) } maybeSetNormalizedName(t, n) { this.normalizedNames.has(n) || this.normalizedNames.set(n, t) } init() { this.lazyInit && (this.lazyInit instanceof e ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(n => { this.headers.set(n, t.headers.get(n)), this.normalizedNames.set(n, t.normalizedNames.get(n)) }) } clone(t) { let n = new e; return n.lazyInit = this.lazyInit && this.lazyInit instanceof e ? this.lazyInit : this, n.lazyUpdate = (this.lazyUpdate || []).concat([t]), n } applyUpdate(t) { let n = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let r = t.value; if (typeof r == "string" && (r = [r]), r.length === 0) return; this.maybeSetNormalizedName(t.name, n); let o = (t.op === "a" ? this.headers.get(n) : void 0) || []; o.push(...r), this.headers.set(n, o); break; case "d": let i = t.value; if (!i) this.headers.delete(n), this.normalizedNames.delete(n); else { let s = this.headers.get(n); if (!s) return; s = s.filter(a => i.indexOf(a) === -1), s.length === 0 ? (this.headers.delete(n), this.normalizedNames.delete(n)) : this.headers.set(n, s) } break } } addHeaderEntry(t, n) { let r = t.toLowerCase(); this.maybeSetNormalizedName(t, r), this.headers.has(r) ? this.headers.get(r).push(n) : this.headers.set(r, [n]) } setHeaderEntries(t, n) { let r = (Array.isArray(n) ? n : [n]).map(i => i.toString()), o = t.toLowerCase(); this.headers.set(o, r), this.maybeSetNormalizedName(t, o) } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(n => t(this.normalizedNames.get(n), this.headers.get(n))) }
}; var ps = class { encodeKey(t) { return mg(t) } encodeValue(t) { return mg(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } }; function Db(e, t) { let n = new Map; return e.length > 0 && e.replace(/^\?/, "").split("&").forEach(o => { let i = o.indexOf("="), [s, a] = i == -1 ? [t.decodeKey(o), ""] : [t.decodeKey(o.slice(0, i)), t.decodeValue(o.slice(i + 1))], l = n.get(s) || []; l.push(a), n.set(s, l) }), n } var Cb = /%(\d[a-f0-9])/gi, Eb = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function mg(e) { return encodeURIComponent(e).replace(Cb, (t, n) => Eb[n] ?? t) } function hs(e) { return `${e}` } var Ct = class e { map; encoder; updates = null; cloneFrom = null; constructor(t = {}) { if (this.encoder = t.encoder || new ps, t.fromString) { if (t.fromObject) throw new v(2805, !1); this.map = Db(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(n => { let r = t.fromObject[n], o = Array.isArray(r) ? r.map(hs) : [hs(r)]; this.map.set(n, o) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); let n = this.map.get(t); return n ? n[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, n) { return this.clone({ param: t, value: n, op: "a" }) } appendAll(t) { let n = []; return Object.keys(t).forEach(r => { let o = t[r]; Array.isArray(o) ? o.forEach(i => { n.push({ param: r, value: i, op: "a" }) }) : n.push({ param: r, value: o, op: "a" }) }), this.clone(n) } set(t, n) { return this.clone({ param: t, value: n, op: "s" }) } delete(t, n) { return this.clone({ param: t, value: n, op: "d" }) } toString() { return this.init(), this.keys().map(t => { let n = this.encoder.encodeKey(t); return this.map.get(t).map(r => n + "=" + this.encoder.encodeValue(r)).join("&") }).filter(t => t !== "").join("&") } clone(t) { let n = new e({ encoder: this.encoder }); return n.cloneFrom = this.cloneFrom || this, n.updates = (this.updates || []).concat(t), n } init() { this.map === null && (this.map = new Map), this.cloneFrom !== null && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": let n = (t.op === "a" ? this.map.get(t.param) : void 0) || []; n.push(hs(t.value)), this.map.set(t.param, n); break; case "d": if (t.value !== void 0) { let r = this.map.get(t.param) || [], o = r.indexOf(hs(t.value)); o !== -1 && r.splice(o, 1), r.length > 0 ? this.map.set(t.param, r) : this.map.delete(t.param) } else { this.map.delete(t.param); break } } }), this.cloneFrom = this.updates = null) } }; var gs = class { map = new Map; set(t, n) { return this.map.set(t, n), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } has(t) { return this.map.has(t) } keys() { return this.map.keys() } }; function wb(e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } } function vg(e) { return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer } function yg(e) { return typeof Blob < "u" && e instanceof Blob } function Dg(e) { return typeof FormData < "u" && e instanceof FormData } function bb(e) { return typeof URLSearchParams < "u" && e instanceof URLSearchParams } var Cg = "Content-Type", Eg = "Accept", wg = "X-Request-URL", bg = "text/plain", _g = "application/json", _b = `${_g}, ${bg}, */*`, zn = class e { url; body = null; headers; context; reportProgress = !1; withCredentials = !1; responseType = "json"; method; params; urlWithParams; transferCache; constructor(t, n, r, o) { this.url = n, this.method = t.toUpperCase(); let i; if (wb(this.method) || o ? (this.body = r !== void 0 ? r : null, i = o) : i = r, i && (this.reportProgress = !!i.reportProgress, this.withCredentials = !!i.withCredentials, i.responseType && (this.responseType = i.responseType), i.headers && (this.headers = i.headers), i.context && (this.context = i.context), i.params && (this.params = i.params), this.transferCache = i.transferCache), this.headers ??= new kt, this.context ??= new gs, !this.params) this.params = new Ct, this.urlWithParams = n; else { let s = this.params.toString(); if (s.length === 0) this.urlWithParams = n; else { let a = n.indexOf("?"), l = a === -1 ? "?" : a < n.length - 1 ? "&" : ""; this.urlWithParams = n + l + s } } } serializeBody() { return this.body === null ? null : typeof this.body == "string" || vg(this.body) || yg(this.body) || Dg(this.body) || bb(this.body) ? this.body : this.body instanceof Ct ? this.body.toString() : typeof this.body == "object" || typeof this.body == "boolean" || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return this.body === null || Dg(this.body) ? null : yg(this.body) ? this.body.type || null : vg(this.body) ? null : typeof this.body == "string" ? bg : this.body instanceof Ct ? "application/x-www-form-urlencoded;charset=UTF-8" : typeof this.body == "object" || typeof this.body == "number" || typeof this.body == "boolean" ? _g : null } clone(t = {}) { let n = t.method || this.method, r = t.url || this.url, o = t.responseType || this.responseType, i = t.transferCache ?? this.transferCache, s = t.body !== void 0 ? t.body : this.body, a = t.withCredentials ?? this.withCredentials, l = t.reportProgress ?? this.reportProgress, c = t.headers || this.headers, u = t.params || this.params, f = t.context ?? this.context; return t.setHeaders !== void 0 && (c = Object.keys(t.setHeaders).reduce((h, d) => h.set(d, t.setHeaders[d]), c)), t.setParams && (u = Object.keys(t.setParams).reduce((h, d) => h.set(d, t.setParams[d]), u)), new e(n, r, s, { params: u, headers: c, context: f, reportProgress: l, responseType: o, withCredentials: a, transferCache: i }) } }, sn = function (e) { return e[e.Sent = 0] = "Sent", e[e.UploadProgress = 1] = "UploadProgress", e[e.ResponseHeader = 2] = "ResponseHeader", e[e.DownloadProgress = 3] = "DownloadProgress", e[e.Response = 4] = "Response", e[e.User = 5] = "User", e }(sn || {}), qn = class { headers; status; statusText; url; ok; type; constructor(t, n = 200, r = "OK") { this.headers = t.headers || new kt, this.status = t.status !== void 0 ? t.status : n, this.statusText = t.statusText || r, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } }, ms = class e extends qn { constructor(t = {}) { super(t) } type = sn.ResponseHeader; clone(t = {}) { return new e({ headers: t.headers || this.headers, status: t.status !== void 0 ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } }, Zr = class e extends qn { body; constructor(t = {}) { super(t), this.body = t.body !== void 0 ? t.body : null } type = sn.Response; clone(t = {}) { return new e({ body: t.body !== void 0 ? t.body : this.body, headers: t.headers || this.headers, status: t.status !== void 0 ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } }, Yr = class extends qn { name = "HttpErrorResponse"; message; error; ok = !1; constructor(t) { super(t, 0, "Unknown Error"), this.status >= 200 && this.status < 300 ? this.message = `Http failure during parsing for ${t.url || "(unknown url)"}` : this.message = `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } }, Ib = 200, Mb = 204; function cu(e, t) { return { body: t, headers: e.headers, context: e.context, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials, transferCache: e.transferCache } } var ys = (() => { class e { handler; constructor(n) { this.handler = n } request(n, r, o = {}) { let i; if (n instanceof zn) i = n; else { let l; o.headers instanceof kt ? l = o.headers : l = new kt(o.headers); let c; o.params && (o.params instanceof Ct ? c = o.params : c = new Ct({ fromObject: o.params })), i = new zn(n, r, o.body !== void 0 ? o.body : null, { headers: l, context: o.context, params: c, reportProgress: o.reportProgress, responseType: o.responseType || "json", withCredentials: o.withCredentials, transferCache: o.transferCache }) } let s = S(i).pipe(_t(l => this.handler.handle(l))); if (n instanceof zn || o.observe === "events") return s; let a = s.pipe(_e(l => l instanceof Zr)); switch (o.observe || "body") { case "body": switch (i.responseType) { case "arraybuffer": return a.pipe(T(l => { if (l.body !== null && !(l.body instanceof ArrayBuffer)) throw new v(2806, !1); return l.body })); case "blob": return a.pipe(T(l => { if (l.body !== null && !(l.body instanceof Blob)) throw new v(2807, !1); return l.body })); case "text": return a.pipe(T(l => { if (l.body !== null && typeof l.body != "string") throw new v(2808, !1); return l.body })); case "json": default: return a.pipe(T(l => l.body)) }case "response": return a; default: throw new v(2809, !1) } } delete(n, r = {}) { return this.request("DELETE", n, r) } get(n, r = {}) { return this.request("GET", n, r) } head(n, r = {}) { return this.request("HEAD", n, r) } jsonp(n, r) { return this.request("JSONP", n, { params: new Ct().append(r, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(n, r = {}) { return this.request("OPTIONS", n, r) } patch(n, r, o = {}) { return this.request("PATCH", n, cu(o, r)) } post(n, r, o = {}) { return this.request("POST", n, cu(o, r)) } put(n, r, o = {}) { return this.request("PUT", n, cu(o, r)) } static \u0275fac = function (r) { return new (r || e)(M(Gn)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac }) } return e })(); var Sb = new D(""); function Tb(e, t) { return t(e) } function Nb(e, t, n) { return (r, o) => Me(n, () => t(r, i => e(i, o))) } var Ig = new D(""), Mg = new D(""), Sg = new D("", { providedIn: "root", factory: () => !0 }); var vs = (() => { class e extends Gn { backend; injector; chain = null; pendingTasks = g(xt); contributeToStability = g(Sg); constructor(n, r) { super(), this.backend = n, this.injector = r } handle(n) { if (this.chain === null) { let r = Array.from(new Set([...this.injector.get(Ig), ...this.injector.get(Mg, [])])); this.chain = r.reduceRight((o, i) => Nb(o, i, this.injector), Tb) } if (this.contributeToStability) { let r = this.pendingTasks.add(); return this.chain(n, o => this.backend.handle(o)).pipe(Gt(() => this.pendingTasks.remove(r))) } else return this.chain(n, r => this.backend.handle(r)) } static \u0275fac = function (r) { return new (r || e)(M(Wr), M(fe)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac }) } return e })(); var xb = /^\)\]\}',?\n/, Ab = RegExp(`^${wg}:`, "m"); function Rb(e) { return "responseURL" in e && e.responseURL ? e.responseURL : Ab.test(e.getAllResponseHeaders()) ? e.getResponseHeader(wg) : null } var uu = (() => { class e { xhrFactory; constructor(n) { this.xhrFactory = n } handle(n) { if (n.method === "JSONP") throw new v(-2800, !1); let r = this.xhrFactory; return (r.\u0275loadImpl ? W(r.\u0275loadImpl()) : S(null)).pipe(se(() => new B(i => { let s = r.build(); if (s.open(n.method, n.urlWithParams), n.withCredentials && (s.withCredentials = !0), n.headers.forEach((y, I) => s.setRequestHeader(y, I.join(","))), n.headers.has(Eg) || s.setRequestHeader(Eg, _b), !n.headers.has(Cg)) { let y = n.detectContentTypeHeader(); y !== null && s.setRequestHeader(Cg, y) } if (n.responseType) { let y = n.responseType.toLowerCase(); s.responseType = y !== "json" ? y : "text" } let a = n.serializeBody(), l = null, c = () => { if (l !== null) return l; let y = s.statusText || "OK", I = new kt(s.getAllResponseHeaders()), j = Rb(s) || n.url; return l = new ms({ headers: I, status: s.status, statusText: y, url: j }), l }, u = () => { let { headers: y, status: I, statusText: j, url: Mo } = c(), ee = null; I !== Mb && (ee = typeof s.response > "u" ? s.responseText : s.response), I === 0 && (I = ee ? Ib : 0); let Da = I >= 200 && I < 300; if (n.responseType === "json" && typeof ee == "string") { let tv = ee; ee = ee.replace(xb, ""); try { ee = ee !== "" ? JSON.parse(ee) : null } catch (nv) { ee = tv, Da && (Da = !1, ee = { error: nv, text: ee }) } } Da ? (i.next(new Zr({ body: ee, headers: y, status: I, statusText: j, url: Mo || void 0 })), i.complete()) : i.error(new Yr({ error: ee, headers: y, status: I, statusText: j, url: Mo || void 0 })) }, f = y => { let { url: I } = c(), j = new Yr({ error: y, status: s.status || 0, statusText: s.statusText || "Unknown Error", url: I || void 0 }); i.error(j) }, h = !1, d = y => { h || (i.next(c()), h = !0); let I = { type: sn.DownloadProgress, loaded: y.loaded }; y.lengthComputable && (I.total = y.total), n.responseType === "text" && s.responseText && (I.partialText = s.responseText), i.next(I) }, p = y => { let I = { type: sn.UploadProgress, loaded: y.loaded }; y.lengthComputable && (I.total = y.total), i.next(I) }; return s.addEventListener("load", u), s.addEventListener("error", f), s.addEventListener("timeout", f), s.addEventListener("abort", f), n.reportProgress && (s.addEventListener("progress", d), a !== null && s.upload && s.upload.addEventListener("progress", p)), s.send(a), i.next({ type: sn.Sent }), () => { s.removeEventListener("error", f), s.removeEventListener("abort", f), s.removeEventListener("load", u), s.removeEventListener("timeout", f), n.reportProgress && (s.removeEventListener("progress", d), a !== null && s.upload && s.upload.removeEventListener("progress", p)), s.readyState !== s.DONE && s.abort() } }))) } static \u0275fac = function (r) { return new (r || e)(M(on)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac }) } return e })(), Tg = new D(""), Ob = "XSRF-TOKEN", Pb = new D("", { providedIn: "root", factory: () => Ob }), Fb = "X-XSRF-TOKEN", kb = new D("", { providedIn: "root", factory: () => Fb }), Qr = class { }, Lb = (() => { class e { doc; cookieName; lastCookieString = ""; lastToken = null; parseCount = 0; constructor(n, r) { this.doc = n, this.cookieName = r } getToken() { let n = this.doc.cookie || ""; return n !== this.lastCookieString && (this.parseCount++, this.lastToken = $r(n, this.cookieName), this.lastCookieString = n), this.lastToken } static \u0275fac = function (r) { return new (r || e)(M(ae), M(Pb)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac }) } return e })(); function Vb(e, t) { let n = e.url.toLowerCase(); if (!g(Tg) || e.method === "GET" || e.method === "HEAD" || n.startsWith("http://") || n.startsWith("https://")) return t(e); let r = g(Qr).getToken(), o = g(kb); return r != null && !e.headers.has(o) && (e = e.clone({ headers: e.headers.set(o, r) })), t(e) } function du(...e) { let t = [ys, uu, vs, { provide: Gn, useExisting: vs }, { provide: Wr, useFactory: () => g(Sb, { optional: !0 }) ?? g(uu) }, { provide: Ig, useValue: Vb, multi: !0 }, { provide: Tg, useValue: !0 }, { provide: Qr, useClass: Lb }]; for (let n of e) t.push(...n.\u0275providers); return Ar(t) } var Ng = (() => { class e { _doc; constructor(n) { this._doc = n } getTitle() { return this._doc.title } setTitle(n) { this._doc.title = n || "" } static \u0275fac = function (r) { return new (r || e)(M(ae)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); var A = "primary", uo = Symbol("RouteTitle"), mu = class { params; constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { let n = this.params[t]; return Array.isArray(n) ? n[0] : n } return null } getAll(t) { if (this.has(t)) { let n = this.params[t]; return Array.isArray(n) ? n : [n] } return [] } get keys() { return Object.keys(this.params) } }; function cn(e) { return new mu(e) } function Lg(e, t, n) { let r = n.path.split("/"); if (r.length > e.length || n.pathMatch === "full" && (t.hasChildren() || r.length < e.length)) return null; let o = {}; for (let i = 0; i < r.length; i++) { let s = r[i], a = e[i]; if (s[0] === ":") o[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: o } } function Ub(e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; ++n)if (!nt(e[n], t[n])) return !1; return !0 } function nt(e, t) { let n = e ? vu(e) : void 0, r = t ? vu(t) : void 0; if (!n || !r || n.length != r.length) return !1; let o; for (let i = 0; i < n.length; i++)if (o = n[i], !Vg(e[o], t[o])) return !1; return !0 } function vu(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] } function Vg(e, t) { if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return !1; let n = [...e].sort(), r = [...t].sort(); return n.every((o, i) => r[i] === o) } else return e === t } function jg(e) { return e.length > 0 ? e[e.length - 1] : null } function jt(e) { return Wa(e) ? e : Ot(e) ? W(Promise.resolve(e)) : S(e) } var $b = { exact: Ug, subset: $g }, Bg = { exact: Hb, subset: zb, ignored: () => !0 }; function xg(e, t, n) { return $b[n.paths](e.root, t.root, n.matrixParams) && Bg[n.queryParams](e.queryParams, t.queryParams) && !(n.fragment === "exact" && e.fragment !== t.fragment) } function Hb(e, t) { return nt(e, t) } function Ug(e, t, n) { if (!an(e.segments, t.segments) || !Es(e.segments, t.segments, n) || e.numberOfChildren !== t.numberOfChildren) return !1; for (let r in t.children) if (!e.children[r] || !Ug(e.children[r], t.children[r], n)) return !1; return !0 } function zb(e, t) { return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => Vg(e[n], t[n])) } function $g(e, t, n) { return Hg(e, t, t.segments, n) } function Hg(e, t, n, r) { if (e.segments.length > n.length) { let o = e.segments.slice(0, n.length); return !(!an(o, n) || t.hasChildren() || !Es(o, n, r)) } else if (e.segments.length === n.length) { if (!an(e.segments, n) || !Es(e.segments, n, r)) return !1; for (let o in t.children) if (!e.children[o] || !$g(e.children[o], t.children[o], r)) return !1; return !0 } else { let o = n.slice(0, e.segments.length), i = n.slice(e.segments.length); return !an(e.segments, o) || !Es(e.segments, o, r) || !e.children[A] ? !1 : Hg(e.children[A], t, i, r) } } function Es(e, t, n) { return t.every((r, o) => Bg[n](e[o].parameters, r.parameters)) } var ot = class { root; queryParams; fragment; _queryParamMap; constructor(t = new U([], {}), n = {}, r = null) { this.root = t, this.queryParams = n, this.fragment = r } get queryParamMap() { return this._queryParamMap ??= cn(this.queryParams), this._queryParamMap } toString() { return Wb.serialize(this) } }, U = class { segments; children; parent = null; constructor(t, n) { this.segments = t, this.children = n, Object.values(n).forEach(r => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return ws(this) } }, Lt = class { path; parameters; _parameterMap; constructor(t, n) { this.path = t, this.parameters = n } get parameterMap() { return this._parameterMap ??= cn(this.parameters), this._parameterMap } toString() { return Gg(this) } }; function Gb(e, t) { return an(e, t) && e.every((n, r) => nt(n.parameters, t[r].parameters)) } function an(e, t) { return e.length !== t.length ? !1 : e.every((n, r) => n.path === t[r].path) } function qb(e, t) { let n = []; return Object.entries(e.children).forEach(([r, o]) => { r === A && (n = n.concat(t(o, r))) }), Object.entries(e.children).forEach(([r, o]) => { r !== A && (n = n.concat(t(o, r))) }), n } var fo = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: () => new un, providedIn: "root" }) } return e })(), un = class { parse(t) { let n = new Du(t); return new ot(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment()) } serialize(t) { let n = `/${Kr(t.root, !0)}`, r = Qb(t.queryParams), o = typeof t.fragment == "string" ? `#${Zb(t.fragment)}` : ""; return `${n}${r}${o}` } }, Wb = new un; function ws(e) { return e.segments.map(t => Gg(t)).join("/") } function Kr(e, t) { if (!e.hasChildren()) return ws(e); if (t) { let n = e.children[A] ? Kr(e.children[A], !1) : "", r = []; return Object.entries(e.children).forEach(([o, i]) => { o !== A && r.push(`${o}:${Kr(i, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } else { let n = qb(e, (r, o) => o === A ? [Kr(e.children[A], !1)] : [`${o}:${Kr(r, !1)}`]); return Object.keys(e.children).length === 1 && e.children[A] != null ? `${ws(e)}/${n[0]}` : `${ws(e)}/(${n.join("//")})` } } function zg(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Ds(e) { return zg(e).replace(/%3B/gi, ";") } function Zb(e) { return encodeURI(e) } function yu(e) { return zg(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function bs(e) { return decodeURIComponent(e) } function Ag(e) { return bs(e.replace(/\+/g, "%20")) } function Gg(e) { return `${yu(e.path)}${Yb(e.parameters)}` } function Yb(e) { return Object.entries(e).map(([t, n]) => `;${yu(t)}=${yu(n)}`).join("") } function Qb(e) { let t = Object.entries(e).map(([n, r]) => Array.isArray(r) ? r.map(o => `${Ds(n)}=${Ds(o)}`).join("&") : `${Ds(n)}=${Ds(r)}`).filter(n => n); return t.length ? `?${t.join("&")}` : "" } var Kb = /^[^\/()?;#]+/; function fu(e) { let t = e.match(Kb); return t ? t[0] : "" } var Jb = /^[^\/()?;=#]+/; function Xb(e) { let t = e.match(Jb); return t ? t[0] : "" } var e_ = /^[^=?&#]+/; function t_(e) { let t = e.match(e_); return t ? t[0] : "" } var n_ = /^[^&#]+/; function r_(e) { let t = e.match(n_); return t ? t[0] : "" } var Du = class { url; remaining; constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#") ? new U([], {}) : new U([], this.parseChildren()) } parseQueryParams() { let t = {}; if (this.consumeOptional("?")) do this.parseQueryParam(t); while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if (this.remaining === "") return {}; this.consumeOptional("/"); let t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let n = {}; this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (t.length > 0 || Object.keys(n).length > 0) && (r[A] = new U(t, n)), r } parseSegment() { let t = fu(this.remaining); if (t === "" && this.peekStartsWith(";")) throw new v(4009, !1); return this.capture(t), new Lt(bs(t), this.parseMatrixParams()) } parseMatrixParams() { let t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { let n = Xb(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { let o = fu(this.remaining); o && (r = o, this.capture(r)) } t[bs(n)] = bs(r) } parseQueryParam(t) { let n = t_(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { let s = r_(this.remaining); s && (r = s, this.capture(r)) } let o = Ag(n), i = Ag(r); if (t.hasOwnProperty(o)) { let s = t[o]; Array.isArray(s) || (s = [s], t[o] = s), s.push(i) } else t[o] = i } parseParens(t) { let n = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { let r = fu(this.remaining), o = this.remaining[r.length]; if (o !== "/" && o !== ")" && o !== ";") throw new v(4010, !1); let i; r.indexOf(":") > -1 ? (i = r.slice(0, r.indexOf(":")), this.capture(i), this.capture(":")) : t && (i = A); let s = this.parseChildren(); n[i] = Object.keys(s).length === 1 ? s[A] : new U([], s), this.consumeOptional("//") } return n } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return this.peekStartsWith(t) ? (this.remaining = this.remaining.substring(t.length), !0) : !1 } capture(t) { if (!this.consumeOptional(t)) throw new v(4011, !1) } }; function qg(e) { return e.segments.length > 0 ? new U([], { [A]: e }) : e } function Wg(e) { let t = {}; for (let [r, o] of Object.entries(e.children)) { let i = Wg(o); if (r === A && i.segments.length === 0 && i.hasChildren()) for (let [s, a] of Object.entries(i.children)) t[s] = a; else (i.segments.length > 0 || i.hasChildren()) && (t[r] = i) } let n = new U(e.segments, t); return o_(n) } function o_(e) { if (e.numberOfChildren === 1 && e.children[A]) { let t = e.children[A]; return new U(e.segments.concat(t.segments), t.children) } return e } function Vt(e) { return e instanceof ot } function Zg(e, t, n = null, r = null) { let o = Yg(e); return Qg(o, t, n, r) } function Yg(e) { let t; function n(i) { let s = {}; for (let l of i.children) { let c = n(l); s[l.outlet] = c } let a = new U(i.url, s); return i === e && (t = a), a } let r = n(e.root), o = qg(r); return t ?? o } function Qg(e, t, n, r) { let o = e; for (; o.parent;)o = o.parent; if (t.length === 0) return hu(o, o, o, n, r); let i = i_(t); if (i.toRoot()) return hu(o, o, new U([], {}), n, r); let s = s_(i, o, e), a = s.processChildren ? Xr(s.segmentGroup, s.index, i.commands) : Jg(s.segmentGroup, s.index, i.commands); return hu(o, s.segmentGroup, a, n, r) } function Is(e) { return typeof e == "object" && e != null && !e.outlets && !e.segmentPath } function to(e) { return typeof e == "object" && e != null && e.outlets } function hu(e, t, n, r, o) { let i = {}; r && Object.entries(r).forEach(([l, c]) => { i[l] = Array.isArray(c) ? c.map(u => `${u}`) : `${c}` }); let s; e === t ? s = n : s = Kg(e, t, n); let a = qg(Wg(s)); return new ot(a, i, o) } function Kg(e, t, n) { let r = {}; return Object.entries(e.children).forEach(([o, i]) => { i === t ? r[o] = n : r[o] = Kg(i, t, n) }), new U(e.segments, r) } var Ms = class { isAbsolute; numberOfDoubleDots; commands; constructor(t, n, r) { if (this.isAbsolute = t, this.numberOfDoubleDots = n, this.commands = r, t && r.length > 0 && Is(r[0])) throw new v(4003, !1); let o = r.find(to); if (o && o !== jg(r)) throw new v(4004, !1) } toRoot() { return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/" } }; function i_(e) { if (typeof e[0] == "string" && e.length === 1 && e[0] === "/") return new Ms(!0, 0, e); let t = 0, n = !1, r = e.reduce((o, i, s) => { if (typeof i == "object" && i != null) { if (i.outlets) { let a = {}; return Object.entries(i.outlets).forEach(([l, c]) => { a[l] = typeof c == "string" ? c.split("/") : c }), [...o, { outlets: a }] } if (i.segmentPath) return [...o, i.segmentPath] } return typeof i != "string" ? [...o, i] : s === 0 ? (i.split("/").forEach((a, l) => { l == 0 && a === "." || (l == 0 && a === "" ? n = !0 : a === ".." ? t++ : a != "" && o.push(a)) }), o) : [...o, i] }, []); return new Ms(n, t, r) } var Yn = class { segmentGroup; processChildren; index; constructor(t, n, r) { this.segmentGroup = t, this.processChildren = n, this.index = r } }; function s_(e, t, n) { if (e.isAbsolute) return new Yn(t, !0, 0); if (!n) return new Yn(t, !1, NaN); if (n.parent === null) return new Yn(n, !0, 0); let r = Is(e.commands[0]) ? 0 : 1, o = n.segments.length - 1 + r; return a_(n, o, e.numberOfDoubleDots) } function a_(e, t, n) { let r = e, o = t, i = n; for (; i > o;) { if (i -= o, r = r.parent, !r) throw new v(4005, !1); o = r.segments.length } return new Yn(r, !1, o - i) } function l_(e) { return to(e[0]) ? e[0].outlets : { [A]: e } } function Jg(e, t, n) { if (e ??= new U([], {}), e.segments.length === 0 && e.hasChildren()) return Xr(e, t, n); let r = c_(e, t, n), o = n.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { let i = new U(e.segments.slice(0, r.pathIndex), {}); return i.children[A] = new U(e.segments.slice(r.pathIndex), e.children), Xr(i, 0, o) } else return r.match && o.length === 0 ? new U(e.segments, {}) : r.match && !e.hasChildren() ? Cu(e, t, n) : r.match ? Xr(e, 0, o) : Cu(e, t, n) } function Xr(e, t, n) { if (n.length === 0) return new U(e.segments, {}); { let r = l_(n), o = {}; if (Object.keys(r).some(i => i !== A) && e.children[A] && e.numberOfChildren === 1 && e.children[A].segments.length === 0) { let i = Xr(e.children[A], t, n); return new U(e.segments, i.children) } return Object.entries(r).forEach(([i, s]) => { typeof s == "string" && (s = [s]), s !== null && (o[i] = Jg(e.children[i], t, s)) }), Object.entries(e.children).forEach(([i, s]) => { r[i] === void 0 && (o[i] = s) }), new U(e.segments, o) } } function c_(e, t, n) { let r = 0, o = t, i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; o < e.segments.length;) { if (r >= n.length) return i; let s = e.segments[o], a = n[r]; if (to(a)) break; let l = `${a}`, c = r < n.length - 1 ? n[r + 1] : null; if (o > 0 && l === void 0) break; if (l && c && typeof c == "object" && c.outlets === void 0) { if (!Og(l, c, s)) return i; r += 2 } else { if (!Og(l, {}, s)) return i; r++ } o++ } return { match: !0, pathIndex: o, commandIndex: r } } function Cu(e, t, n) { let r = e.segments.slice(0, t), o = 0; for (; o < n.length;) { let i = n[o]; if (to(i)) { let l = u_(i.outlets); return new U(r, l) } if (o === 0 && Is(n[0])) { let l = e.segments[t]; r.push(new Lt(l.path, Rg(n[0]))), o++; continue } let s = to(i) ? i.outlets[A] : `${i}`, a = o < n.length - 1 ? n[o + 1] : null; s && a && Is(a) ? (r.push(new Lt(s, Rg(a))), o += 2) : (r.push(new Lt(s, {})), o++) } return new U(r, {}) } function u_(e) { let t = {}; return Object.entries(e).forEach(([n, r]) => { typeof r == "string" && (r = [r]), r !== null && (t[n] = Cu(new U([], {}), 0, r)) }), t } function Rg(e) { let t = {}; return Object.entries(e).forEach(([n, r]) => t[n] = `${r}`), t } function Og(e, t, n) { return e == n.path && nt(t, n.parameters) } var _s = "imperative", le = function (e) { return e[e.NavigationStart = 0] = "NavigationStart", e[e.NavigationEnd = 1] = "NavigationEnd", e[e.NavigationCancel = 2] = "NavigationCancel", e[e.NavigationError = 3] = "NavigationError", e[e.RoutesRecognized = 4] = "RoutesRecognized", e[e.ResolveStart = 5] = "ResolveStart", e[e.ResolveEnd = 6] = "ResolveEnd", e[e.GuardsCheckStart = 7] = "GuardsCheckStart", e[e.GuardsCheckEnd = 8] = "GuardsCheckEnd", e[e.RouteConfigLoadStart = 9] = "RouteConfigLoadStart", e[e.RouteConfigLoadEnd = 10] = "RouteConfigLoadEnd", e[e.ChildActivationStart = 11] = "ChildActivationStart", e[e.ChildActivationEnd = 12] = "ChildActivationEnd", e[e.ActivationStart = 13] = "ActivationStart", e[e.ActivationEnd = 14] = "ActivationEnd", e[e.Scroll = 15] = "Scroll", e[e.NavigationSkipped = 16] = "NavigationSkipped", e }(le || {}), Ne = class { id; url; constructor(t, n) { this.id = t, this.url = n } }, dn = class extends Ne { type = le.NavigationStart; navigationTrigger; restoredState; constructor(t, n, r = "imperative", o = null) { super(t, n), this.navigationTrigger = r, this.restoredState = o } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } }, it = class extends Ne { urlAfterRedirects; type = le.NavigationEnd; constructor(t, n, r) { super(t, n), this.urlAfterRedirects = r } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } }, we = function (e) { return e[e.Redirect = 0] = "Redirect", e[e.SupersededByNewNavigation = 1] = "SupersededByNewNavigation", e[e.NoDataFromResolver = 2] = "NoDataFromResolver", e[e.GuardRejected = 3] = "GuardRejected", e }(we || {}), no = function (e) { return e[e.IgnoredSameUrlNavigation = 0] = "IgnoredSameUrlNavigation", e[e.IgnoredByUrlHandlingStrategy = 1] = "IgnoredByUrlHandlingStrategy", e }(no || {}), rt = class extends Ne { reason; code; type = le.NavigationCancel; constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } }, Et = class extends Ne { reason; code; type = le.NavigationSkipped; constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o } }, Kn = class extends Ne { error; target; type = le.NavigationError; constructor(t, n, r, o) { super(t, n), this.error = r, this.target = o } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } }, ro = class extends Ne { urlAfterRedirects; state; type = le.RoutesRecognized; constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, Ss = class extends Ne { urlAfterRedirects; state; type = le.GuardsCheckStart; constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, Ts = class extends Ne { urlAfterRedirects; state; shouldActivate; type = le.GuardsCheckEnd; constructor(t, n, r, o, i) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.shouldActivate = i } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } }, Ns = class extends Ne { urlAfterRedirects; state; type = le.ResolveStart; constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, xs = class extends Ne { urlAfterRedirects; state; type = le.ResolveEnd; constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } }, As = class { route; type = le.RouteConfigLoadStart; constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } }, Rs = class { route; type = le.RouteConfigLoadEnd; constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } }, Os = class { snapshot; type = le.ChildActivationStart; constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }, Ps = class { snapshot; type = le.ChildActivationEnd; constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }, Fs = class { snapshot; type = le.ActivationStart; constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }, ks = class { snapshot; type = le.ActivationEnd; constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } }; var oo = class { }, Jn = class { url; navigationBehaviorOptions; constructor(t, n) { this.url = t, this.navigationBehaviorOptions = n } }; function d_(e, t) { return e.providers && !e._injector && (e._injector = Ji(e.providers, t, `Route: ${e.path}`)), e._injector ?? t } function ze(e) { return e.outlet || A } function f_(e, t) { let n = e.filter(r => ze(r) === t); return n.push(...e.filter(r => ze(r) !== t)), n } function ho(e) { if (!e) return null; if (e.routeConfig?._injector) return e.routeConfig._injector; for (let t = e.parent; t; t = t.parent) { let n = t.routeConfig; if (n?._loadedInjector) return n._loadedInjector; if (n?._injector) return n._injector } return null } var Ls = class { rootInjector; outlet = null; route = null; children; attachRef = null; get injector() { return ho(this.route?.snapshot) ?? this.rootInjector } constructor(t) { this.rootInjector = t, this.children = new tr(this.rootInjector) } }, tr = (() => { class e { rootInjector; contexts = new Map; constructor(n) { this.rootInjector = n } onChildOutletCreated(n, r) { let o = this.getOrCreateContext(n); o.outlet = r, this.contexts.set(n, o) } onChildOutletDestroyed(n) { let r = this.getContext(n); r && (r.outlet = null, r.attachRef = null) } onOutletDeactivated() { let n = this.contexts; return this.contexts = new Map, n } onOutletReAttached(n) { this.contexts = n } getOrCreateContext(n) { let r = this.getContext(n); return r || (r = new Ls(this.rootInjector), this.contexts.set(n, r)), r } getContext(n) { return this.contexts.get(n) || null } static \u0275fac = function (r) { return new (r || e)(M(fe)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), Vs = class { _root; constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { let n = this.pathFromRoot(t); return n.length > 1 ? n[n.length - 2] : null } children(t) { let n = Eu(t, this._root); return n ? n.children.map(r => r.value) : [] } firstChild(t) { let n = Eu(t, this._root); return n && n.children.length > 0 ? n.children[0].value : null } siblings(t) { let n = wu(t, this._root); return n.length < 2 ? [] : n[n.length - 2].children.map(o => o.value).filter(o => o !== t) } pathFromRoot(t) { return wu(t, this._root).map(n => n.value) } }; function Eu(e, t) { if (e === t.value) return t; for (let n of t.children) { let r = Eu(e, n); if (r) return r } return null } function wu(e, t) { if (e === t.value) return [t]; for (let n of t.children) { let r = wu(e, n); if (r.length) return r.unshift(t), r } return [] } var Te = class { value; children; constructor(t, n) { this.value = t, this.children = n } toString() { return `TreeNode(${this.value})` } }; function Zn(e) { let t = {}; return e && e.children.forEach(n => t[n.value.outlet] = n), t } var io = class extends Vs { snapshot; constructor(t, n) { super(t), this.snapshot = n, xu(this, t) } toString() { return this.snapshot.toString() } }; function Xg(e) { let t = h_(e), n = new ne([new Lt("", {})]), r = new ne({}), o = new ne({}), i = new ne({}), s = new ne(""), a = new xe(n, r, i, s, o, A, e, t.root); return a.snapshot = t.root, new io(new Te(a, []), t) } function h_(e) { let t = {}, n = {}, r = {}, o = "", i = new ln([], t, r, o, n, A, e, null, {}); return new so("", new Te(i, [])) } var xe = class { urlSubject; paramsSubject; queryParamsSubject; fragmentSubject; dataSubject; outlet; component; snapshot; _futureSnapshot; _routerState; _paramMap; _queryParamMap; title; url; params; queryParams; fragment; data; constructor(t, n, r, o, i, s, a, l) { this.urlSubject = t, this.paramsSubject = n, this.queryParamsSubject = r, this.fragmentSubject = o, this.dataSubject = i, this.outlet = s, this.component = a, this._futureSnapshot = l, this.title = this.dataSubject?.pipe(T(c => c[uo])) ?? S(void 0), this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap ??= this.params.pipe(T(t => cn(t))), this._paramMap } get queryParamMap() { return this._queryParamMap ??= this.queryParams.pipe(T(t => cn(t))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } }; function js(e, t, n = "emptyOnly") { let r, { routeConfig: o } = e; return t !== null && (n === "always" || o?.path === "" || !t.component && !t.routeConfig?.loadComponent) ? r = { params: m(m({}, t.params), e.params), data: m(m({}, t.data), e.data), resolve: m(m(m(m({}, e.data), t.data), o?.data), e._resolvedData) } : r = { params: m({}, e.params), data: m({}, e.data), resolve: m(m({}, e.data), e._resolvedData ?? {}) }, o && tm(o) && (r.resolve[uo] = o.title), r } var ln = class { url; params; queryParams; fragment; data; outlet; component; routeConfig; _resolve; _resolvedData; _routerState; _paramMap; _queryParamMap; get title() { return this.data?.[uo] } constructor(t, n, r, o, i, s, a, l, c) { this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.routeConfig = l, this._resolve = c } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap ??= cn(this.params), this._paramMap } get queryParamMap() { return this._queryParamMap ??= cn(this.queryParams), this._queryParamMap } toString() { let t = this.url.map(r => r.toString()).join("/"), n = this.routeConfig ? this.routeConfig.path : ""; return `Route(url:'${t}', path:'${n}')` } }, so = class extends Vs { url; constructor(t, n) { super(n), this.url = t, xu(this, n) } toString() { return em(this._root) } }; function xu(e, t) { t.value._routerState = e, t.children.forEach(n => xu(e, n)) } function em(e) { let t = e.children.length > 0 ? ` { ${e.children.map(em).join(", ")} } ` : ""; return `${e.value}${t}` } function pu(e) { if (e.snapshot) { let t = e.snapshot, n = e._futureSnapshot; e.snapshot = n, nt(t.queryParams, n.queryParams) || e.queryParamsSubject.next(n.queryParams), t.fragment !== n.fragment && e.fragmentSubject.next(n.fragment), nt(t.params, n.params) || e.paramsSubject.next(n.params), Ub(t.url, n.url) || e.urlSubject.next(n.url), nt(t.data, n.data) || e.dataSubject.next(n.data) } else e.snapshot = e._futureSnapshot, e.dataSubject.next(e._futureSnapshot.data) } function bu(e, t) { let n = nt(e.params, t.params) && Gb(e.url, t.url), r = !e.parent != !t.parent; return n && !r && (!e.parent || bu(e.parent, t.parent)) } function tm(e) { return typeof e.title == "string" || e.title === null } var nm = new D(""), po = (() => { class e { activated = null; get activatedComponentRef() { return this.activated } _activatedRoute = null; name = A; activateEvents = new X; deactivateEvents = new X; attachEvents = new X; detachEvents = new X; routerOutletData = Ah(void 0); parentContexts = g(tr); location = g(Bn); changeDetector = g(rn); inputBinder = g(Hs, { optional: !0 }); supportsBindingToComponentInputs = !0; ngOnChanges(n) { if (n.name) { let { firstChange: r, previousValue: o } = n.name; if (r) return; this.isTrackedInParentContexts(o) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(o)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder?.unsubscribeFromRouteData(this) } isTrackedInParentContexts(n) { return this.parentContexts.getContext(n)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; let n = this.parentContexts.getContext(this.name); n?.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new v(4012, !1); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new v(4012, !1); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new v(4012, !1); this.location.detach(); let n = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(n.instance), n } attach(n, r) { this.activated = n, this._activatedRoute = r, this.location.insert(n.hostView), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(n.instance) } deactivate() { if (this.activated) { let n = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(n) } } activateWith(n, r) { if (this.isActivated) throw new v(4013, !1); this._activatedRoute = n; let o = this.location, s = n.snapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, l = new _u(n, a, o.injector, this.routerOutletData); this.activated = o.createComponent(s, { index: o.length, injector: l, environmentInjector: r }), this.changeDetector.markForCheck(), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance) } static \u0275fac = function (r) { return new (r || e) }; static \u0275dir = Y({ type: e, selectors: [["router-outlet"]], inputs: { name: "name", routerOutletData: [1, "routerOutletData"] }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], features: [vt] }) } return e })(), _u = class { route; childContexts; parent; outletData; constructor(t, n, r, o) { this.route = t, this.childContexts = n, this.parent = r, this.outletData = o } get(t, n) { return t === xe ? this.route : t === tr ? this.childContexts : t === nm ? this.outletData : this.parent.get(t, n) } }, Hs = new D(""); var Au = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275cmp = ke({ type: e, selectors: [["ng-component"]], exportAs: ["emptyRouterOutlet"], decls: 1, vars: 0, template: function (r, o) { r & 1 && q(0, "router-outlet") }, dependencies: [po], encapsulation: 2 }) } return e })(); function Ru(e) { let t = e.children && e.children.map(Ru), n = t ? P(m({}, e), { children: t }) : m({}, e); return !n.component && !n.loadComponent && (t || n.loadChildren) && n.outlet && n.outlet !== A && (n.component = Au), n } function p_(e, t, n) { let r = ao(e, t._root, n ? n._root : void 0); return new io(r, t) } function ao(e, t, n) { if (n && e.shouldReuseRoute(t.value, n.value.snapshot)) { let r = n.value; r._futureSnapshot = t.value; let o = g_(e, t, n); return new Te(r, o) } else { if (e.shouldAttach(t.value)) { let i = e.retrieve(t.value); if (i !== null) { let s = i.route; return s.value._futureSnapshot = t.value, s.children = t.children.map(a => ao(e, a)), s } } let r = m_(t.value), o = t.children.map(i => ao(e, i)); return new Te(r, o) } } function g_(e, t, n) { return t.children.map(r => { for (let o of n.children) if (e.shouldReuseRoute(r.value, o.value.snapshot)) return ao(e, r, o); return ao(e, r) }) } function m_(e) { return new xe(new ne(e.url), new ne(e.params), new ne(e.queryParams), new ne(e.fragment), new ne(e.data), e.outlet, e.component, e) } var Xn = class { redirectTo; navigationBehaviorOptions; constructor(t, n) { this.redirectTo = t, this.navigationBehaviorOptions = n } }, rm = "ngNavigationCancelingError"; function Bs(e, t) { let { redirectTo: n, navigationBehaviorOptions: r } = Vt(t) ? { redirectTo: t, navigationBehaviorOptions: void 0 } : t, o = om(!1, we.Redirect); return o.url = n, o.navigationBehaviorOptions = r, o } function om(e, t) { let n = new Error(`NavigationCancelingError: ${e || ""}`); return n[rm] = !0, n.cancellationCode = t, n } function v_(e) { return im(e) && Vt(e.url) } function im(e) { return !!e && e[rm] } var y_ = (e, t, n, r) => T(o => (new Iu(t, o.targetRouterState, o.currentRouterState, n, r).activate(e), o)), Iu = class { routeReuseStrategy; futureState; currState; forwardEvent; inputBindingEnabled; constructor(t, n, r, o, i) { this.routeReuseStrategy = t, this.futureState = n, this.currState = r, this.forwardEvent = o, this.inputBindingEnabled = i } activate(t) { let n = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(n, r, t), pu(this.futureState.root), this.activateChildRoutes(n, r, t) } deactivateChildRoutes(t, n, r) { let o = Zn(n); t.children.forEach(i => { let s = i.value.outlet; this.deactivateRoutes(i, o[s], r), delete o[s] }), Object.values(o).forEach(i => { this.deactivateRouteAndItsChildren(i, r) }) } deactivateRoutes(t, n, r) { let o = t.value, i = n ? n.value : null; if (o === i) if (o.component) { let s = r.getContext(o.outlet); s && this.deactivateChildRoutes(t, n, s.children) } else this.deactivateChildRoutes(t, n, r); else i && this.deactivateRouteAndItsChildren(n, r) } deactivateRouteAndItsChildren(t, n) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, n) : this.deactivateRouteAndOutlet(t, n) } detachAndStoreRouteSubtree(t, n) { let r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = Zn(t); for (let s of Object.values(i)) this.deactivateRouteAndItsChildren(s, o); if (r && r.outlet) { let s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: s, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, n) { let r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = Zn(t); for (let s of Object.values(i)) this.deactivateRouteAndItsChildren(s, o); r && (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()), r.attachRef = null, r.route = null) } activateChildRoutes(t, n, r) { let o = Zn(n); t.children.forEach(i => { this.activateRoutes(i, o[i.value.outlet], r), this.forwardEvent(new ks(i.value.snapshot)) }), t.children.length && this.forwardEvent(new Ps(t.value.snapshot)) } activateRoutes(t, n, r) { let o = t.value, i = n ? n.value : null; if (pu(o), o === i) if (o.component) { let s = r.getOrCreateContext(o.outlet); this.activateChildRoutes(t, n, s.children) } else this.activateChildRoutes(t, n, r); else if (o.component) { let s = r.getOrCreateContext(o.outlet); if (this.routeReuseStrategy.shouldAttach(o.snapshot)) { let a = this.routeReuseStrategy.retrieve(o.snapshot); this.routeReuseStrategy.store(o.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), pu(a.route.value), this.activateChildRoutes(t, null, s.children) } else s.attachRef = null, s.route = o, s.outlet && s.outlet.activateWith(o, s.injector), this.activateChildRoutes(t, null, s.children) } else this.activateChildRoutes(t, null, r) } }, Us = class { path; route; constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } }, Qn = class { component; route; constructor(t, n) { this.component = t, this.route = n } }; function D_(e, t, n) { let r = e._root, o = t ? t._root : null; return Jr(r, o, n, [r.value]) } function C_(e) { let t = e.routeConfig ? e.routeConfig.canActivateChild : null; return !t || t.length === 0 ? null : { node: e, guards: t } } function nr(e, t) { let n = Symbol(), r = t.get(e, n); return r === n ? typeof e == "function" && !If(e) ? e : t.get(e) : r } function Jr(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { let i = Zn(t); return e.children.forEach(s => { E_(s, i[s.value.outlet], n, r.concat([s.value]), o), delete i[s.value.outlet] }), Object.entries(i).forEach(([s, a]) => eo(a, n.getContext(s), o)), o } function E_(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { let i = e.value, s = t ? t.value : null, a = n ? n.getContext(e.value.outlet) : null; if (s && i.routeConfig === s.routeConfig) { let l = w_(s, i, i.routeConfig.runGuardsAndResolvers); l ? o.canActivateChecks.push(new Us(r)) : (i.data = s.data, i._resolvedData = s._resolvedData), i.component ? Jr(e, t, a ? a.children : null, r, o) : Jr(e, t, n, r, o), l && a && a.outlet && a.outlet.isActivated && o.canDeactivateChecks.push(new Qn(a.outlet.component, s)) } else s && eo(t, a, o), o.canActivateChecks.push(new Us(r)), i.component ? Jr(e, null, a ? a.children : null, r, o) : Jr(e, null, n, r, o); return o } function w_(e, t, n) { if (typeof n == "function") return n(e, t); switch (n) { case "pathParamsChange": return !an(e.url, t.url); case "pathParamsOrQueryParamsChange": return !an(e.url, t.url) || !nt(e.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !bu(e, t) || !nt(e.queryParams, t.queryParams); case "paramsChange": default: return !bu(e, t) } } function eo(e, t, n) { let r = Zn(e), o = e.value; Object.entries(r).forEach(([i, s]) => { o.component ? t ? eo(s, t.children.getContext(i), n) : eo(s, null, n) : eo(s, t, n) }), o.component ? t && t.outlet && t.outlet.isActivated ? n.canDeactivateChecks.push(new Qn(t.outlet.component, o)) : n.canDeactivateChecks.push(new Qn(null, o)) : n.canDeactivateChecks.push(new Qn(null, o)) } function go(e) { return typeof e == "function" } function b_(e) { return typeof e == "boolean" } function __(e) { return e && go(e.canLoad) } function I_(e) { return e && go(e.canActivate) } function M_(e) { return e && go(e.canActivateChild) } function S_(e) { return e && go(e.canDeactivate) } function T_(e) { return e && go(e.canMatch) } function sm(e) { return e instanceof lt || e?.name === "EmptyError" } var Cs = Symbol("INITIAL_VALUE"); function er() { return se(e => ti(e.map(t => t.pipe(ct(1), Ka(Cs)))).pipe(T(t => { for (let n of t) if (n !== !0) { if (n === Cs) return Cs; if (n === !1 || N_(n)) return n } return !0 }), _e(t => t !== Cs), ct(1))) } function N_(e) { return Vt(e) || e instanceof Xn } function x_(e, t) { return re(n => { let { targetSnapshot: r, currentSnapshot: o, guards: { canActivateChecks: i, canDeactivateChecks: s } } = n; return s.length === 0 && i.length === 0 ? S(P(m({}, n), { guardsResult: !0 })) : A_(s, r, o, e).pipe(re(a => a && b_(a) ? R_(r, i, e, t) : S(a)), T(a => P(m({}, n), { guardsResult: a }))) }) } function A_(e, t, n, r) { return W(e).pipe(re(o => L_(o.component, o.route, n, t, r)), ut(o => o !== !0, !0)) } function R_(e, t, n, r) { return W(t).pipe(_t(o => wn(P_(o.route.parent, r), O_(o.route, r), k_(e, o.path, n), F_(e, o.route, n))), ut(o => o !== !0, !0)) } function O_(e, t) { return e !== null && t && t(new Fs(e)), S(!0) } function P_(e, t) { return e !== null && t && t(new Os(e)), S(!0) } function F_(e, t, n) { let r = t.routeConfig ? t.routeConfig.canActivate : null; if (!r || r.length === 0) return S(!0); let o = r.map(i => ni(() => { let s = ho(t) ?? n, a = nr(i, s), l = I_(a) ? a.canActivate(t, e) : Me(s, () => a(t, e)); return jt(l).pipe(ut()) })); return S(o).pipe(er()) } function k_(e, t, n) { let r = t[t.length - 1], i = t.slice(0, t.length - 1).reverse().map(s => C_(s)).filter(s => s !== null).map(s => ni(() => { let a = s.guards.map(l => { let c = ho(s.node) ?? n, u = nr(l, c), f = M_(u) ? u.canActivateChild(r, e) : Me(c, () => u(r, e)); return jt(f).pipe(ut()) }); return S(a).pipe(er()) })); return S(i).pipe(er()) } function L_(e, t, n, r, o) { let i = t && t.routeConfig ? t.routeConfig.canDeactivate : null; if (!i || i.length === 0) return S(!0); let s = i.map(a => { let l = ho(t) ?? o, c = nr(a, l), u = S_(c) ? c.canDeactivate(e, t, n, r) : Me(l, () => c(e, t, n, r)); return jt(u).pipe(ut()) }); return S(s).pipe(er()) } function V_(e, t, n, r) { let o = t.canLoad; if (o === void 0 || o.length === 0) return S(!0); let i = o.map(s => { let a = nr(s, e), l = __(a) ? a.canLoad(t, n) : Me(e, () => a(t, n)); return jt(l) }); return S(i).pipe(er(), am(r)) } function am(e) { return Ha(ce(t => { if (typeof t != "boolean") throw Bs(e, t) }), T(t => t === !0)) } function j_(e, t, n, r) { let o = t.canMatch; if (!o || o.length === 0) return S(!0); let i = o.map(s => { let a = nr(s, e), l = T_(a) ? a.canMatch(t, n) : Me(e, () => a(t, n)); return jt(l) }); return S(i).pipe(er(), am(r)) } var lo = class { segmentGroup; constructor(t) { this.segmentGroup = t || null } }, co = class extends Error { urlTree; constructor(t) { super(), this.urlTree = t } }; function Wn(e) { return En(new lo(e)) } function B_(e) { return En(new v(4e3, !1)) } function U_(e) { return En(om(!1, we.GuardRejected)) } var Mu = class { urlSerializer; urlTree; constructor(t, n) { this.urlSerializer = t, this.urlTree = n } lineralizeSegments(t, n) { let r = [], o = n.root; for (; ;) { if (r = r.concat(o.segments), o.numberOfChildren === 0) return S(r); if (o.numberOfChildren > 1 || !o.children[A]) return B_(`${t.redirectTo}`); o = o.children[A] } } applyRedirectCommands(t, n, r, o, i) { if (typeof n != "string") { let a = n, { queryParams: l, fragment: c, routeConfig: u, url: f, outlet: h, params: d, data: p, title: y } = o, I = Me(i, () => a({ params: d, data: p, queryParams: l, fragment: c, routeConfig: u, url: f, outlet: h, title: y })); if (I instanceof ot) throw new co(I); n = I } let s = this.applyRedirectCreateUrlTree(n, this.urlSerializer.parse(n), t, r); if (n[0] === "/") throw new co(s); return s } applyRedirectCreateUrlTree(t, n, r, o) { let i = this.createSegmentGroup(t, n.root, r, o); return new ot(i, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment) } createQueryParams(t, n) { let r = {}; return Object.entries(t).forEach(([o, i]) => { if (typeof i == "string" && i[0] === ":") { let a = i.substring(1); r[o] = n[a] } else r[o] = i }), r } createSegmentGroup(t, n, r, o) { let i = this.createSegments(t, n.segments, r, o), s = {}; return Object.entries(n.children).forEach(([a, l]) => { s[a] = this.createSegmentGroup(t, l, r, o) }), new U(i, s) } createSegments(t, n, r, o) { return n.map(i => i.path[0] === ":" ? this.findPosParam(t, i, o) : this.findOrReturn(i, r)) } findPosParam(t, n, r) { let o = r[n.path.substring(1)]; if (!o) throw new v(4001, !1); return o } findOrReturn(t, n) { let r = 0; for (let o of n) { if (o.path === t.path) return n.splice(r), o; r++ } return t } }, Su = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function $_(e, t, n, r, o) { let i = lm(e, t, n); return i.matched ? (r = d_(t, r), j_(r, t, n, o).pipe(T(s => s === !0 ? i : m({}, Su)))) : S(i) } function lm(e, t, n) { if (t.path === "**") return H_(n); if (t.path === "") return t.pathMatch === "full" && (e.hasChildren() || n.length > 0) ? m({}, Su) : { matched: !0, consumedSegments: [], remainingSegments: n, parameters: {}, positionalParamSegments: {} }; let o = (t.matcher || Lg)(n, e, t); if (!o) return m({}, Su); let i = {}; Object.entries(o.posParams ?? {}).forEach(([a, l]) => { i[a] = l.path }); let s = o.consumed.length > 0 ? m(m({}, i), o.consumed[o.consumed.length - 1].parameters) : i; return { matched: !0, consumedSegments: o.consumed, remainingSegments: n.slice(o.consumed.length), parameters: s, positionalParamSegments: o.posParams ?? {} } } function H_(e) { return { matched: !0, parameters: e.length > 0 ? jg(e).parameters : {}, consumedSegments: e, remainingSegments: [], positionalParamSegments: {} } } function Pg(e, t, n, r) { return n.length > 0 && q_(e, n, r) ? { segmentGroup: new U(t, G_(r, new U(n, e.children))), slicedSegments: [] } : n.length === 0 && W_(e, n, r) ? { segmentGroup: new U(e.segments, z_(e, n, r, e.children)), slicedSegments: n } : { segmentGroup: new U(e.segments, e.children), slicedSegments: n } } function z_(e, t, n, r) { let o = {}; for (let i of n) if (zs(e, t, i) && !r[ze(i)]) { let s = new U([], {}); o[ze(i)] = s } return m(m({}, r), o) } function G_(e, t) { let n = {}; n[A] = t; for (let r of e) if (r.path === "" && ze(r) !== A) { let o = new U([], {}); n[ze(r)] = o } return n } function q_(e, t, n) { return n.some(r => zs(e, t, r) && ze(r) !== A) } function W_(e, t, n) { return n.some(r => zs(e, t, r)) } function zs(e, t, n) { return (e.hasChildren() || t.length > 0) && n.pathMatch === "full" ? !1 : n.path === "" } function Z_(e, t, n) { return t.length === 0 && !e.children[n] } var Tu = class { }; function Y_(e, t, n, r, o, i, s = "emptyOnly") { return new Nu(e, t, n, r, o, s, i).recognize() } var Q_ = 31, Nu = class { injector; configLoader; rootComponentType; config; urlTree; paramsInheritanceStrategy; urlSerializer; applyRedirects; absoluteRedirectCount = 0; allowRedirects = !0; constructor(t, n, r, o, i, s, a) { this.injector = t, this.configLoader = n, this.rootComponentType = r, this.config = o, this.urlTree = i, this.paramsInheritanceStrategy = s, this.urlSerializer = a, this.applyRedirects = new Mu(this.urlSerializer, this.urlTree) } noMatchError(t) { return new v(4002, `'${t.segmentGroup}'`) } recognize() { let t = Pg(this.urlTree.root, [], [], this.config).segmentGroup; return this.match(t).pipe(T(({ children: n, rootSnapshot: r }) => { let o = new Te(r, n), i = new so("", o), s = Zg(r, [], this.urlTree.queryParams, this.urlTree.fragment); return s.queryParams = this.urlTree.queryParams, i.url = this.urlSerializer.serialize(s), { state: i, tree: s } })) } match(t) { let n = new ln([], Object.freeze({}), Object.freeze(m({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), A, this.rootComponentType, null, {}); return this.processSegmentGroup(this.injector, this.config, t, A, n).pipe(T(r => ({ children: r, rootSnapshot: n })), bt(r => { if (r instanceof co) return this.urlTree = r.urlTree, this.match(r.urlTree.root); throw r instanceof lo ? this.noMatchError(r) : r })) } processSegmentGroup(t, n, r, o, i) { return r.segments.length === 0 && r.hasChildren() ? this.processChildren(t, n, r, i) : this.processSegment(t, n, r, r.segments, o, !0, i).pipe(T(s => s instanceof Te ? [s] : [])) } processChildren(t, n, r, o) { let i = []; for (let s of Object.keys(r.children)) s === "primary" ? i.unshift(s) : i.push(s); return W(i).pipe(_t(s => { let a = r.children[s], l = f_(n, s); return this.processSegmentGroup(t, l, a, s, o) }), Qa((s, a) => (s.push(...a), s)), It(null), Ya(), re(s => { if (s === null) return Wn(r); let a = cm(s); return K_(a), S(a) })) } processSegment(t, n, r, o, i, s, a) { return W(n).pipe(_t(l => this.processSegmentAgainstRoute(l._injector ?? t, n, l, r, o, i, s, a).pipe(bt(c => { if (c instanceof lo) return S(null); throw c }))), ut(l => !!l), bt(l => { if (sm(l)) return Z_(r, o, i) ? S(new Tu) : Wn(r); throw l })) } processSegmentAgainstRoute(t, n, r, o, i, s, a, l) { return ze(r) !== s && (s === A || !zs(o, i, r)) ? Wn(o) : r.redirectTo === void 0 ? this.matchSegmentAgainstRoute(t, o, r, i, s, l) : this.allowRedirects && a ? this.expandSegmentAgainstRouteUsingRedirect(t, o, n, r, i, s, l) : Wn(o) } expandSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s, a) { let { matched: l, parameters: c, consumedSegments: u, positionalParamSegments: f, remainingSegments: h } = lm(n, o, i); if (!l) return Wn(n); typeof o.redirectTo == "string" && o.redirectTo[0] === "/" && (this.absoluteRedirectCount++, this.absoluteRedirectCount > Q_ && (this.allowRedirects = !1)); let d = new ln(i, c, Object.freeze(m({}, this.urlTree.queryParams)), this.urlTree.fragment, Fg(o), ze(o), o.component ?? o._loadedComponent ?? null, o, kg(o)), p = js(d, a, this.paramsInheritanceStrategy); d.params = Object.freeze(p.params), d.data = Object.freeze(p.data); let y = this.applyRedirects.applyRedirectCommands(u, o.redirectTo, f, d, t); return this.applyRedirects.lineralizeSegments(o, y).pipe(re(I => this.processSegment(t, r, n, I.concat(h), s, !1, a))) } matchSegmentAgainstRoute(t, n, r, o, i, s) { let a = $_(n, r, o, t, this.urlSerializer); return r.path === "**" && (n.children = {}), a.pipe(se(l => l.matched ? (t = r._injector ?? t, this.getChildConfig(t, r, o).pipe(se(({ routes: c }) => { let u = r._loadedInjector ?? t, { parameters: f, consumedSegments: h, remainingSegments: d } = l, p = new ln(h, f, Object.freeze(m({}, this.urlTree.queryParams)), this.urlTree.fragment, Fg(r), ze(r), r.component ?? r._loadedComponent ?? null, r, kg(r)), y = js(p, s, this.paramsInheritanceStrategy); p.params = Object.freeze(y.params), p.data = Object.freeze(y.data); let { segmentGroup: I, slicedSegments: j } = Pg(n, h, d, c); if (j.length === 0 && I.hasChildren()) return this.processChildren(u, c, I, p).pipe(T(ee => new Te(p, ee))); if (c.length === 0 && j.length === 0) return S(new Te(p, [])); let Mo = ze(r) === i; return this.processSegment(u, c, I, j, Mo ? A : i, !0, p).pipe(T(ee => new Te(p, ee instanceof Te ? [ee] : []))) }))) : Wn(n))) } getChildConfig(t, n, r) { return n.children ? S({ routes: n.children, injector: t }) : n.loadChildren ? n._loadedRoutes !== void 0 ? S({ routes: n._loadedRoutes, injector: n._loadedInjector }) : V_(t, n, r, this.urlSerializer).pipe(re(o => o ? this.configLoader.loadChildren(t, n).pipe(ce(i => { n._loadedRoutes = i.routes, n._loadedInjector = i.injector })) : U_(n))) : S({ routes: [], injector: t }) } }; function K_(e) { e.sort((t, n) => t.value.outlet === A ? -1 : n.value.outlet === A ? 1 : t.value.outlet.localeCompare(n.value.outlet)) } function J_(e) { let t = e.value.routeConfig; return t && t.path === "" } function cm(e) { let t = [], n = new Set; for (let r of e) { if (!J_(r)) { t.push(r); continue } let o = t.find(i => r.value.routeConfig === i.value.routeConfig); o !== void 0 ? (o.children.push(...r.children), n.add(o)) : t.push(r) } for (let r of n) { let o = cm(r.children); t.push(new Te(r.value, o)) } return t.filter(r => !n.has(r)) } function Fg(e) { return e.data || {} } function kg(e) { return e.resolve || {} } function X_(e, t, n, r, o, i) { return re(s => Y_(e, t, n, r, s.extractedUrl, o, i).pipe(T(({ state: a, tree: l }) => P(m({}, s), { targetSnapshot: a, urlAfterRedirects: l })))) } function eI(e, t) { return re(n => { let { targetSnapshot: r, guards: { canActivateChecks: o } } = n; if (!o.length) return S(n); let i = new Set(o.map(l => l.route)), s = new Set; for (let l of i) if (!s.has(l)) for (let c of um(l)) s.add(c); let a = 0; return W(s).pipe(_t(l => i.has(l) ? tI(l, r, e, t) : (l.data = js(l, l.parent, e).resolve, S(void 0))), ce(() => a++), bn(1), re(l => a === s.size ? S(n) : me)) }) } function um(e) { let t = e.children.map(n => um(n)).flat(); return [e, ...t] } function tI(e, t, n, r) { let o = e.routeConfig, i = e._resolve; return o?.title !== void 0 && !tm(o) && (i[uo] = o.title), nI(i, e, t, r).pipe(T(s => (e._resolvedData = s, e.data = js(e, e.parent, n).resolve, null))) } function nI(e, t, n, r) { let o = vu(e); if (o.length === 0) return S({}); let i = {}; return W(o).pipe(re(s => rI(e[s], t, n, r).pipe(ut(), ce(a => { if (a instanceof Xn) throw Bs(new un, a); i[s] = a }))), bn(1), T(() => i), bt(s => sm(s) ? me : En(s))) } function rI(e, t, n, r) { let o = ho(t) ?? r, i = nr(e, o), s = i.resolve ? i.resolve(t, n) : Me(o, () => i(t, n)); return jt(s) } function gu(e) { return se(t => { let n = e(t); return n ? W(n).pipe(T(() => t)) : S(t) }) } var Ou = (() => { class e { buildTitle(n) { let r, o = n.root; for (; o !== void 0;)r = this.getResolvedTitleForRoute(o) ?? r, o = o.children.find(i => i.outlet === A); return r } getResolvedTitleForRoute(n) { return n.data[uo] } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: () => g(dm), providedIn: "root" }) } return e })(), dm = (() => { class e extends Ou { title; constructor(n) { super(), this.title = n } updateTitle(n) { let r = this.buildTitle(n); r !== void 0 && this.title.setTitle(r) } static \u0275fac = function (r) { return new (r || e)(M(Ng)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), mo = new D("", { providedIn: "root", factory: () => ({}) }), vo = new D(""), fm = (() => { class e { componentLoaders = new WeakMap; childrenLoaders = new WeakMap; onLoadStartListener; onLoadEndListener; compiler = g(qp); loadComponent(n) { if (this.componentLoaders.get(n)) return this.componentLoaders.get(n); if (n._loadedComponent) return S(n._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(n); let r = jt(n.loadComponent()).pipe(T(pm), ce(i => { this.onLoadEndListener && this.onLoadEndListener(n), n._loadedComponent = i }), Gt(() => { this.componentLoaders.delete(n) })), o = new Cn(r, () => new K).pipe(Dn()); return this.componentLoaders.set(n, o), o } loadChildren(n, r) { if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r); if (r._loadedRoutes) return S({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); let i = hm(r, this.compiler, n, this.onLoadEndListener).pipe(Gt(() => { this.childrenLoaders.delete(r) })), s = new Cn(i, () => new K).pipe(Dn()); return this.childrenLoaders.set(r, s), s } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function hm(e, t, n, r) { return jt(e.loadChildren()).pipe(T(pm), re(o => o instanceof jc || Array.isArray(o) ? S(o) : W(t.compileModuleAsync(o))), T(o => { r && r(e); let i, s, a = !1; return Array.isArray(o) ? (s = o, a = !0) : (i = o.create(n).injector, s = i.get(vo, [], { optional: !0, self: !0 }).flat()), { routes: s.map(Ru), injector: i } })) } function oI(e) { return e && typeof e == "object" && "default" in e } function pm(e) { return oI(e) ? e.default : e } var Gs = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: () => g(iI), providedIn: "root" }) } return e })(), iI = (() => { class e { shouldProcessUrl(n) { return !0 } extract(n) { return n } merge(n, r) { return n } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), gm = new D(""); var mm = new D(""), vm = (() => { class e { currentNavigation = null; currentTransition = null; lastSuccessfulNavigation = null; events = new K; transitionAbortSubject = new K; configLoader = g(fm); environmentInjector = g(fe); destroyRef = g(Or); urlSerializer = g(fo); rootContexts = g(tr); location = g(Hn); inputBindingEnabled = g(Hs, { optional: !0 }) !== null; titleStrategy = g(Ou); options = g(mo, { optional: !0 }) || {}; paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly"; urlHandlingStrategy = g(Gs); createViewTransition = g(gm, { optional: !0 }); navigationErrorHandler = g(mm, { optional: !0 }); navigationId = 0; get hasRequestedNavigation() { return this.navigationId !== 0 } transitions; afterPreactivation = () => S(void 0); rootComponentType = null; destroyed = !1; constructor() { let n = o => this.events.next(new As(o)), r = o => this.events.next(new Rs(o)); this.configLoader.onLoadEndListener = r, this.configLoader.onLoadStartListener = n, this.destroyRef.onDestroy(() => { this.destroyed = !0 }) } complete() { this.transitions?.complete() } handleNavigationRequest(n) { let r = ++this.navigationId; this.transitions?.next(P(m({}, n), { extractedUrl: this.urlHandlingStrategy.extract(n.rawUrl), targetSnapshot: null, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null, id: r })) } setupNavigations(n) { return this.transitions = new ne(null), this.transitions.pipe(_e(r => r !== null), se(r => { let o = !1, i = !1; return S(r).pipe(se(s => { if (this.navigationId > r.id) return this.cancelNavigationTransition(r, "", we.SupersededByNewNavigation), me; this.currentTransition = r, this.currentNavigation = { id: s.id, initialUrl: s.rawUrl, extractedUrl: s.extractedUrl, targetBrowserUrl: typeof s.extras.browserUrl == "string" ? this.urlSerializer.parse(s.extras.browserUrl) : s.extras.browserUrl, trigger: s.source, extras: s.extras, previousNavigation: this.lastSuccessfulNavigation ? P(m({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null }; let a = !n.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl(), l = s.extras.onSameUrlNavigation ?? n.onSameUrlNavigation; if (!a && l !== "reload") { let c = ""; return this.events.next(new Et(s.id, this.urlSerializer.serialize(s.rawUrl), c, no.IgnoredSameUrlNavigation)), s.resolve(!1), me } if (this.urlHandlingStrategy.shouldProcessUrl(s.rawUrl)) return S(s).pipe(se(c => (this.events.next(new dn(c.id, this.urlSerializer.serialize(c.extractedUrl), c.source, c.restoredState)), c.id !== this.navigationId ? me : Promise.resolve(c))), X_(this.environmentInjector, this.configLoader, this.rootComponentType, n.config, this.urlSerializer, this.paramsInheritanceStrategy), ce(c => { r.targetSnapshot = c.targetSnapshot, r.urlAfterRedirects = c.urlAfterRedirects, this.currentNavigation = P(m({}, this.currentNavigation), { finalUrl: c.urlAfterRedirects }); let u = new ro(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(u) })); if (a && this.urlHandlingStrategy.shouldProcessUrl(s.currentRawUrl)) { let { id: c, extractedUrl: u, source: f, restoredState: h, extras: d } = s, p = new dn(c, this.urlSerializer.serialize(u), f, h); this.events.next(p); let y = Xg(this.rootComponentType).snapshot; return this.currentTransition = r = P(m({}, s), { targetSnapshot: y, urlAfterRedirects: u, extras: P(m({}, d), { skipLocationChange: !1, replaceUrl: !1 }) }), this.currentNavigation.finalUrl = u, S(r) } else { let c = ""; return this.events.next(new Et(s.id, this.urlSerializer.serialize(s.extractedUrl), c, no.IgnoredByUrlHandlingStrategy)), s.resolve(!1), me } }), ce(s => { let a = new Ss(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects), s.targetSnapshot); this.events.next(a) }), T(s => (this.currentTransition = r = P(m({}, s), { guards: D_(s.targetSnapshot, s.currentSnapshot, this.rootContexts) }), r)), x_(this.environmentInjector, s => this.events.next(s)), ce(s => { if (r.guardsResult = s.guardsResult, s.guardsResult && typeof s.guardsResult != "boolean") throw Bs(this.urlSerializer, s.guardsResult); let a = new Ts(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects), s.targetSnapshot, !!s.guardsResult); this.events.next(a) }), _e(s => s.guardsResult ? !0 : (this.cancelNavigationTransition(s, "", we.GuardRejected), !1)), gu(s => { if (s.guards.canActivateChecks.length !== 0) return S(s).pipe(ce(a => { let l = new Ns(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(l) }), se(a => { let l = !1; return S(a).pipe(eI(this.paramsInheritanceStrategy, this.environmentInjector), ce({ next: () => l = !0, complete: () => { l || this.cancelNavigationTransition(a, "", we.NoDataFromResolver) } })) }), ce(a => { let l = new xs(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(l) })) }), gu(s => { let a = l => { let c = []; l.routeConfig?.loadComponent && !l.routeConfig._loadedComponent && c.push(this.configLoader.loadComponent(l.routeConfig).pipe(ce(u => { l.component = u }), T(() => { }))); for (let u of l.children) c.push(...a(u)); return c }; return ti(a(s.targetSnapshot.root)).pipe(It(null), ct(1)) }), gu(() => this.afterPreactivation()), se(() => { let { currentSnapshot: s, targetSnapshot: a } = r, l = this.createViewTransition?.(this.environmentInjector, s.root, a.root); return l ? W(l).pipe(T(() => r)) : S(r) }), T(s => { let a = p_(n.routeReuseStrategy, s.targetSnapshot, s.currentRouterState); return this.currentTransition = r = P(m({}, s), { targetRouterState: a }), this.currentNavigation.targetRouterState = a, r }), ce(() => { this.events.next(new oo) }), y_(this.rootContexts, n.routeReuseStrategy, s => this.events.next(s), this.inputBindingEnabled), ct(1), ce({ next: s => { o = !0, this.lastSuccessfulNavigation = this.currentNavigation, this.events.next(new it(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects))), this.titleStrategy?.updateTitle(s.targetRouterState.snapshot), s.resolve(!0) }, complete: () => { o = !0 } }), Ja(this.transitionAbortSubject.pipe(ce(s => { throw s }))), Gt(() => { !o && !i && this.cancelNavigationTransition(r, "", we.SupersededByNewNavigation), this.currentTransition?.id === r.id && (this.currentNavigation = null, this.currentTransition = null) }), bt(s => { if (this.destroyed) return r.resolve(!1), me; if (i = !0, im(s)) this.events.next(new rt(r.id, this.urlSerializer.serialize(r.extractedUrl), s.message, s.cancellationCode)), v_(s) ? this.events.next(new Jn(s.url, s.navigationBehaviorOptions)) : r.resolve(!1); else { let a = new Kn(r.id, this.urlSerializer.serialize(r.extractedUrl), s, r.targetSnapshot ?? void 0); try { let l = Me(this.environmentInjector, () => this.navigationErrorHandler?.(a)); if (l instanceof Xn) { let { message: c, cancellationCode: u } = Bs(this.urlSerializer, l); this.events.next(new rt(r.id, this.urlSerializer.serialize(r.extractedUrl), c, u)), this.events.next(new Jn(l.redirectTo, l.navigationBehaviorOptions)) } else throw this.events.next(a), s } catch (l) { this.options.resolveNavigationPromiseOnError ? r.resolve(!1) : r.reject(l) } } return me })) })) } cancelNavigationTransition(n, r, o) { let i = new rt(n.id, this.urlSerializer.serialize(n.extractedUrl), r, o); this.events.next(i), n.resolve(!1) } isUpdatingInternalState() { return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString() } isUpdatedBrowserUrl() { let n = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))), r = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl; return n.toString() !== r?.toString() && !this.currentNavigation?.extras.skipLocationChange } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function sI(e) { return e !== _s } var ym = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: () => g(aI), providedIn: "root" }) } return e })(), $s = class { shouldDetach(t) { return !1 } store(t, n) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, n) { return t.routeConfig === n.routeConfig } }, aI = (() => { class e extends $s { static \u0275fac = (() => { let n; return function (o) { return (n || (n = Nt(e)))(o || e) } })(); static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), Dm = (() => { class e { urlSerializer = g(fo); options = g(mo, { optional: !0 }) || {}; canceledNavigationResolution = this.options.canceledNavigationResolution || "replace"; location = g(Hn); urlHandlingStrategy = g(Gs); urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred"; currentUrlTree = new ot; getCurrentUrlTree() { return this.currentUrlTree } rawUrlTree = this.currentUrlTree; getRawUrlTree() { return this.rawUrlTree } createBrowserPath({ finalUrl: n, initialUrl: r, targetBrowserUrl: o }) { let i = n !== void 0 ? this.urlHandlingStrategy.merge(n, r) : r, s = o ?? i; return s instanceof ot ? this.urlSerializer.serialize(s) : s } commitTransition({ targetRouterState: n, finalUrl: r, initialUrl: o }) { r && n ? (this.currentUrlTree = r, this.rawUrlTree = this.urlHandlingStrategy.merge(r, o), this.routerState = n) : this.rawUrlTree = o } routerState = Xg(null); getRouterState() { return this.routerState } stateMemento = this.createStateMemento(); updateStateMemento() { this.stateMemento = this.createStateMemento() } createStateMemento() { return { rawUrlTree: this.rawUrlTree, currentUrlTree: this.currentUrlTree, routerState: this.routerState } } resetInternalState({ finalUrl: n }) { this.routerState = this.stateMemento.routerState, this.currentUrlTree = this.stateMemento.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n ?? this.rawUrlTree) } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: () => g(lI), providedIn: "root" }) } return e })(), lI = (() => { class e extends Dm { currentPageId = 0; lastSuccessfulId = -1; restoredState() { return this.location.getState() } get browserPageId() { return this.canceledNavigationResolution !== "computed" ? this.currentPageId : this.restoredState()?.\u0275routerPageId ?? this.currentPageId } registerNonRouterCurrentEntryChangeListener(n) { return this.location.subscribe(r => { r.type === "popstate" && setTimeout(() => { n(r.url, r.state, "popstate") }) }) } handleRouterEvent(n, r) { n instanceof dn ? this.updateStateMemento() : n instanceof Et ? this.commitTransition(r) : n instanceof ro ? this.urlUpdateStrategy === "eager" && (r.extras.skipLocationChange || this.setBrowserUrl(this.createBrowserPath(r), r)) : n instanceof oo ? (this.commitTransition(r), this.urlUpdateStrategy === "deferred" && !r.extras.skipLocationChange && this.setBrowserUrl(this.createBrowserPath(r), r)) : n instanceof rt && (n.code === we.GuardRejected || n.code === we.NoDataFromResolver) ? this.restoreHistory(r) : n instanceof Kn ? this.restoreHistory(r, !0) : n instanceof it && (this.lastSuccessfulId = n.id, this.currentPageId = this.browserPageId) } setBrowserUrl(n, { extras: r, id: o }) { let { replaceUrl: i, state: s } = r; if (this.location.isCurrentPathEqualTo(n) || i) { let a = this.browserPageId, l = m(m({}, s), this.generateNgRouterState(o, a)); this.location.replaceState(n, "", l) } else { let a = m(m({}, s), this.generateNgRouterState(o, this.browserPageId + 1)); this.location.go(n, "", a) } } restoreHistory(n, r = !1) { if (this.canceledNavigationResolution === "computed") { let o = this.browserPageId, i = this.currentPageId - o; i !== 0 ? this.location.historyGo(i) : this.getCurrentUrlTree() === n.finalUrl && i === 0 && (this.resetInternalState(n), this.resetUrlToCurrentUrlTree()) } else this.canceledNavigationResolution === "replace" && (r && this.resetInternalState(n), this.resetUrlToCurrentUrlTree()) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(n, r) { return this.canceledNavigationResolution === "computed" ? { navigationId: n, \u0275routerPageId: r } : { navigationId: n } } static \u0275fac = (() => { let n; return function (o) { return (n || (n = Nt(e)))(o || e) } })(); static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function Pu(e, t) { e.events.pipe(_e(n => n instanceof it || n instanceof rt || n instanceof Kn || n instanceof Et), T(n => n instanceof it || n instanceof Et ? 0 : (n instanceof rt ? n.code === we.Redirect || n.code === we.SupersededByNewNavigation : !1) ? 2 : 1), _e(n => n !== 2), ct(1)).subscribe(() => { t() }) } var cI = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, uI = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }, Ae = (() => { class e { get currentUrlTree() { return this.stateManager.getCurrentUrlTree() } get rawUrlTree() { return this.stateManager.getRawUrlTree() } disposed = !1; nonRouterCurrentEntryChangeSubscription; console = g(Rp); stateManager = g(Dm); options = g(mo, { optional: !0 }) || {}; pendingTasks = g(xt); urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred"; navigationTransitions = g(vm); urlSerializer = g(fo); location = g(Hn); urlHandlingStrategy = g(Gs); _events = new K; get events() { return this._events } get routerState() { return this.stateManager.getRouterState() } navigated = !1; routeReuseStrategy = g(ym); onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore"; config = g(vo, { optional: !0 })?.flat() ?? []; componentInputBindingEnabled = !!g(Hs, { optional: !0 }); constructor() { this.resetConfig(this.config), this.navigationTransitions.setupNavigations(this).subscribe({ error: n => { this.console.warn(n) } }), this.subscribeToNavigationEvents() } eventsSubscription = new Q; subscribeToNavigationEvents() { let n = this.navigationTransitions.events.subscribe(r => { try { let o = this.navigationTransitions.currentTransition, i = this.navigationTransitions.currentNavigation; if (o !== null && i !== null) { if (this.stateManager.handleRouterEvent(r, i), r instanceof rt && r.code !== we.Redirect && r.code !== we.SupersededByNewNavigation) this.navigated = !0; else if (r instanceof it) this.navigated = !0; else if (r instanceof Jn) { let s = r.navigationBehaviorOptions, a = this.urlHandlingStrategy.merge(r.url, o.currentRawUrl), l = m({ browserUrl: o.extras.browserUrl, info: o.extras.info, skipLocationChange: o.extras.skipLocationChange, replaceUrl: o.extras.replaceUrl || this.urlUpdateStrategy === "eager" || sI(o.source) }, s); this.scheduleNavigation(a, _s, null, l, { resolve: o.resolve, reject: o.reject, promise: o.promise }) } } fI(r) && this._events.next(r) } catch (o) { this.navigationTransitions.transitionAbortSubject.next(o) } }); this.eventsSubscription.add(n) } resetRootComponentType(n) { this.routerState.root.component = n, this.navigationTransitions.rootComponentType = n } initialNavigation() { this.setUpLocationChangeListener(), this.navigationTransitions.hasRequestedNavigation || this.navigateToSyncWithBrowser(this.location.path(!0), _s, this.stateManager.restoredState()) } setUpLocationChangeListener() { this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((n, r, o) => { this.navigateToSyncWithBrowser(n, o, r) }) } navigateToSyncWithBrowser(n, r, o) { let i = { replaceUrl: !0 }, s = o?.navigationId ? o : null; if (o) { let l = m({}, o); delete l.navigationId, delete l.\u0275routerPageId, Object.keys(l).length !== 0 && (i.state = l) } let a = this.parseUrl(n); this.scheduleNavigation(a, r, s, i) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } get lastSuccessfulNavigation() { return this.navigationTransitions.lastSuccessfulNavigation } resetConfig(n) { this.config = n.map(Ru), this.navigated = !1 } ngOnDestroy() { this.dispose() } dispose() { this._events.unsubscribe(), this.navigationTransitions.complete(), this.nonRouterCurrentEntryChangeSubscription && (this.nonRouterCurrentEntryChangeSubscription.unsubscribe(), this.nonRouterCurrentEntryChangeSubscription = void 0), this.disposed = !0, this.eventsSubscription.unsubscribe() } createUrlTree(n, r = {}) { let { relativeTo: o, queryParams: i, fragment: s, queryParamsHandling: a, preserveFragment: l } = r, c = l ? this.currentUrlTree.fragment : s, u = null; switch (a ?? this.options.defaultQueryParamsHandling) { case "merge": u = m(m({}, this.currentUrlTree.queryParams), i); break; case "preserve": u = this.currentUrlTree.queryParams; break; default: u = i || null }u !== null && (u = this.removeEmptyProps(u)); let f; try { let h = o ? o.snapshot : this.routerState.snapshot.root; f = Yg(h) } catch { (typeof n[0] != "string" || n[0][0] !== "/") && (n = []), f = this.currentUrlTree.root } return Qg(f, n, u, c ?? null) } navigateByUrl(n, r = { skipLocationChange: !1 }) { let o = Vt(n) ? n : this.parseUrl(n), i = this.urlHandlingStrategy.merge(o, this.rawUrlTree); return this.scheduleNavigation(i, _s, null, r) } navigate(n, r = { skipLocationChange: !1 }) { return dI(n), this.navigateByUrl(this.createUrlTree(n, r), r) } serializeUrl(n) { return this.urlSerializer.serialize(n) } parseUrl(n) { try { return this.urlSerializer.parse(n) } catch { return this.urlSerializer.parse("/") } } isActive(n, r) { let o; if (r === !0 ? o = m({}, cI) : r === !1 ? o = m({}, uI) : o = r, Vt(n)) return xg(this.currentUrlTree, n, o); let i = this.parseUrl(n); return xg(this.currentUrlTree, i, o) } removeEmptyProps(n) { return Object.entries(n).reduce((r, [o, i]) => (i != null && (r[o] = i), r), {}) } scheduleNavigation(n, r, o, i, s) { if (this.disposed) return Promise.resolve(!1); let a, l, c; s ? (a = s.resolve, l = s.reject, c = s.promise) : c = new Promise((f, h) => { a = f, l = h }); let u = this.pendingTasks.add(); return Pu(this, () => { queueMicrotask(() => this.pendingTasks.remove(u)) }), this.navigationTransitions.handleNavigationRequest({ source: r, restoredState: o, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, rawUrl: n, extras: i, resolve: a, reject: l, promise: c, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), c.catch(f => Promise.reject(f)) } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function dI(e) { for (let t = 0; t < e.length; t++)if (e[t] == null) throw new v(4008, !1) } function fI(e) { return !(e instanceof oo) && !(e instanceof Jn) } var Bt = (() => { class e { router; route; tabIndexAttribute; renderer; el; locationStrategy; href = null; target; queryParams; fragment; queryParamsHandling; state; info; relativeTo; isAnchorElement; subscription; onChanges = new K; constructor(n, r, o, i, s, a) { this.router = n, this.route = r, this.tabIndexAttribute = o, this.renderer = i, this.el = s, this.locationStrategy = a; let l = s.nativeElement.tagName?.toLowerCase(); this.isAnchorElement = l === "a" || l === "area", this.isAnchorElement ? this.subscription = n.events.subscribe(c => { c instanceof it && this.updateHref() }) : this.setTabIndexIfNotOnNativeEl("0") } preserveFragment = !1; skipLocationChange = !1; replaceUrl = !1; setTabIndexIfNotOnNativeEl(n) { this.tabIndexAttribute != null || this.isAnchorElement || this.applyAttributeValue("tabindex", n) } ngOnChanges(n) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this) } routerLinkInput = null; set routerLink(n) { n == null ? (this.routerLinkInput = null, this.setTabIndexIfNotOnNativeEl(null)) : (Vt(n) ? this.routerLinkInput = n : this.routerLinkInput = Array.isArray(n) ? n : [n], this.setTabIndexIfNotOnNativeEl("0")) } onClick(n, r, o, i, s) { let a = this.urlTree; if (a === null || this.isAnchorElement && (n !== 0 || r || o || i || s || typeof this.target == "string" && this.target != "_self")) return !0; let l = { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state, info: this.info }; return this.router.navigateByUrl(a, l), !this.isAnchorElement } ngOnDestroy() { this.subscription?.unsubscribe() } updateHref() { let n = this.urlTree; this.href = n !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(n)) : null; let r = this.href === null ? null : qh(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", r) } applyAttributeValue(n, r) { let o = this.renderer, i = this.el.nativeElement; r !== null ? o.setAttribute(i, n, r) : o.removeAttribute(i, n) } get urlTree() { return this.routerLinkInput === null ? null : Vt(this.routerLinkInput) ? this.routerLinkInput : this.router.createUrlTree(this.routerLinkInput, { relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }) } static \u0275fac = function (r) { return new (r || e)(E(Ae), E(xe), mc("tabindex"), E(At), E(yt), E($n)) }; static \u0275dir = Y({ type: e, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (r, o) { r & 1 && ge("click", function (s) { return o.onClick(s.button, s.ctrlKey, s.shiftKey, s.altKey, s.metaKey) }), r & 2 && es("target", o.target) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", info: "info", relativeTo: "relativeTo", preserveFragment: [2, "preserveFragment", "preserveFragment", Un], skipLocationChange: [2, "skipLocationChange", "skipLocationChange", Un], replaceUrl: [2, "replaceUrl", "replaceUrl", Un], routerLink: "routerLink" }, features: [vt] }) } return e })(); var pI = new D(""); function Fu(e, ...t) { return Ar([{ provide: vo, multi: !0, useValue: e }, [], { provide: xe, useFactory: gI, deps: [Ae] }, { provide: Uc, multi: !0, useFactory: mI }, t.map(n => n.\u0275providers)]) } function gI(e) { return e.routerState.root } function mI() { let e = g(ft); return t => { let n = e.get(en); if (t !== n.components[0]) return; let r = e.get(Ae), o = e.get(vI); e.get(yI) === 1 && r.initialNavigation(), e.get(DI, null, R.Optional)?.setUpPreloading(), e.get(pI, null, R.Optional)?.init(), r.resetRootComponentType(n.componentTypes[0]), o.closed || (o.next(), o.complete(), o.unsubscribe()) } } var vI = new D("", { factory: () => new K }), yI = new D("", { providedIn: "root", factory: () => 1 }); var DI = new D(""); var Ws = class e { transform(t, n) { return n ? t.filter(r => r.type === n) : t } static \u0275fac = function (n) { return new (n || e) }; static \u0275pipe = Xi({ name: "filterByType", type: e, pure: !0 }) }; var Nm = (() => { class e { _renderer; _elementRef; onChange = n => { }; onTouched = () => { }; constructor(n, r) { this._renderer = n, this._elementRef = r } setProperty(n, r) { this._renderer.setProperty(this._elementRef.nativeElement, n, r) } registerOnTouched(n) { this.onTouched = n } registerOnChange(n) { this.onChange = n } setDisabledState(n) { this.setProperty("disabled", n) } static \u0275fac = function (r) { return new (r || e)(E(At), E(yt)) }; static \u0275dir = Y({ type: e }) } return e })(), na = (() => { class e extends Nm { static \u0275fac = (() => { let n; return function (o) { return (n || (n = Nt(e)))(o || e) } })(); static \u0275dir = Y({ type: e, features: [Le] }) } return e })(), sr = new D(""); var CI = { provide: sr, useExisting: Ke(() => ar), multi: !0 }; function EI() { let e = Ve() ? Ve().getUserAgent() : ""; return /android (\d+)/.test(e.toLowerCase()) } var wI = new D(""), ar = (() => { class e extends Nm { _compositionMode; _composing = !1; constructor(n, r, o) { super(n, r), this._compositionMode = o, this._compositionMode == null && (this._compositionMode = !EI()) } writeValue(n) { let r = n ?? ""; this.setProperty("value", r) } _handleInput(n) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(n) } _compositionStart() { this._composing = !0 } _compositionEnd(n) { this._composing = !1, this._compositionMode && this.onChange(n) } static \u0275fac = function (r) { return new (r || e)(E(At), E(yt), E(wI, 8)) }; static \u0275dir = Y({ type: e, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (r, o) { r & 1 && ge("input", function (s) { return o._handleInput(s.target.value) })("blur", function () { return o.onTouched() })("compositionstart", function () { return o._compositionStart() })("compositionend", function (s) { return o._compositionEnd(s.target.value) }) }, standalone: !1, features: [Pt([CI]), Le] }) } return e })(); function $u(e) { return e == null || Hu(e) === 0 } function Hu(e) { return e == null ? null : Array.isArray(e) || typeof e == "string" ? e.length : e instanceof Set ? e.size : null } var zu = new D(""), Gu = new D(""), bI = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, G = class { static min(t) { return _I(t) } static max(t) { return II(t) } static required(t) { return MI(t) } static requiredTrue(t) { return SI(t) } static email(t) { return TI(t) } static minLength(t) { return NI(t) } static maxLength(t) { return xI(t) } static pattern(t) { return AI(t) } static nullValidator(t) { return xm() } static compose(t) { return km(t) } static composeAsync(t) { return Vm(t) } }; function _I(e) { return t => { if (t.value == null || e == null) return null; let n = parseFloat(t.value); return !isNaN(n) && n < e ? { min: { min: e, actual: t.value } } : null } } function II(e) { return t => { if (t.value == null || e == null) return null; let n = parseFloat(t.value); return !isNaN(n) && n > e ? { max: { max: e, actual: t.value } } : null } } function MI(e) { return $u(e.value) ? { required: !0 } : null } function SI(e) { return e.value === !0 ? null : { required: !0 } } function TI(e) { return $u(e.value) || bI.test(e.value) ? null : { email: !0 } } function NI(e) { return t => { let n = t.value?.length ?? Hu(t.value); return n === null || n === 0 ? null : n < e ? { minlength: { requiredLength: e, actualLength: n } } : null } } function xI(e) { return t => { let n = t.value?.length ?? Hu(t.value); return n !== null && n > e ? { maxlength: { requiredLength: e, actualLength: n } } : null } } function AI(e) { if (!e) return xm; let t, n; return typeof e == "string" ? (n = "", e.charAt(0) !== "^" && (n += "^"), n += e, e.charAt(e.length - 1) !== "$" && (n += "$"), t = new RegExp(n)) : (n = e.toString(), t = e), r => { if ($u(r.value)) return null; let o = r.value; return t.test(o) ? null : { pattern: { requiredPattern: n, actualValue: o } } } } function xm(e) { return null } function Am(e) { return e != null } function Rm(e) { return Ot(e) ? W(e) : e } function Om(e) { let t = {}; return e.forEach(n => { t = n != null ? m(m({}, t), n) : t }), Object.keys(t).length === 0 ? null : t } function Pm(e, t) { return t.map(n => n(e)) } function RI(e) { return !e.validate } function Fm(e) { return e.map(t => RI(t) ? t : n => t.validate(n)) } function km(e) { if (!e) return null; let t = e.filter(Am); return t.length == 0 ? null : function (n) { return Om(Pm(n, t)) } } function Lm(e) { return e != null ? km(Fm(e)) : null } function Vm(e) { if (!e) return null; let t = e.filter(Am); return t.length == 0 ? null : function (n) { let r = Pm(n, t).map(Rm); return Za(r).pipe(T(Om)) } } function jm(e) { return e != null ? Vm(Fm(e)) : null } function Cm(e, t) { return e === null ? [t] : Array.isArray(e) ? [...e, t] : [e, t] } function Bm(e) { return e._rawValidators } function Um(e) { return e._rawAsyncValidators } function ku(e) { return e ? Array.isArray(e) ? e : [e] : [] } function Ys(e, t) { return Array.isArray(e) ? e.includes(t) : e === t } function Em(e, t) { let n = ku(t); return ku(e).forEach(o => { Ys(n, o) || n.push(o) }), n } function wm(e, t) { return ku(t).filter(n => !Ys(e, n)) } var Qs = class { get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _composedValidatorFn; _composedAsyncValidatorFn; _rawValidators = []; _rawAsyncValidators = []; _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = Lm(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = jm(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _onDestroyCallbacks = []; _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t = void 0) { this.control && this.control.reset(t) } hasError(t, n) { return this.control ? this.control.hasError(t, n) : !1 } getError(t, n) { return this.control ? this.control.getError(t, n) : null } }, fn = class extends Qs { name; get formDirective() { return null } get path() { return null } }, hn = class extends Qs { _parent = null; name = null; valueAccessor = null }, Ks = class { _cd; constructor(t) { this._cd = t } get isTouched() { return this._cd?.control?._touched?.(), !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return this._cd?.control?._pristine?.(), !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return this._cd?.control?._status?.(), !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return this._cd?._submitted?.(), !!this._cd?.submitted } }, OI = { "[class.ng-untouched]": "isUntouched", "[class.ng-touched]": "isTouched", "[class.ng-pristine]": "isPristine", "[class.ng-dirty]": "isDirty", "[class.ng-valid]": "isValid", "[class.ng-invalid]": "isInvalid", "[class.ng-pending]": "isPending" }, FF = P(m({}, OI), { "[class.ng-submitted]": "isSubmitted" }), lr = (() => { class e extends Ks { constructor(n) { super(n) } static \u0275fac = function (r) { return new (r || e)(E(hn, 2)) }; static \u0275dir = Y({ type: e, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (r, o) { r & 2 && ts("ng-untouched", o.isUntouched)("ng-touched", o.isTouched)("ng-pristine", o.isPristine)("ng-dirty", o.isDirty)("ng-valid", o.isValid)("ng-invalid", o.isInvalid)("ng-pending", o.isPending) }, standalone: !1, features: [Le] }) } return e })(), ra = (() => { class e extends Ks { constructor(n) { super(n) } static \u0275fac = function (r) { return new (r || e)(E(fn, 10)) }; static \u0275dir = Y({ type: e, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (r, o) { r & 2 && ts("ng-untouched", o.isUntouched)("ng-touched", o.isTouched)("ng-pristine", o.isPristine)("ng-dirty", o.isDirty)("ng-valid", o.isValid)("ng-invalid", o.isInvalid)("ng-pending", o.isPending)("ng-submitted", o.isSubmitted) }, standalone: !1, features: [Le] }) } return e })(); var yo = "VALID", Zs = "INVALID", rr = "PENDING", Do = "DISABLED", Ut = class { }, Js = class extends Ut { value; source; constructor(t, n) { super(), this.value = t, this.source = n } }, Co = class extends Ut { pristine; source; constructor(t, n) { super(), this.pristine = t, this.source = n } }, Eo = class extends Ut { touched; source; constructor(t, n) { super(), this.touched = t, this.source = n } }, or = class extends Ut { status; source; constructor(t, n) { super(), this.status = t, this.source = n } }, Lu = class extends Ut { source; constructor(t) { super(), this.source = t } }, Vu = class extends Ut { source; constructor(t) { super(), this.source = t } }; function qu(e) { return (oa(e) ? e.validators : e) || null } function PI(e) { return Array.isArray(e) ? Lm(e) : e || null } function Wu(e, t) { return (oa(t) ? t.asyncValidators : e) || null } function FI(e) { return Array.isArray(e) ? jm(e) : e || null } function oa(e) { return e != null && !Array.isArray(e) && typeof e == "object" } function $m(e, t, n) { let r = e.controls; if (!(t ? Object.keys(r) : r).length) throw new v(1e3, ""); if (!r[n]) throw new v(1001, "") } function Hm(e, t, n) { e._forEachChild((r, o) => { if (n[o] === void 0) throw new v(1002, "") }) } var ir = class { _pendingDirty = !1; _hasOwnPendingAsyncValidator = null; _pendingTouched = !1; _onCollectionChange = () => { }; _updateOn; _parent = null; _asyncValidationSubscription; _composedValidatorFn; _composedAsyncValidatorFn; _rawValidators; _rawAsyncValidators; value; constructor(t, n) { this._assignValidators(t), this._assignAsyncValidators(n) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get status() { return He(this.statusReactive) } set status(t) { He(() => this.statusReactive.set(t)) } _status = Vr(() => this.statusReactive()); statusReactive = Pr(void 0); get valid() { return this.status === yo } get invalid() { return this.status === Zs } get pending() { return this.status == rr } get disabled() { return this.status === Do } get enabled() { return this.status !== Do } errors; get pristine() { return He(this.pristineReactive) } set pristine(t) { He(() => this.pristineReactive.set(t)) } _pristine = Vr(() => this.pristineReactive()); pristineReactive = Pr(!0); get dirty() { return !this.pristine } get touched() { return He(this.touchedReactive) } set touched(t) { He(() => this.touchedReactive.set(t)) } _touched = Vr(() => this.touchedReactive()); touchedReactive = Pr(!1); get untouched() { return !this.touched } _events = new K; events = this._events.asObservable(); valueChanges; statusChanges; get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._assignValidators(t) } setAsyncValidators(t) { this._assignAsyncValidators(t) } addValidators(t) { this.setValidators(Em(t, this._rawValidators)) } addAsyncValidators(t) { this.setAsyncValidators(Em(t, this._rawAsyncValidators)) } removeValidators(t) { this.setValidators(wm(t, this._rawValidators)) } removeAsyncValidators(t) { this.setAsyncValidators(wm(t, this._rawAsyncValidators)) } hasValidator(t) { return Ys(this._rawValidators, t) } hasAsyncValidator(t) { return Ys(this._rawAsyncValidators, t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { let n = this.touched === !1; this.touched = !0; let r = t.sourceControl ?? this; this._parent && !t.onlySelf && this._parent.markAsTouched(P(m({}, t), { sourceControl: r })), n && t.emitEvent !== !1 && this._events.next(new Eo(!0, r)) } markAllAsTouched(t = {}) { this.markAsTouched({ onlySelf: !0, emitEvent: t.emitEvent, sourceControl: this }), this._forEachChild(n => n.markAllAsTouched(t)) } markAsUntouched(t = {}) { let n = this.touched === !0; this.touched = !1, this._pendingTouched = !1; let r = t.sourceControl ?? this; this._forEachChild(o => { o.markAsUntouched({ onlySelf: !0, emitEvent: t.emitEvent, sourceControl: r }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t, r), n && t.emitEvent !== !1 && this._events.next(new Eo(!1, r)) } markAsDirty(t = {}) { let n = this.pristine === !0; this.pristine = !1; let r = t.sourceControl ?? this; this._parent && !t.onlySelf && this._parent.markAsDirty(P(m({}, t), { sourceControl: r })), n && t.emitEvent !== !1 && this._events.next(new Co(!1, r)) } markAsPristine(t = {}) { let n = this.pristine === !1; this.pristine = !0, this._pendingDirty = !1; let r = t.sourceControl ?? this; this._forEachChild(o => { o.markAsPristine({ onlySelf: !0, emitEvent: t.emitEvent }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t, r), n && t.emitEvent !== !1 && this._events.next(new Co(!0, r)) } markAsPending(t = {}) { this.status = rr; let n = t.sourceControl ?? this; t.emitEvent !== !1 && (this._events.next(new or(this.status, n)), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.markAsPending(P(m({}, t), { sourceControl: n })) } disable(t = {}) { let n = this._parentMarkedDirty(t.onlySelf); this.status = Do, this.errors = null, this._forEachChild(o => { o.disable(P(m({}, t), { onlySelf: !0 })) }), this._updateValue(); let r = t.sourceControl ?? this; t.emitEvent !== !1 && (this._events.next(new Js(this.value, r)), this._events.next(new or(this.status, r)), this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(P(m({}, t), { skipPristineCheck: n }), this), this._onDisabledChange.forEach(o => o(!0)) } enable(t = {}) { let n = this._parentMarkedDirty(t.onlySelf); this.status = yo, this._forEachChild(r => { r.enable(P(m({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(P(m({}, t), { skipPristineCheck: n }), this), this._onDisabledChange.forEach(r => r(!1)) } _updateAncestors(t, n) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine({}, n), this._parent._updateTouched({}, n)) } setParent(t) { this._parent = t } getRawValue() { return this.value } updateValueAndValidity(t = {}) { if (this._setInitialStatus(), this._updateValue(), this.enabled) { let r = this._cancelExistingSubscription(); this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === yo || this.status === rr) && this._runAsyncValidator(r, t.emitEvent) } let n = t.sourceControl ?? this; t.emitEvent !== !1 && (this._events.next(new Js(this.value, n)), this._events.next(new or(this.status, n)), this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(P(m({}, t), { sourceControl: n })) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(n => n._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? Do : yo } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t, n) { if (this.asyncValidator) { this.status = rr, this._hasOwnPendingAsyncValidator = { emitEvent: n !== !1 }; let r = Rm(this.asyncValidator(this)); this._asyncValidationSubscription = r.subscribe(o => { this._hasOwnPendingAsyncValidator = null, this.setErrors(o, { emitEvent: n, shouldHaveEmitted: t }) }) } } _cancelExistingSubscription() { if (this._asyncValidationSubscription) { this._asyncValidationSubscription.unsubscribe(); let t = this._hasOwnPendingAsyncValidator?.emitEvent ?? !1; return this._hasOwnPendingAsyncValidator = null, t } return !1 } setErrors(t, n = {}) { this.errors = t, this._updateControlsErrors(n.emitEvent !== !1, this, n.shouldHaveEmitted) } get(t) { let n = t; return n == null || (Array.isArray(n) || (n = n.split(".")), n.length === 0) ? null : n.reduce((r, o) => r && r._find(o), this) } getError(t, n) { let r = n ? this.get(n) : this; return r && r.errors ? r.errors[t] : null } hasError(t, n) { return !!this.getError(t, n) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t, n, r) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), (t || r) && this._events.next(new or(this.status, n)), this._parent && this._parent._updateControlsErrors(t, n, r) } _initObservables() { this.valueChanges = new X, this.statusChanges = new X } _calculateStatus() { return this._allControlsDisabled() ? Do : this.errors ? Zs : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(rr) ? rr : this._anyControlsHaveStatus(Zs) ? Zs : yo } _anyControlsHaveStatus(t) { return this._anyControls(n => n.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t, n) { let r = !this._anyControlsDirty(), o = this.pristine !== r; this.pristine = r, this._parent && !t.onlySelf && this._parent._updatePristine(t, n), o && this._events.next(new Co(this.pristine, n)) } _updateTouched(t = {}, n) { this.touched = this._anyControlsTouched(), this._events.next(new Eo(this.touched, n)), this._parent && !t.onlySelf && this._parent._updateTouched(t, n) } _onDisabledChange = []; _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { oa(t) && t.updateOn != null && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { let n = this._parent && this._parent.dirty; return !t && !!n && !this._parent._anyControlsDirty() } _find(t) { return null } _assignValidators(t) { this._rawValidators = Array.isArray(t) ? t.slice() : t, this._composedValidatorFn = PI(this._rawValidators) } _assignAsyncValidators(t) { this._rawAsyncValidators = Array.isArray(t) ? t.slice() : t, this._composedAsyncValidatorFn = FI(this._rawAsyncValidators) } }, Xs = class extends ir { constructor(t, n, r) { super(qu(n), Wu(r, n)), this.controls = t, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } controls; registerControl(t, n) { return this.controls[t] ? this.controls[t] : (this.controls[t] = n, n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange), n) } addControl(t, n, r = {}) { this.registerControl(t, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } removeControl(t, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } setControl(t, n, r = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], n && this.registerControl(t, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, n = {}) { Hm(this, !0, t), Object.keys(t).forEach(r => { $m(this, !0, r), this.controls[r].setValue(t[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n) } patchValue(t, n = {}) { t != null && (Object.keys(t).forEach(r => { let o = this.controls[r]; o && o.patchValue(t[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n)) } reset(t = {}, n = {}) { this._forEachChild((r, o) => { r.reset(t ? t[o] : null, { onlySelf: !0, emitEvent: n.emitEvent }) }), this._updatePristine(n, this), this._updateTouched(n, this), this.updateValueAndValidity(n) } getRawValue() { return this._reduceChildren({}, (t, n, r) => (t[r] = n.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (n, r) => r._syncPendingControls() ? !0 : n); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _forEachChild(t) { Object.keys(this.controls).forEach(n => { let r = this.controls[n]; r && t(r, n) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (let [n, r] of Object.entries(this.controls)) if (this.contains(n) && t(r)) return !0; return !1 } _reduceValue() { let t = {}; return this._reduceChildren(t, (n, r, o) => ((r.enabled || this.disabled) && (n[o] = r.value), n)) } _reduceChildren(t, n) { let r = t; return this._forEachChild((o, i) => { r = n(r, o, i) }), r } _allControlsDisabled() { for (let t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(t) { return this.controls.hasOwnProperty(t) ? this.controls[t] : null } }; var ju = class extends Xs { }; var ia = new D("", { providedIn: "root", factory: () => sa }), sa = "always"; function zm(e, t) { return [...t.path, e] } function Bu(e, t, n = sa) { Zu(e, t), t.valueAccessor.writeValue(e.value), (e.disabled || n === "always") && t.valueAccessor.setDisabledState?.(e.disabled), LI(e, t), jI(e, t), VI(e, t), kI(e, t) } function bm(e, t, n = !0) { let r = () => { }; t.valueAccessor && (t.valueAccessor.registerOnChange(r), t.valueAccessor.registerOnTouched(r)), ta(e, t), e && (t._invokeOnDestroyCallbacks(), e._registerOnCollectionChange(() => { })) } function ea(e, t) { e.forEach(n => { n.registerOnValidatorChange && n.registerOnValidatorChange(t) }) } function kI(e, t) { if (t.valueAccessor.setDisabledState) { let n = r => { t.valueAccessor.setDisabledState(r) }; e.registerOnDisabledChange(n), t._registerOnDestroy(() => { e._unregisterOnDisabledChange(n) }) } } function Zu(e, t) { let n = Bm(e); t.validator !== null ? e.setValidators(Cm(n, t.validator)) : typeof n == "function" && e.setValidators([n]); let r = Um(e); t.asyncValidator !== null ? e.setAsyncValidators(Cm(r, t.asyncValidator)) : typeof r == "function" && e.setAsyncValidators([r]); let o = () => e.updateValueAndValidity(); ea(t._rawValidators, o), ea(t._rawAsyncValidators, o) } function ta(e, t) { let n = !1; if (e !== null) { if (t.validator !== null) { let o = Bm(e); if (Array.isArray(o) && o.length > 0) { let i = o.filter(s => s !== t.validator); i.length !== o.length && (n = !0, e.setValidators(i)) } } if (t.asyncValidator !== null) { let o = Um(e); if (Array.isArray(o) && o.length > 0) { let i = o.filter(s => s !== t.asyncValidator); i.length !== o.length && (n = !0, e.setAsyncValidators(i)) } } } let r = () => { }; return ea(t._rawValidators, r), ea(t._rawAsyncValidators, r), n } function LI(e, t) { t.valueAccessor.registerOnChange(n => { e._pendingValue = n, e._pendingChange = !0, e._pendingDirty = !0, e.updateOn === "change" && Gm(e, t) }) } function VI(e, t) { t.valueAccessor.registerOnTouched(() => { e._pendingTouched = !0, e.updateOn === "blur" && e._pendingChange && Gm(e, t), e.updateOn !== "submit" && e.markAsTouched() }) } function Gm(e, t) { e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, { emitModelToViewChange: !1 }), t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1 } function jI(e, t) { let n = (r, o) => { t.valueAccessor.writeValue(r), o && t.viewToModelUpdate(r) }; e.registerOnChange(n), t._registerOnDestroy(() => { e._unregisterOnChange(n) }) } function BI(e, t) { e == null, Zu(e, t) } function UI(e, t) { return ta(e, t) } function qm(e, t) { if (!e.hasOwnProperty("model")) return !1; let n = e.model; return n.isFirstChange() ? !0 : !Object.is(t, n.currentValue) } function $I(e) { return Object.getPrototypeOf(e.constructor) === na } function HI(e, t) { e._syncPendingControls(), t.forEach(n => { let r = n.control; r.updateOn === "submit" && r._pendingChange && (n.viewToModelUpdate(r._pendingValue), r._pendingChange = !1) }) } function Wm(e, t) { if (!t) return null; Array.isArray(t); let n, r, o; return t.forEach(i => { i.constructor === ar ? n = i : $I(i) ? r = i : o = i }), o || r || n || null } function zI(e, t) { let n = e.indexOf(t); n > -1 && e.splice(n, 1) } function _m(e, t) { let n = e.indexOf(t); n > -1 && e.splice(n, 1) } function Im(e) { return typeof e == "object" && e !== null && Object.keys(e).length === 2 && "value" in e && "disabled" in e } var wo = class extends ir { defaultValue = null; _onChange = []; _pendingValue; _pendingChange = !1; constructor(t = null, n, r) { super(qu(n), Wu(r, n)), this._applyFormState(t), this._setUpdateStrategy(n), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), oa(n) && (n.nonNullable || n.initialValueIsDefault) && (Im(t) ? this.defaultValue = t.value : this.defaultValue = t) } setValue(t, n = {}) { this.value = this._pendingValue = t, this._onChange.length && n.emitModelToViewChange !== !1 && this._onChange.forEach(r => r(this.value, n.emitViewToModelChange !== !1)), this.updateValueAndValidity(n) } patchValue(t, n = {}) { this.setValue(t, n) } reset(t = this.defaultValue, n = {}) { this._applyFormState(t), this.markAsPristine(n), this.markAsUntouched(n), this.setValue(this.value, n), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { _m(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { _m(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return this.updateOn === "submit" && (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), this._pendingChange) ? (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), !0) : !1 } _applyFormState(t) { Im(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } }; var GI = e => e instanceof wo; var qI = { provide: hn, useExisting: Ke(() => Yu) }, Mm = Promise.resolve(), Yu = (() => { class e extends hn { _changeDetectorRef; callSetDisabledState; control = new wo; static ngAcceptInputType_isDisabled; _registered = !1; viewModel; name = ""; isDisabled; model; options; update = new X; constructor(n, r, o, i, s, a) { super(), this._changeDetectorRef = s, this.callSetDisabledState = a, this._parent = n, this._setValidators(r), this._setAsyncValidators(o), this.valueAccessor = Wm(this, i) } ngOnChanges(n) { if (this._checkForErrors(), !this._registered || "name" in n) { if (this._registered && (this._checkName(), this.formDirective)) { let r = n.name.previousValue; this.formDirective.removeControl({ name: r, path: this._getPath(r) }) } this._setUpControl() } "isDisabled" in n && this._updateDisabled(n), qm(n, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._getPath(this.name) } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(n) { this.viewModel = n, this.update.emit(n) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && this.options.updateOn != null && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !!(this.options && this.options.standalone) } _setUpStandalone() { Bu(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._checkName() } _checkName() { this.options && this.options.name && (this.name = this.options.name), !this._isStandalone() && this.name } _updateValue(n) { Mm.then(() => { this.control.setValue(n, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck() }) } _updateDisabled(n) { let r = n.isDisabled.currentValue, o = r !== 0 && Un(r); Mm.then(() => { o && !this.control.disabled ? this.control.disable() : !o && this.control.disabled && this.control.enable(), this._changeDetectorRef?.markForCheck() }) } _getPath(n) { return this._parent ? zm(n, this._parent) : [n] } static \u0275fac = function (r) { return new (r || e)(E(fn, 9), E(zu, 10), E(Gu, 10), E(sr, 10), E(rn, 8), E(ia, 8)) }; static \u0275dir = Y({ type: e, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: [0, "disabled", "isDisabled"], model: [0, "ngModel", "model"], options: [0, "ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], standalone: !1, features: [Pt([qI]), Le, vt] }) } return e })(); var aa = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275dir = Y({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""], standalone: !1 }) } return e })(), WI = { provide: sr, useExisting: Ke(() => bo), multi: !0 }, bo = (() => { class e extends na { writeValue(n) { let r = n ?? ""; this.setProperty("value", r) } registerOnChange(n) { this.onChange = r => { n(r == "" ? null : parseFloat(r)) } } static \u0275fac = (() => { let n; return function (o) { return (n || (n = Nt(e)))(o || e) } })(); static \u0275dir = Y({ type: e, selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]], hostBindings: function (r, o) { r & 1 && ge("input", function (s) { return o.onChange(s.target.value) })("blur", function () { return o.onTouched() }) }, standalone: !1, features: [Pt([WI]), Le] }) } return e })(); var Zm = new D(""); var ZI = { provide: fn, useExisting: Ke(() => _o) }, _o = (() => { class e extends fn { callSetDisabledState; get submitted() { return He(this._submittedReactive) } set submitted(n) { this._submittedReactive.set(n) } _submitted = Vr(() => this._submittedReactive()); _submittedReactive = Pr(!1); _oldForm; _onCollectionChange = () => this._updateDomValue(); directives = []; form = null; ngSubmit = new X; constructor(n, r, o) { super(), this.callSetDisabledState = o, this._setValidators(n), this._setAsyncValidators(r) } ngOnChanges(n) { n.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (ta(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(n) { let r = this.form.get(n.path); return Bu(r, n, this.callSetDisabledState), r.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(n), r } getControl(n) { return this.form.get(n.path) } removeControl(n) { bm(n.control || null, n, !1), zI(this.directives, n) } addFormGroup(n) { this._setUpFormContainer(n) } removeFormGroup(n) { this._cleanUpFormContainer(n) } getFormGroup(n) { return this.form.get(n.path) } addFormArray(n) { this._setUpFormContainer(n) } removeFormArray(n) { this._cleanUpFormContainer(n) } getFormArray(n) { return this.form.get(n.path) } updateModel(n, r) { this.form.get(n.path).setValue(r) } onSubmit(n) { return this._submittedReactive.set(!0), HI(this.form, this.directives), this.ngSubmit.emit(n), this.form._events.next(new Lu(this.control)), n?.target?.method === "dialog" } onReset() { this.resetForm() } resetForm(n = void 0) { this.form.reset(n), this._submittedReactive.set(!1), this.form._events.next(new Vu(this.form)) } _updateDomValue() { this.directives.forEach(n => { let r = n.control, o = this.form.get(n.path); r !== o && (bm(r || null, n), GI(o) && (Bu(o, n, this.callSetDisabledState), n.control = o)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(n) { let r = this.form.get(n.path); BI(r, n), r.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(n) { if (this.form) { let r = this.form.get(n.path); r && UI(r, n) && r.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { Zu(this.form, this), this._oldForm && ta(this._oldForm, this) } static \u0275fac = function (r) { return new (r || e)(E(zu, 10), E(Gu, 10), E(ia, 8)) }; static \u0275dir = Y({ type: e, selectors: [["", "formGroup", ""]], hostBindings: function (r, o) { r & 1 && ge("submit", function (s) { return o.onSubmit(s) })("reset", function () { return o.onReset() }) }, inputs: { form: [0, "formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], standalone: !1, features: [Pt([ZI]), Le, vt] }) } return e })(); var YI = { provide: hn, useExisting: Ke(() => Io) }, Io = (() => { class e extends hn { _ngModelWarningConfig; _added = !1; viewModel; control; name = null; set isDisabled(n) { } model; update = new X; static _ngModelWarningSentOnce = !1; _ngModelWarningSent = !1; constructor(n, r, o, i, s) { super(), this._ngModelWarningConfig = s, this._parent = n, this._setValidators(r), this._setAsyncValidators(o), this.valueAccessor = Wm(this, i) } ngOnChanges(n) { this._added || this._setUpControl(), qm(n, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(n) { this.viewModel = n, this.update.emit(n) } get path() { return zm(this.name == null ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _setUpControl() { this.control = this.formDirective.addControl(this), this._added = !0 } static \u0275fac = function (r) { return new (r || e)(E(fn, 13), E(zu, 10), E(Gu, 10), E(sr, 10), E(Zm, 8)) }; static \u0275dir = Y({ type: e, selectors: [["", "formControlName", ""]], inputs: { name: [0, "formControlName", "name"], isDisabled: [0, "disabled", "isDisabled"], model: [0, "ngModel", "model"] }, outputs: { update: "ngModelChange" }, standalone: !1, features: [Pt([YI]), Le, vt] }) } return e })(); var QI = { provide: sr, useExisting: Ke(() => cr), multi: !0 }; function Ym(e, t) { return e == null ? `${t}` : (t && typeof t == "object" && (t = "Object"), `${e}: ${t}`.slice(0, 50)) } function KI(e) { return e.split(":")[0] } var cr = (() => { class e extends na { value; _optionMap = new Map; _idCounter = 0; set compareWith(n) { this._compareWith = n } _compareWith = Object.is; writeValue(n) { this.value = n; let r = this._getOptionId(n), o = Ym(r, n); this.setProperty("value", o) } registerOnChange(n) { this.onChange = r => { this.value = this._getOptionValue(r), n(this.value) } } _registerOption() { return (this._idCounter++).toString() } _getOptionId(n) { for (let r of this._optionMap.keys()) if (this._compareWith(this._optionMap.get(r), n)) return r; return null } _getOptionValue(n) { let r = KI(n); return this._optionMap.has(r) ? this._optionMap.get(r) : n } static \u0275fac = (() => { let n; return function (o) { return (n || (n = Nt(e)))(o || e) } })(); static \u0275dir = Y({ type: e, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function (r, o) { r & 1 && ge("change", function (s) { return o.onChange(s.target.value) })("blur", function () { return o.onTouched() }) }, inputs: { compareWith: "compareWith" }, standalone: !1, features: [Pt([QI]), Le] }) } return e })(), la = (() => { class e { _element; _renderer; _select; id; constructor(n, r, o) { this._element = n, this._renderer = r, this._select = o, this._select && (this.id = this._select._registerOption()) } set ngValue(n) { this._select != null && (this._select._optionMap.set(this.id, n), this._setElementValue(Ym(this.id, n)), this._select.writeValue(this._select.value)) } set value(n) { this._setElementValue(n), this._select && this._select.writeValue(this._select.value) } _setElementValue(n) { this._renderer.setProperty(this._element.nativeElement, "value", n) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } static \u0275fac = function (r) { return new (r || e)(E(yt), E(At), E(cr, 9)) }; static \u0275dir = Y({ type: e, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" }, standalone: !1 }) } return e })(), JI = { provide: sr, useExisting: Ke(() => Qm), multi: !0 }; function Sm(e, t) { return e == null ? `${t}` : (typeof t == "string" && (t = `'${t}'`), t && typeof t == "object" && (t = "Object"), `${e}: ${t}`.slice(0, 50)) } function XI(e) { return e.split(":")[0] } var Qm = (() => { class e extends na { value; _optionMap = new Map; _idCounter = 0; set compareWith(n) { this._compareWith = n } _compareWith = Object.is; writeValue(n) { this.value = n; let r; if (Array.isArray(n)) { let o = n.map(i => this._getOptionId(i)); r = (i, s) => { i._setSelected(o.indexOf(s.toString()) > -1) } } else r = (o, i) => { o._setSelected(!1) }; this._optionMap.forEach(r) } registerOnChange(n) { this.onChange = r => { let o = [], i = r.selectedOptions; if (i !== void 0) { let s = i; for (let a = 0; a < s.length; a++) { let l = s[a], c = this._getOptionValue(l.value); o.push(c) } } else { let s = r.options; for (let a = 0; a < s.length; a++) { let l = s[a]; if (l.selected) { let c = this._getOptionValue(l.value); o.push(c) } } } this.value = o, n(o) } } _registerOption(n) { let r = (this._idCounter++).toString(); return this._optionMap.set(r, n), r } _getOptionId(n) { for (let r of this._optionMap.keys()) if (this._compareWith(this._optionMap.get(r)._value, n)) return r; return null } _getOptionValue(n) { let r = XI(n); return this._optionMap.has(r) ? this._optionMap.get(r)._value : n } static \u0275fac = (() => { let n; return function (o) { return (n || (n = Nt(e)))(o || e) } })(); static \u0275dir = Y({ type: e, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function (r, o) { r & 1 && ge("change", function (s) { return o.onChange(s.target) })("blur", function () { return o.onTouched() }) }, inputs: { compareWith: "compareWith" }, standalone: !1, features: [Pt([JI]), Le] }) } return e })(), ca = (() => { class e { _element; _renderer; _select; id; _value; constructor(n, r, o) { this._element = n, this._renderer = r, this._select = o, this._select && (this.id = this._select._registerOption(this)) } set ngValue(n) { this._select != null && (this._value = n, this._setElementValue(Sm(this.id, n)), this._select.writeValue(this._select.value)) } set value(n) { this._select ? (this._value = n, this._setElementValue(Sm(this.id, n)), this._select.writeValue(this._select.value)) : this._setElementValue(n) } _setElementValue(n) { this._renderer.setProperty(this._element.nativeElement, "value", n) } _setSelected(n) { this._renderer.setProperty(this._element.nativeElement, "selected", n) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } static \u0275fac = function (r) { return new (r || e)(E(yt), E(At), E(Qm, 9)) }; static \u0275dir = Y({ type: e, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" }, standalone: !1 }) } return e })(); var Km = (() => { class e { static \u0275fac = function (r) { return new (r || e) }; static \u0275mod = et({ type: e }); static \u0275inj = Je({}) } return e })(), Uu = class extends ir { constructor(t, n, r) { super(qu(n), Wu(r, n)), this.controls = t, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } controls; at(t) { return this.controls[this._adjustIndex(t)] } push(t, n = {}) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } insert(t, n, r = {}) { this.controls.splice(t, 0, n), this._registerControl(n), this.updateValueAndValidity({ emitEvent: r.emitEvent }) } removeAt(t, n = {}) { let r = this._adjustIndex(t); r < 0 && (r = 0), this.controls[r] && this.controls[r]._registerOnCollectionChange(() => { }), this.controls.splice(r, 1), this.updateValueAndValidity({ emitEvent: n.emitEvent }) } setControl(t, n, r = {}) { let o = this._adjustIndex(t); o < 0 && (o = 0), this.controls[o] && this.controls[o]._registerOnCollectionChange(() => { }), this.controls.splice(o, 1), n && (this.controls.splice(o, 0, n), this._registerControl(n)), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, n = {}) { Hm(this, !1, t), t.forEach((r, o) => { $m(this, !1, o), this.at(o).setValue(r, { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n) } patchValue(t, n = {}) { t != null && (t.forEach((r, o) => { this.at(o) && this.at(o).patchValue(r, { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n)) } reset(t = [], n = {}) { this._forEachChild((r, o) => { r.reset(t[o], { onlySelf: !0, emitEvent: n.emitEvent }) }), this._updatePristine(n, this), this._updateTouched(n, this), this.updateValueAndValidity(n) } getRawValue() { return this.controls.map(t => t.getRawValue()) } clear(t = {}) { this.controls.length < 1 || (this._forEachChild(n => n._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: t.emitEvent })) } _adjustIndex(t) { return t < 0 ? t + this.length : t } _syncPendingControls() { let t = this.controls.reduce((n, r) => r._syncPendingControls() ? !0 : n, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _forEachChild(t) { this.controls.forEach((n, r) => { t(n, r) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(n => n.enabled && t(n)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _allControlsDisabled() { for (let t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } _find(t) { return this.at(t) ?? null } }; function Tm(e) { return !!e && (e.asyncValidators !== void 0 || e.validators !== void 0 || e.updateOn !== void 0) } var ua = (() => { class e { useNonNullable = !1; get nonNullable() { let n = new e; return n.useNonNullable = !0, n } group(n, r = null) { let o = this._reduceControls(n), i = {}; return Tm(r) ? i = r : r !== null && (i.validators = r.validator, i.asyncValidators = r.asyncValidator), new Xs(o, i) } record(n, r = null) { let o = this._reduceControls(n); return new ju(o, r) } control(n, r, o) { let i = {}; return this.useNonNullable ? (Tm(r) ? i = r : (i.validators = r, i.asyncValidators = o), new wo(n, P(m({}, i), { nonNullable: !0 }))) : new wo(n, r, o) } array(n, r, o) { let i = n.map(s => this._createControl(s)); return new Uu(i, r, o) } _reduceControls(n) { let r = {}; return Object.keys(n).forEach(o => { r[o] = this._createControl(n[o]) }), r } _createControl(n) { if (n instanceof wo) return n; if (n instanceof ir) return n; if (Array.isArray(n)) { let r = n[0], o = n.length > 1 ? n[1] : null, i = n.length > 2 ? n[2] : null; return this.control(r, o, i) } else return this.control(n) } static \u0275fac = function (r) { return new (r || e) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); var Jm = (() => { class e { static withConfig(n) { return { ngModule: e, providers: [{ provide: ia, useValue: n.callSetDisabledState ?? sa }] } } static \u0275fac = function (r) { return new (r || e) }; static \u0275mod = et({ type: e }); static \u0275inj = Je({ imports: [Km] }) } return e })(), da = (() => { class e { static withConfig(n) { return { ngModule: e, providers: [{ provide: Zm, useValue: n.warnOnNgModelWithFormControl ?? "always" }, { provide: ia, useValue: n.callSetDisabledState ?? sa }] } } static \u0275fac = function (r) { return new (r || e) }; static \u0275mod = et({ type: e }); static \u0275inj = Je({ imports: [Km] }) } return e })(); var st = class e { constructor(t) { this.http = t; this.loadInitialData() } pollutions$ = new ne([]); loadInitialData() { this.http.get("assets/pollution.json").subscribe(t => { this.pollutions$.next(t) }) } getPollutions() { return this.pollutions$.asObservable() } addPollution(t) { let n = this.pollutions$.getValue(); t.id = n.length + 1, this.pollutions$.next([...n, t]) } getOne(t) { return this.pollutions$.pipe(T(n => n.find(r => r.id === t))) } updatePollution(t, n) { let r = this.pollutions$.getValue(), o = r.findIndex(i => i.id === t); o !== -1 && (r[o] = P(m({}, n), { id: t }), this.pollutions$.next([...r])) } deletePollution(t) { let r = this.pollutions$.getValue().filter(o => o.id !== t); this.pollutions$.next(r) } static \u0275fac = function (n) { return new (n || e)(M(ys)) }; static \u0275prov = _({ token: e, factory: e.\u0275fac, providedIn: "root" }) }; var e0 = e => ["/pollutions", e], t0 = e => ["/pollutions/edit", e]; function n0(e, t) { if (e & 1) { let n = Hc(); b(0, "button", 15), ge("click", function () { ac(n); let o = ns().$implicit, i = ns(2); return lc(i.delete(o.id)) }), w(1, "Supprimer"), C() } } function r0(e, t) { if (e & 1 && (b(0, "li", 13), w(1), b(2, "button", 13), w(3, "Modifier"), C(), Rt(4, n0, 2, 0, "button", 14), C()), e & 2) { let n = t.$implicit; pe("routerLink", Wc(4, e0, n.id)), Z(), tt(" ", n.titre, " "), Z(), pe("routerLink", Wc(6, t0, n.id)), Z(2), pe("ngIf", n.id !== void 0) } } function o0(e, t) { if (e & 1 && (b(0, "ul"), Rt(1, r0, 5, 8, "li", 12), Lr(2, "filterByType"), C()), e & 2) { let n = t.ngIf, r = ns(); Z(), pe("ngForOf", Hp(2, 1, n, r.selectedType)) } } function i0(e, t) { e & 1 && w(0, "Chargement\u2026") } var ha = class e { constructor(t, n) { this.pollutionService = t; this.router = n } pollutions$; selectedType = ""; ngOnInit() { this.pollutions$ = this.pollutionService.getPollutions() } addPollution(t) { this.pollutionService.addPollution(t) } delete(t) { this.pollutionService.deletePollution(t), this.router.navigate(["/pollutions"]) } static \u0275fac = function (n) { return new (n || e)(E(st), E(Ae)) }; static \u0275cmp = ke({ type: e, selectors: [["app-liste-pollutions"]], decls: 25, vars: 5, consts: [["loading", ""], ["for", "filterType"], ["id", "filterType", 3, "ngModelChange", "ngModel"], ["value", ""], ["value", "plastique"], ["value", "chimique"], ["value", "depot sauvage"], ["value", "eau"], ["value", "air"], ["value", "autre"], ["routerLink", "/pollutions/add"], [4, "ngIf", "ngIfElse"], [3, "routerLink", 4, "ngFor", "ngForOf"], [3, "routerLink"], [3, "click", 4, "ngIf"], [3, "click"]], template: function (n, r) { if (n & 1) { let o = Hc(); b(0, "h2"), w(1, "Liste des pollutions"), C(), b(2, "label", 1), w(3, "Filtrer par type :"), C(), b(4, "select", 2), qc("ngModelChange", function (s) { return ac(o), jp(r.selectedType, s) || (r.selectedType = s), lc(s) }), b(5, "option", 3), w(6, "-- S\xE9lectionnez --"), C(), b(7, "option", 4), w(8, "Plastique"), C(), b(9, "option", 5), w(10, "Chimique"), C(), b(11, "option", 6), w(12, "D\xE9p\xF4t sauvage"), C(), b(13, "option", 7), w(14, "Eau"), C(), b(15, "option", 8), w(16, "Air"), C(), b(17, "option", 9), w(18, "Autre"), C()(), b(19, "button", 10), w(20, "Ajouter"), C(), Rt(21, o0, 3, 4, "ul", 11), Lr(22, "async"), Rt(23, i0, 1, 0, "ng-template", null, 0, Gp) } if (n & 2) { let o = Lp(24); Z(4), Gc("ngModel", r.selectedType), Z(17), pe("ngIf", rs(22, 3, r.pollutions$))("ngIfElse", o) } }, dependencies: [as, ss, Br, Ur, Bt, Ws, Jm, la, ca, cr, lr, Yu], styles: ["h2[_ngcontent-%COMP%]{color:#024520;text-shadow:0 2px 5px rgba(0,0,0,.3);margin-bottom:1rem}ul[_ngcontent-%COMP%]{list-style:none;padding:0;margin:0}ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{background:#12a01740;padding:.8rem 1rem;border-radius:10px;margin-bottom:.5rem;font-weight:500;display:flex;flex-direction:column;width:50%}button[_ngcontent-%COMP%]{align-self:center;background:linear-gradient(135deg,#4caf50,#2e7d32);border:none;color:#fff;padding:.8rem 1.2rem;border-radius:12px;cursor:pointer;font-size:1rem;font-weight:700;margin-top:1rem;transition:all .3s ease}"] }) }; function s0(e, t) { if (e & 1 && (b(0, "div", 1)(1, "h2"), w(2), C(), b(3, "ul")(4, "li")(5, "strong"), w(6, "Type :"), C(), w(7), C(), b(8, "li")(9, "strong"), w(10, "Description :"), C(), w(11), C(), b(12, "li")(13, "strong"), w(14, "Date :"), C(), w(15), C(), b(16, "li")(17, "strong"), w(18, "Lieu :"), C(), w(19), C(), b(20, "li")(21, "strong"), w(22, "Latitude :"), C(), w(23), C(), b(24, "li")(25, "strong"), w(26, "Longitude :"), C(), w(27), C(), q(28, "div", 2), C(), b(29, "button", 3), w(30, "Retour"), C()()), e & 2) { let n = t.ngIf; Z(2), zc("Pollution ", n.id, " - ", n.titre, ""), Z(5), tt(" ", n.type, ""), Z(4), tt(" ", n.description, ""), Z(4), tt(" ", n.date, ""), Z(4), tt(" ", n.lieu, ""), Z(4), tt(" ", n.latitude, ""), Z(4), tt(" ", n.longitude, ""), Z(), $c("background-image", "url(" + n.photo + ")") } } var ga = class e { constructor(t, n, r) { this.route = t; this.router = n; this.pollutionService = r } pollution$; ngOnInit() { this.pollution$ = this.route.paramMap.pipe(T(t => Number(t.get("id"))), se(t => this.pollutionService.getOne(t))) } static \u0275fac = function (n) { return new (n || e)(E(xe), E(Ae), E(st)) }; static \u0275cmp = ke({ type: e, selectors: [["app-details-pollution"]], decls: 2, vars: 3, consts: [["class", "recap", 4, "ngIf"], [1, "recap"], [1, "photo"], ["routerLink", "/pollutions"]], template: function (n, r) { n & 1 && (Rt(0, s0, 31, 10, "div", 0), Lr(1, "async")), n & 2 && pe("ngIf", rs(1, 1, r.pollution$)) }, dependencies: [Ur, Br, Bt], styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;background:url(https://images.unsplash.com/photo-1506744038136-46273834b3fb) no-repeat center center/cover}.recap[_ngcontent-%COMP%]{width:90%;max-width:500px;background:#68ac8c26;border-radius:20px;padding:2rem;backdrop-filter:blur(10px);box-shadow:0 4px 20px #0003;color:#024520;display:flex;flex-direction:column;gap:1rem}.recap[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{text-align:center;color:#024520;text-shadow:0 2px 5px rgba(0,0,0,.3);margin-bottom:1rem}.recap[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]{list-style:none;padding:0;margin:0}.recap[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{background:#ffffff40;padding:.8rem 1rem;border-radius:10px;margin-bottom:.5rem;font-weight:500;display:flex;flex-direction:column}.recap[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   strong[_ngcontent-%COMP%]{color:#013a1a;font-weight:700;margin-bottom:.2rem}.photo[_ngcontent-%COMP%]{width:100%;height:250px;border-radius:15px;background-size:cover;background-position:center;margin-top:1rem;box-shadow:0 4px 10px #0003}button[_ngcontent-%COMP%]{align-self:center;background:linear-gradient(135deg,#4caf50,#2e7d32);border:none;color:#fff;padding:.8rem 1.2rem;border-radius:12px;cursor:pointer;font-size:1rem;font-weight:700;margin-top:1rem;transition:all .3s ease}button[_ngcontent-%COMP%]:hover{background:linear-gradient(135deg,#66bb6a,#388e3c);transform:scale(1.03)}@media (max-width: 600px){.recap[_ngcontent-%COMP%]{padding:1.5rem}.recap[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-size:1.4rem}.photo[_ngcontent-%COMP%]{height:180px}}"] }) }; var ma = class e { constructor(t, n, r) { this.fb = t; this.pollutionService = n; this.router = r; this.pollutionForm = this.fb.group({ titre: ["", G.required], type: ["", G.required], description: ["", G.required], date: ["", G.required], lieu: ["", G.required], latitude: [null, [G.required, G.min(-90), G.max(90)]], longitude: [null, [G.required, G.min(-180), G.max(180)]], photo: [""] }) } pollutionForm; onSubmit() { this.pollutionForm.valid && (this.pollutionService.addPollution(this.pollutionForm.value), this.router.navigate(["/pollutions"])) } static \u0275fac = function (n) { return new (n || e)(E(ua), E(st), E(Ae)) }; static \u0275cmp = ke({ type: e, selectors: [["app-add-pollution"]], decls: 43, vars: 2, consts: [[1, "pollution-form", 3, "ngSubmit", "formGroup"], ["type", "text", "formControlName", "titre", "placeholder", "Titre de la pollution"], ["formControlName", "type"], ["value", ""], ["value", "plastique"], ["value", "chimique"], ["value", "depot sauvage"], ["value", "eau"], ["value", "air"], ["value", "autre"], ["formControlName", "description", "placeholder", "Description"], ["type", "date", "formControlName", "date"], ["type", "text", "formControlName", "lieu", "placeholder", "Lieu"], ["type", "number", "formControlName", "latitude", "placeholder", "Latitude"], ["type", "number", "formControlName", "longitude", "placeholder", "Longitude"], ["type", "url", "formControlName", "photo", "placeholder", "URL de la photo"], ["type", "submit", 3, "disabled"]], template: function (n, r) { n & 1 && (b(0, "h1"), w(1, "Pollution"), C(), b(2, "form", 0), ge("ngSubmit", function () { return r.onSubmit() }), b(3, "p"), w(4, " Titre : "), q(5, "input", 1), C(), b(6, "p"), w(7, " Type : "), b(8, "select", 2)(9, "option", 3), w(10, "-- S\xE9lectionnez --"), C(), b(11, "option", 4), w(12, "Plastique"), C(), b(13, "option", 5), w(14, "Chimique"), C(), b(15, "option", 6), w(16, "D\xE9p\xF4t sauvage"), C(), b(17, "option", 7), w(18, "Eau"), C(), b(19, "option", 8), w(20, "Air"), C(), b(21, "option", 9), w(22, "Autre"), C()()(), b(23, "p"), w(24, " Description : "), q(25, "textarea", 10), C(), b(26, "p"), w(27, " Date : "), q(28, "input", 11), C(), b(29, "p"), w(30, " Lieu : "), q(31, "input", 12), C(), b(32, "p"), w(33, " Latitude : "), q(34, "input", 13), C(), b(35, "p"), w(36, " Longitude : "), q(37, "input", 14), C(), b(38, "p"), w(39, " Photo : "), q(40, "input", 15), C(), b(41, "button", 16), w(42, "D\xE9clarer"), C()()), n & 2 && (Z(2), pe("formGroup", r.pollutionForm), Z(39), pe("disabled", r.pollutionForm.invalid)) }, dependencies: [da, aa, la, ca, ar, bo, cr, lr, ra, _o, Io], styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;background:url(https://images.unsplash.com/photo-1506744038136-46273834b3fb) no-repeat center center/cover}h1[_ngcontent-%COMP%]{color:#024520;text-shadow:0 2px 5px rgba(0,0,0,.3);margin-bottom:1rem}.pollution-form[_ngcontent-%COMP%]{width:90%;max-width:500px;background:#68ac8c26;border-radius:20px;padding:2rem;backdrop-filter:blur(10px);box-shadow:0 4px 20px #0003;color:#024520;display:flex;flex-direction:column;gap:1rem}.pollution-form[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{display:block;font-weight:600;margin-bottom:.3rem}.pollution-form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%], .pollution-form[_ngcontent-%COMP%]   select[_ngcontent-%COMP%], .pollution-form[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]{width:100%;padding:.7rem;border:none;border-radius:10px;background:#ffffff40;color:#024520;font-size:1rem;outline:none;transition:background .3s}.pollution-form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]::placeholder, .pollution-form[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]::placeholder{color:#3e3d3d}.pollution-form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]:focus, .pollution-form[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]:focus, .pollution-form[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]:focus{background:#fff6}.pollution-form[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{background:linear-gradient(135deg,#4caf50,#2e7d32);border:none;color:#fff;padding:.8rem;border-radius:12px;cursor:pointer;font-size:1.1rem;font-weight:700;transition:all .3s ease}.pollution-form[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover{background:linear-gradient(135deg,#66bb6a,#388e3c);transform:scale(1.03)}@media (max-width: 600px){.pollution-form[_ngcontent-%COMP%]{padding:1.5rem}h1[_ngcontent-%COMP%]{font-size:1.5rem}}"] }) }; var va = class e {
  constructor(t, n, r, o) { this.fb = t; this.route = n; this.router = r; this.pollutionService = o; this.pollutionForm = this.fb.group({ titre: ["", G.required], type: ["", G.required], description: ["", G.required], date: ["", G.required], lieu: ["", G.required], latitude: [null, [G.required, G.min(-90), G.max(90)]], longitude: [null, [G.required, G.min(-180), G.max(180)]], photo: [""] }) } pollutionForm; id; ngOnInit() { this.route.paramMap.pipe(se(t => (this.id = Number(t.get("id")), this.pollutionService.getOne(this.id)))).subscribe(t => { this.pollutionForm.patchValue(t) }) } onSubmit() { this.pollutionService.updatePollution(this.id, this.pollutionForm.value), this.router.navigate(["/pollutions"]) } static \u0275fac = function (n) { return new (n || e)(E(ua), E(xe), E(Ae), E(st)) }; static \u0275cmp = ke({
    type: e, selectors: [["app-edit-pollution"]], decls: 32, vars: 2, consts: [[3, "ngSubmit", "formGroup"], ["formControlName", "titre", "type", "text"], ["formControlName", "type", "type", "text"], ["formControlName", "description"], ["formControlName", "date", "type", "date"], ["formControlName", "lieu", "type", "text"], ["formControlName", "latitude", "type", "number"], ["formControlName", "longitude", "type", "number"], ["formControlName", "photo", "type", "text"], ["type", "submit", 3, "disabled"], ["routerLink", "/pollutions"]], template: function (n, r) {
      n & 1 && (b(0, "h2"), w(1, "Modifier une pollution"), C(), b(2, "form", 0), ge("ngSubmit", function () { return r.onSubmit() }), b(3, "label"), w(4, " Titre : "), q(5, "input", 1), C(), b(6, "label"), w(7, " Type : "), q(8, "input", 2), C(), b(9, "label"), w(10, " Description : "), q(11, "textarea", 3), C(), b(12, "label"), w(13, " Date : "), q(14, "input", 4), C(), b(15, "label"), w(16, " Lieu : "), q(17, "input", 5), C(), b(18, "label"), w(19, " Latitude : "), q(20, "input", 6), C(), b(21, "label"), w(22, " Longitude : "), q(23, "input", 7), C(), b(24, "label"), w(25, " Photo (URL) : "), q(26, "input", 8), C(), b(27, "button", 9), w(28, " \u2705 Enregistrer les modifications "), C()(), q(29, "br"), b(30, "button", 10), w(31, ` \u2B05\uFE0F Retour \xE0 la liste
`), C()), n & 2 && (Z(2), pe("formGroup", r.pollutionForm), Z(25), pe("disabled", r.pollutionForm.invalid))
    }, dependencies: [da, aa, ar, bo, lr, ra, _o, Io, Bt], styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;background:url(https://images.unsplash.com/photo-1506744038136-46273834b3fb) no-repeat center center/cover}h1[_ngcontent-%COMP%]{color:#024520;text-shadow:0 2px 5px rgba(0,0,0,.3);margin-bottom:1rem}.pollution-form[_ngcontent-%COMP%]{width:90%;max-width:500px;background:#68ac8c26;border-radius:20px;padding:2rem;backdrop-filter:blur(10px);box-shadow:0 4px 20px #0003;color:#024520;display:flex;flex-direction:column;gap:1rem}.pollution-form[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{display:block;font-weight:600;margin-bottom:.3rem}.pollution-form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%], .pollution-form[_ngcontent-%COMP%]   select[_ngcontent-%COMP%], .pollution-form[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]{width:100%;padding:.7rem;border:none;border-radius:10px;background:#ffffff40;color:#024520;font-size:1rem;outline:none;transition:background .3s}.pollution-form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]::placeholder, .pollution-form[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]::placeholder{color:#3e3d3d}.pollution-form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]:focus, .pollution-form[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]:focus, .pollution-form[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]:focus{background:#fff6}.pollution-form[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{background:linear-gradient(135deg,#4caf50,#2e7d32);border:none;color:#fff;padding:.8rem;border-radius:12px;cursor:pointer;font-size:1.1rem;font-weight:700;transition:all .3s ease}.pollution-form[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover{background:linear-gradient(135deg,#66bb6a,#388e3c);transform:scale(1.03)}@media (max-width: 600px){.pollution-form[_ngcontent-%COMP%]{padding:1.5rem}h1[_ngcontent-%COMP%]{font-size:1.5rem}}"]
  })
}; var Xm = [{ path: "", redirectTo: "pollutions", pathMatch: "full" }, { path: "pollutions", component: ha }, { path: "pollutions/add", component: ma }, { path: "pollutions/:id", component: ga }, { path: "pollutions/edit/:id", component: va }]; var ev = { providers: [Zp({ eventCoalescing: !0 }), Fu(Xm), du()] }; var ya = class e { title = "tp6"; static \u0275fac = function (n) { return new (n || e) }; static \u0275cmp = ke({ type: e, selectors: [["app-root"]], decls: 1, vars: 0, template: function (n, r) { n & 1 && q(0, "router-outlet") }, dependencies: [po], encapsulation: 2 }) }; lu(ya, ev).catch(e => console.error(e));
